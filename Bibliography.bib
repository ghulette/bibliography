%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/


%% Created for Geoff Hulette at 2010-01-13 16:27:10 -0800 


%% Saved with string encoding Unicode (UTF-8) 



@inproceedings{ravitch09bindings,
	Abstract = {High-level languages are growing in popularity. However, decades of C software development have produced large libraries of fast, time-tested, meritorious code that are impractical to recreate from scratch. Cross-language bindings can expose low-level C code to high-level languages. Unfortunately, writing bindings by hand is tedious and error-prone, while mainstream binding generators require extensive manual annotation or fail to offer the language features that users of modern languages have come to expect.

We present an improved binding-generation strategy based on static analysis of unannotated library source code. We characterize three high-level idioms that are not uniquely expressible in C's low-level type system: array parameters, resource managers, and multiple return values. We describe a suite of interprocedural analyses that recover this high-level information, and we show how the results can be used in a binding generator for the Python programming language. In experiments with four large C libraries, we find that our approach avoids the mistakes characteristic of hand-written bindings while offering a level of Python integration unmatched by prior automated approaches. Among the thousands of functions in the public interfaces of these libraries, roughly 40% exhibit the behaviors detected by our static analyses.},
	Address = {Dublin, Ireland},
	Author = {Tristan Ravitch and Steve Jackson and Eric Aderhold and Ben Liblit},
	Booktitle = {{Proceedings of the ACM SIGPLAN 2009 Conference on Programming Language Design and Implementation}},
	Date-Added = {2010-01-13 10:31:05 -0800},
	Date-Modified = {2010-01-13 10:32:32 -0800},
	Keywords = {generator,bindings},
	Month = jun,
	Organization = {{ACM}},
	Pages = {15--20},
	Title = {Automatic Generation of Library Bindings Using Static Analysis},
	Year = 2009,
	Bdsk-Url-1 = {http://pages.cs.wisc.edu/~liblit/pldi-2009-b/},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVyYXZpdGNoMDliaW5kaW5ncy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATpVkx3NRmwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHc8IbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyYXZpdGNoMDliaW5kaW5ncy5wZGYADgAsABUAcgBhAHYAaQB0AGMAaAAwADkAYgBpAG4AZABpAG4AZwBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3Jhdml0Y2gwOWJpbmRpbmdzLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvcmF2aXRjaDA5YmluZGluZ3MucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5}}

@book{panda07ejb,
	Abstract = {An EJB 3 tutorial.},
	Address = {Greenwich, CT, USA},
	Author = {Panda, Debu and Rahman, Reza and Lane, Derek},
	Date-Added = {2010-01-11 17:16:56 -0800},
	Date-Modified = {2010-01-11 17:17:42 -0800},
	Isbn = {1932394931},
	Publisher = {Manning Publications Co.},
	Title = {{EJB 3 in Action}},
	Year = {2007},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?id=1202848}}

@misc{folk2003attributes,
	Author = {Folk, M. and Barkstrom, B.R.},
	Date-Added = {2010-01-05 13:13:06 -0800},
	Date-Modified = {2010-01-05 13:17:23 -0800},
	Keywords = {hdf5},
	Title = {{Attributes of file formats for long-term preservation of scientific and engineering data in digital libraries}},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZmb2xrMjAwM2F0dHJpYnV0ZXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASEnAx2jrNgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHaVu2AAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmb2xrMjAwM2F0dHJpYnV0ZXMucGRmAAAOAC4AFgBmAG8AbABrADIAMAAwADMAYQB0AHQAcgBpAGIAdQB0AGUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9mb2xrMjAwM2F0dHJpYnV0ZXMucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L2ZvbGsyMDAzYXR0cmlidXRlcy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=}}

@misc{folk2000introduction,
	Abstract = {SIides introducing HDF5.},
	Author = {Folk, M.},
	Date-Added = {2010-01-05 13:10:12 -0800},
	Date-Modified = {2010-01-05 13:11:35 -0800},
	Howpublished = {http://hdf.ncsa.uiuc.edu/HDF5/papers},
	Institution = {NCSA/University of Illinois at Urbana-Champaign},
	Keywords = {hdf5},
	Title = {{Introduction to HDF5}},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdgAAAAAAdgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRhmb2xrMjAwMGludHJvZHVjdGlvbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASEjcx2jqTAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHaVrMAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBTTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmb2xrMjAwMGludHJvZHVjdGlvbi5wZGYAAA4AMgAYAGYAbwBsAGsAMgAwADAAMABpAG4AdAByAG8AZAB1AGMAdABpAG8AbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9mb2xrMjAwMGludHJvZHVjdGlvbi5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QIExpYnJhcnkvZm9sazIwMDBpbnRyb2R1Y3Rpb24ucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnwCfgKDAowClwKbAqkCsAK5AtwC4QLkAvEC9gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMI},
	Bdsk-Url-1 = {http://hdf.ncsa.uiuc.edu/HDF5/papers}}

@manual{mathworksmexfiles,
	Abstract = {Technical documentation for Matlab's MEX files, which provide an interface from Matlab to C.},
	Date-Added = {2010-01-05 11:47:04 -0800},
	Date-Modified = {2010-01-05 11:50:55 -0800},
	Keywords = {ffi,matlab},
	Organization = {The Mathworks},
	Title = {{MEX-files Guide}},
	Url = {http://www.mathworks.com/support/tech-notes/1600/1605.html},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVtYXRod29ya3NtZXhmaWxlcy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASENJx2jYDgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHaUiOAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptYXRod29ya3NtZXhmaWxlcy5wZGYADgAsABUAbQBhAHQAaAB3AG8AcgBrAHMAbQBlAHgAZgBpAGwAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L21hdGh3b3Jrc21leGZpbGVzLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvbWF0aHdvcmtzbWV4ZmlsZXMucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5},
	Bdsk-Url-1 = {http://www.mathworks.com/support/tech-notes/1600/1605.html}}

@article{birrell84rpc,
	Address = {New York, NY, USA},
	Author = {Birrell, Andrew D. and Nelson, Bruce Jay},
	Date-Added = {2010-01-04 21:19:40 -0800},
	Date-Modified = {2010-01-04 21:20:00 -0800},
	Doi = {http://doi.acm.org/10.1145/2080.357392},
	Issn = {0734-2071},
	Journal = {ACM Trans. Comput. Syst.},
	Number = {1},
	Pages = {39--59},
	Publisher = {ACM},
	Title = {Implementing remote procedure calls},
	Volume = {2},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBiaXJyZWxsODRycGMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASDdtx2gMSgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHaHzKAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpiaXJyZWxsODRycGMucGRmAAAOACIAEABiAGkAcgByAGUAbABsADgANAByAHAAYwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9iaXJyZWxsODRycGMucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2JpcnJlbGw4NHJwYy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/2080.357392}}

@inproceedings{barrett96polyspin,
	Abstract = {Interoperability is a fundamental concern in many areas of software engineering, such as software reuse or infrastructures for software development environments. Of particular interest to software engineers are the interoperability problems arising in polylingual software systems. The defining characteristic of polylingual systems is their focus on uniform interaction among a set of components written in two or more different languages. Existing approaches to support for interoperability are inadequate because they lack seamlessness: that is, they generally force software developers to compensate explicitly for the existence of multiple languages or the crossing of language boundaries. In this paper we first discuss some foundations for polylingual interoperability, then review and assess existing approaches. We then outline PolySPIN, an approach in which interoperability can be made transparent and existing systems can be made to interoperate with no visible modifications.},
	Author = {Daniel J. Barrett and Alan Kaplan and Jack C. Wileden},
	Booktitle = {In ACM SIGSOFT'96, Fourth Symposium on the Foundations of Software Engineering},
	Date-Added = {2009-12-22 16:14:44 -0500},
	Date-Modified = {2010-01-06 14:03:26 -0800},
	Pages = {147--155},
	Title = {Automated Support for Seamless Interoperability in Polylingual Software Systems},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRViYXJyZXR0OTZwb2x5c3Bpbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR4qEx1Z24gAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVudiAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpiYXJyZXR0OTZwb2x5c3Bpbi5wZGYADgAsABUAYgBhAHIAcgBlAHQAdAA5ADYAcABvAGwAeQBzAHAAaQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2JhcnJldHQ5NnBvbHlzcGluLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvYmFycmV0dDk2cG9seXNwaW4ucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5}}

@conference{janssen94ilu,
	Address = {Portland, OR},
	Author = {Bill Janssen and Mike Spreitzer},
	Booktitle = {Workshop on Multi-language Object Models},
	Date-Added = {2009-12-22 15:44:21 -0500},
	Date-Modified = {2009-12-22 15:48:16 -0500},
	Month = {August},
	Title = {{ILU}: Inter-language unification via object modules},
	Year = {1994},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBqYW5zc2VuOTRpbHUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR4gix1ZvnAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVuAcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpqYW5zc2VuOTRpbHUucGRmAAAOACIAEABqAGEAbgBzAHMAZQBuADkANABpAGwAdQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9qYW5zc2VuOTRpbHUucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2phbnNzZW45NGlsdS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=}}

@phdthesis{bracha92jigsaw,
	Abstract = {Mixins},
	Address = {Salt Lake City, UT, USA},
	Author = {Bracha, Gilad},
	Date-Added = {2009-12-20 13:33:22 -0500},
	Date-Modified = {2009-12-20 13:33:22 -0500},
	Keywords = {mixins},
	Order_No = {UMI Order No. GAX92-14893},
	Publisher = {University of Utah},
	Title = {The programming language jigsaw: mixins, modularity and multiple inheritance},
	Year = {1992},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJicmFjaGE5MmppZ3Nhdy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eLx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpicmFjaGE5MmppZ3Nhdy5wZGYAAA4AJgASAGIAcgBhAGMAaABhADkAMgBqAGkAZwBzAGEAdwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9icmFjaGE5MmppZ3Nhdy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvYnJhY2hhOTJqaWdzYXcucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq}}

@article{batory97genvoca,
	Abstract = {GenVoca generators synthesize software systems by composing components from reuse libraries. GenVoca components are designed to export and import standardized interfaces, and thus be plug-compatible, interchangeable, and interoperable with other components. In this paper, we examine two different but important issues in software system synthesis. First, not all syntactically correct compositions of components are semantically correct. We present simple, efficient, and domain-independent algorithms for validating compositions of GenVoca components. Second, components that export and import immutable interfaces are too restrictive for software system synthesis. We show that the interfaces and bodies of GenVoca components are subjective, i.e., they mutate and enlarge upon instantiation. This mutability enables software systems with customized interfaces to be composed from components with "standardized" interfaces.},
	Address = {Piscataway, NJ, USA},
	Author = {Batory, Don and Geraci, Bart J.},
	Date-Added = {2009-12-20 13:32:55 -0500},
	Date-Modified = {2009-12-20 13:32:55 -0500},
	Doi = {http://dx.doi.org/10.1109/32.585497},
	Issn = {0098-5589},
	Journal = {IEEE Trans. Softw. Eng.},
	Keywords = {component},
	Number = {2},
	Pages = {67--82},
	Publisher = {IEEE Press},
	Title = {Composition Validation and Subjectivity in GenVoca Generators},
	Volume = {23},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNiYXRvcnk5N2dlbnZvY2EucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eGx1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpiYXRvcnk5N2dlbnZvY2EucGRmAA4AKAATAGIAYQB0AG8AcgB5ADkANwBnAGUAbgB2AG8AYwBhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2JhdG9yeTk3Z2Vudm9jYS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2JhdG9yeTk3Z2Vudm9jYS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=}}

@article{hartono09orio,
	Abstract = {For many scientific applications, significant time is spent in tuning codes for a particular high-performance architecture. Tuning approaches range from the relatively nonintrusive (e.g., by using compiler options) to extensive code modifications that attempt to exploit specific architecture features. Intrusive techniques often result in code changes that are not easily reversible, and can negatively impact readability, maintainability, and performance on different architectures. We introduce an extensible annotation-based empirical tuning system called Orio that is aimed at improving both performance and productivity. It allows software developers to insert annotations in the form of structured comments into their source code to trigger a number of low-level performance optimizations on a specified code fragment. To maximize the performance tuning opportunities, the annotation processing infrastructure is designed to support both architecture-independent and architecture-specific code optimizations. Given the annotated code as input, Orio generates many tuned versions of the same operation and empirically evaluates the alternatives to select the best performing version for production use. We have also enabled the use of the Pluto automatic parallelization tool in conjunction with Orio to generate efficient OpenMP-based parallel code. We describe our experimental results involving a number of computational kernels, including dense array and sparse matrix operations.},
	Address = {Los Alamitos, CA, USA},
	Author = {Albert Hartono and Boyana Norris and P. Sadayappan},
	Date-Added = {2009-12-14 12:34:21 -0800},
	Date-Modified = {2009-12-14 12:35:58 -0800},
	Doi = {http://doi.ieeecomputersociety.org/10.1109/IPDPS.2009.5161004},
	Isbn = {978-1-4244-3751-1},
	Journal = {Parallel and Distributed Processing Symposium, International},
	Pages = {1-11},
	Publisher = {IEEE Computer Society},
	Title = {Annotation-based empirical performance tuning using Orio},
	Volume = {0},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFoYXJ0b25vMDlvcmlvLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fBx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpoYXJ0b25vMDlvcmlvLnBkZgAOACQAEQBoAGEAcgB0AG8AbgBvADAAOQBvAHIAaQBvAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2hhcnRvbm8wOW9yaW8ucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9oYXJ0b25vMDlvcmlvLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://trac.mcs.anl.gov/projects/performance/wiki/Orio}}

@article{milner78atheory,
	Abstract = {The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple pro-gramming language, and a compile time type-checking algorithm w which enforces the discipline. A Semantic Soundness Theorem (based on a formal semantics for the language) states that well-type programs cannot ``go wrong '' and a Syntactic Soundness Theorem states that if fl accepts a program then it is well typed. We also discuss extending these results to richer languages; a type-checking algorithm based on w is in fact already implemented and working, for the metalanguage ML in the Edinburgh LCF system, 1.},
	Author = {Robin Milner},
	Date-Added = {2009-12-11 15:05:06 -0800},
	Date-Modified = {2009-12-11 15:05:22 -0800},
	Journal = {Journal of Computer and System Sciences},
	Pages = {348--375},
	Title = {A theory of type polymorphism in programming},
	Volume = {17},
	Year = {1978},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNtaWxuZXI3OGF0aGVvcnkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fwx1O5IgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmiAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptaWxuZXI3OGF0aGVvcnkucGRmAA4AKAATAG0AaQBsAG4AZQByADcAOABhAHQAaABlAG8AcgB5AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L21pbG5lcjc4YXRoZW9yeS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L21pbG5lcjc4YXRoZW9yeS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=}}

@inproceedings{lindlan98pdt,
	Abstract = {Developers of static and dynamic analysis tools for C++ programs need access to information on functions, classes, templates, and macros in parsed C++ code. Existing tools, such as the EDG display tool, provide that access, but in an unsuitable format. We built a converter that prunes and reorganizes the information into the appropriate format. The converter provides the information needed for our TAU (Tuning and Analysis Utilities) tools and, in more general terms, provides C++ developers considerable opportunities for automating software development.},
	Address = {New York, NY, USA},
	Author = {Lindlan, Kathleen and Cuny, Janice and Malony, Allen D. and Shende, Sameer and Beckman, Peter},
	Booktitle = {SPDT '98: Proceedings of the SIGMETRICS symposium on Parallel and distributed tools},
	Date-Added = {2009-12-11 14:35:10 -0800},
	Date-Modified = {2009-12-11 14:35:49 -0800},
	Doi = {http://doi.acm.org/10.1145/281035.281055},
	Isbn = {1-58113-001-5},
	Pages = {153},
	Publisher = {ACM},
	Title = {An IL converter and program database for analysis tools},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBsaW5kbGFuOThwZHQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fmx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsaW5kbGFuOThwZHQucGRmAAAOACIAEABsAGkAbgBkAGwAYQBuADkAOABwAGQAdAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9saW5kbGFuOThwZHQucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2xpbmRsYW45OHBkdC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/281035.281055}}

@phdthesis{ridgway04polylingual,
	Annote = {Can't find this thesis anywhere.},
	Author = {Ridgway, John V. E.},
	Date-Added = {2009-12-11 12:59:47 -0800},
	Date-Modified = {2009-12-11 14:20:49 -0800},
	Isbn = {0-496-13274-1},
	School = {University of Massachusetts Amherst},
	Title = {Foundations for polylingual systems},
	Year = {2004},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?id=1087170#}}

@article{wilson94suif,
	Abstract = {Compiler infrastructures that support experimental research are crucial to the advancement of high-performance computing. New compiler technology must be implemented and evaluated in the context of a complete compiler, but developing such an infrastructure requires a huge investment in time and resources. We have spent a number of years building the SUIF compiler into a powerful, flexible system, and we would now like to share the results of our efforts.SUIF consists of a small, clearly documented kernel and a toolkit of compiler passes built on top of the kernel. The kernel defines the intermediate representation, provides functions to access and manipulate the intermediate representation, and structures the interface between compiler passes. The toolkit currently includes C and Fortran front ends, a loop-level parallelism and locality optimizer, an optimizing MIPS back end, a set of compiler development tools, and support for instructional use.Although we do not expect SUIF to be suitable for everyone, we think it may be useful for many other researchers. We thus invite you to use SUIF and welcome your contributions to this infrastructure. Directions for obtaining the SUIF software are included at the end of this paper.},
	Address = {New York, NY, USA},
	Author = {Wilson, Robert P. and French, Robert S. and Wilson, Christopher S. and Amarasinghe, Saman P. and Anderson, Jennifer M. and Tjiang, Steve W. K. and Liao, Shih-Wei and Tseng, Chau-Wen and Hall, Mary W. and Lam, Monica S. and Hennessy, John L.},
	Date-Added = {2009-12-11 12:55:03 -0800},
	Date-Modified = {2009-12-11 12:56:41 -0800},
	Doi = {http://doi.acm.org/10.1145/193209.193217},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {compiler},
	Number = {12},
	Pages = {31--37},
	Publisher = {ACM},
	Title = {SUIF: an infrastructure for research on parallelizing and optimizing compilers},
	Volume = {29},
	Year = {1994},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRB3aWxzb245NHN1aWYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gkx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp3aWxzb245NHN1aWYucGRmAAAOACIAEAB3AGkAbABzAG8AbgA5ADQAcwB1AGkAZgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS93aWxzb245NHN1aWYucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L3dpbHNvbjk0c3VpZi5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/193209.193217}}

@electronic{spec00soap11,
	Author = {W3C},
	Date-Added = {2009-12-11 12:43:14 -0800},
	Date-Modified = {2009-12-11 12:44:44 -0800},
	Keywords = {rpc},
	Title = {Simple Object Access Protocol (SOAP) 1.1},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBzcGVjMDBzb2FwMTEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gWx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzcGVjMDBzb2FwMTEucGRmAAAOACIAEABzAHAAZQBjADAAMABzAG8AYQBwADEAMQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9zcGVjMDBzb2FwMTEucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L3NwZWMwMHNvYXAxMS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://www.w3.org/TR/2000/NOTE-SOAP-20000508/}}

@electronic{spec03xmlrpc,
	Author = {Dave Winer},
	Date-Added = {2009-12-11 12:37:37 -0800},
	Date-Modified = {2009-12-11 12:40:54 -0800},
	Keywords = {rpc},
	Title = {XML-RPC Specification},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBzcGVjMDN4bWxycGMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gXx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzcGVjMDN4bWxycGMucGRmAAAOACIAEABzAHAAZQBjADAAMwB4AG0AbAByAHAAYwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9zcGVjMDN4bWxycGMucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L3NwZWMwM3htbHJwYy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://www.xmlrpc.com/spec}}

@inproceedings{rasmussen01chasm,
	Abstract = {The relative simplicity and design of the Fortran 77 language allowed for reasonable interoperability with C and C++. Fortran 90, on the other hand, introduces several new and complex features to the language that severely degrade the ability of a mixed Fortran and C++ development environment. Major new items added to Fortran are userdefined types, pointers, and several new array features. Each of these items introduce difficulties because the Fortran 90 procedure calling convention was not designed with interoperability as an important design goal. For example, Fortran 90 arrays are passed by array descriptor, which is not specified by the language and therefore depends on a particular compiler implementation. This paper describes a set of software tools that parses Fortran 90 source code and produces mediating interface functions which allow access to Fortran 90 libraries from C++.},
	Author = {C. E. Rasmussen and K. A. Lindlan and B. Mohr and J. Striegnitz and Forschungszentrum Jlich},
	Booktitle = {In Proceedings of the Los Alamos Computer Science Symposium 2001 (LACSI'01},
	Date-Added = {2009-12-10 17:59:09 -0800},
	Date-Modified = {2009-12-10 17:59:58 -0800},
	Title = {{CHASM: Static Analysis and Automatic Code Generation for Improved Fortran 90 and C++ Interoperability}},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRyYXNtdXNzZW4wMWNoYXNtLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gEx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyYXNtdXNzZW4wMWNoYXNtLnBkZgAADgAqABQAcgBhAHMAbQB1AHMAcwBlAG4AMAAxAGMAaABhAHMAbQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9yYXNtdXNzZW4wMWNoYXNtLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9yYXNtdXNzZW4wMWNoYXNtLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==}}

@article{kaplan98idl,
	Abstract = {The dominant approach to addressing heterogeneity, interoperability and legacy software components at present is based on the use of interface description languages (IDLs) such as the OMG/CORBA IDL. We believe that this approach has serious drawbacks. In this paper we outline our objections to the IDL-based approach, then describe ongoing research directed toward producing a superior alternative, which we refer to as the polylingual systems approach. We illustrate both our objections to the IDL-based approach and also our new polylingual systems approach with examples based on the IWSSD common case study.},
	Address = {Los Alamitos, CA, USA},
	Author = {A. Kaplan and J. Ridgway and J.C. Wileden},
	Date-Added = {2009-12-10 17:34:15 -0800},
	Date-Modified = {2009-12-10 17:55:13 -0800},
	Doi = {10.1109/IWSSD.1998.667913},
	Issn = {1063-6765},
	Journal = {Software Specification and Design, International Workshop on},
	Keywords = {idl},
	Pages = {2},
	Publisher = {IEEE Computer Society},
	Title = {Why {IDL}s are Not Ideal},
	Volume = {0},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9rYXBsYW45OGlkbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fVx1O5HwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmfAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTprYXBsYW45OGlkbC5wZGYADgAgAA8AawBhAHAAbABhAG4AOQA4AGkAZABsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2thcGxhbjk4aWRsLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkva2FwbGFuOThpZGwucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/IWSSD.1998.667913}}

@article{murphy08open64,
	Abstract = {NVIDIA uses Open64 as part of its CUDA toolchain for general purpose computing using GPUs. Open64 was chosen for the strength of its optimizations, and its usage has been a success, though there have been some difficulties. This paper will give an overview of its usage, the modifications that were made, and some thoughts about future usage.},
	Author = {Mike Murphy},
	Date-Added = {2009-12-09 18:40:40 -0800},
	Date-Modified = {2009-12-10 17:06:56 -0800},
	Journal = {Open64 Workshop at CGO '08},
	Keywords = {whirl,open64},
	Title = {{NVIDIA's experience with Open64}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJtdXJwaHkwOG9wZW42NC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f0x1O5IwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmjAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptdXJwaHkwOG9wZW42NC5wZGYAAA4AJgASAG0AdQByAHAAaAB5ADAAOABvAHAAZQBuADYANAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9tdXJwaHkwOG9wZW42NC5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvbXVycGh5MDhvcGVuNjQucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://www.capsl.udel.edu/conferences/open64/2008/}}

@article{liao06openuh,
	Abstract = {OpenMP has gained wide popularity as an API for parallel programming on shared memory and distributed shared memory platforms. Despite its broad availability, there remains a need for a portable, robust, open source, optimizing OpenMP compiler for C/C++/Fortran 90, especially for teaching and research, for example into its use on new target architectures, such as SMPs with chip multi-threading, as well as learning how to translate for clusters of SMPs. In this paper, we present our efforts to design and implement such an OpenMP compiler on top of Open64, an open source compiler framework, by extending its existing analysis and optimization and adopting a source-to-source translator approach where a native back end is not available. The compilation strategy we have adopted and the corresponding runtime support are described. The OpenMP validation suite is used to determine the correctness of the translation. The compiler's behavior is evaluated using benchmark tests from the EPCC microbenchmarks and the NAS parallel benchmark. },
	Author = {Chunhua Liao and Oscar Hernandez and Barbara Chapman and Wenguang Chen and Weimin Zheng},
	Date-Added = {2009-12-09 18:28:08 -0800},
	Date-Modified = {2009-12-10 17:07:23 -0800},
	Journal = {Concurrency and Computation: Practice and Experience},
	Keywords = {compiler},
	Number = {18},
	Pages = {2317--2332},
	Title = {{OpenUH: an optimizing, portable OpenMP compiler}},
	Volume = {19},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBsaWFvMDZvcGVudWgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1flx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsaWFvMDZvcGVudWgucGRmAAAOACIAEABsAGkAYQBvADAANgBvAHAAZQBuAHUAaAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9saWFvMDZvcGVudWgucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2xpYW8wNm9wZW51aC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=}}

@inproceedings{swamy09coercions,
	Abstract = {A number of important program rewriting scenarios can be recast as type-directed coercion insertion. These range from more theoretical applications such as coercive subtyping and supporting overloading in type theories, to more practical applications such as integrating static and dynamically typed code using gradual typing, and inlining code to enforce security policies such as access control and provenance tracking. In this paper we give a general theory of type-directed coercion insertion. We specifically explore the inherent tradeoff between expressiveness and ambiguity--the more powerful the strategy for generating coercions, the greater the possibility of several, semantically distinct rewritings for a given program. We consider increasingly powerful coercion generation strategies, work out example applications supported by the increased power (including those mentioned above), and identify the inherent ambiguity problems of each setting, along with various techniques to tame the ambiguities.

},
	Address = {New York, NY, USA},
	Author = {Swamy, Nikhil and Hicks, Michael and Bierman, Gavin M.},
	Booktitle = {ICFP '09: Proceedings of the 14th ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2009-12-09 18:11:53 -0800},
	Date-Modified = {2009-12-09 18:13:19 -0800},
	Doi = {http://doi.acm.org/10.1145/1596550.1596598},
	Isbn = {978-1-60558-332-7},
	Keywords = {types,subtypes,coercion},
	Location = {Edinburgh, Scotland},
	Pages = {329--340},
	Publisher = {ACM},
	Title = {A theory of typed coercions and its applications},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRzd2FteTA5Y29lcmNpb25zLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gYx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzd2FteTA5Y29lcmNpb25zLnBkZgAADgAqABQAcwB3AGEAbQB5ADAAOQBjAG8AZQByAGMAaQBvAG4AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9zd2FteTA5Y29lcmNpb25zLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9zd2FteTA5Y29lcmNpb25zLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1596550.1596598}}

@article{breazu91coercion,
	Address = {Duluth, MN, USA},
	Author = {Breazu-Tannen, Val and Coquand, Thierry and Gunter, Carl A. and Scedrov, Andre},
	Date-Added = {2009-12-09 18:04:02 -0800},
	Date-Modified = {2009-12-09 18:12:55 -0800},
	Doi = {10.1016/0890-5401(91)90055-7},
	Issn = {0890-5401},
	Journal = {Information and Computation},
	Keywords = {subtypes,types,coercion},
	Number = {1},
	Pages = {172--221},
	Publisher = {Academic Press, Inc.},
	Title = {Inheritance as implicit coercion},
	Volume = {93},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRicmVhenU5MWNvZXJjaW9uLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eMx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpicmVhenU5MWNvZXJjaW9uLnBkZgAADgAqABQAYgByAGUAYQB6AHUAOQAxAGMAbwBlAHIAYwBpAG8AbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9icmVhenU5MWNvZXJjaW9uLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9icmVhenU5MWNvZXJjaW9uLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1016/0890-5401(91)90055-7}}

@inproceedings{cardelli88asemantics,
	Abstract = {This paper is to present a clean semantics of multiple inheritance and to show that, in the context of strongly-typed, statically-scoped languages, a sound typechecking algorithm exists. Multiple inheritance is also interpreted in a broad sense: instead of being limited to objects, it is extended in a natural way to union types and to higher-order functional types. This constitutes a semantic basis for the unification of functional and object-oriented programming.},
	Author = {Luca Cardelli},
	Booktitle = {Information and Computation},
	Date-Added = {2009-12-08 17:40:57 -0800},
	Date-Modified = {2009-12-08 17:41:55 -0800},
	Keywords = {types,subtypes},
	Pages = {51--67},
	Publisher = {Springer-Verlag},
	Title = {A Semantics of Multiple Inheritance},
	Year = {1988},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdgAAAAAAdgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRhjYXJkZWxsaTg4YXNlbWFudGljcy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eSx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBTTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjYXJkZWxsaTg4YXNlbWFudGljcy5wZGYAAA4AMgAYAGMAYQByAGQAZQBsAGwAaQA4ADgAYQBzAGUAbQBhAG4AdABpAGMAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9jYXJkZWxsaTg4YXNlbWFudGljcy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QIExpYnJhcnkvY2FyZGVsbGk4OGFzZW1hbnRpY3MucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnwCfgKDAowClwKbAqkCsAK5AtwC4QLkAvEC9gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMI}}

@inbook{pierce02reconstruct,
	Author = {Benjamin C. Pierce},
	Chapter = {22 Type Reconstruction},
	Date-Added = {2009-12-08 17:33:44 -0800},
	Date-Modified = {2009-12-08 17:34:15 -0800},
	Edition = {1},
	Keywords = {pl,types},
	Month = {February},
	Pages = {181--207},
	Publisher = {MIT Press},
	Title = {Types and Programming Languages},
	Year = {2002},
	Bdsk-Url-1 = {http://www.cis.upenn.edu/~bcpierce/tapl/}}

@inbook{pierce02rectypes,
	Author = {Benjamin C. Pierce},
	Chapter = {20 Recursive Types},
	Date-Added = {2009-12-08 17:33:09 -0800},
	Date-Modified = {2009-12-08 17:33:44 -0800},
	Edition = {1},
	Keywords = {pl,types},
	Month = {February},
	Pages = {181--207},
	Publisher = {MIT Press},
	Title = {Types and Programming Languages},
	Year = {2002},
	Bdsk-Url-1 = {http://www.cis.upenn.edu/~bcpierce/tapl/}}

@inbook{pierce02subtypingtheory,
	Author = {Benjamin C. Pierce},
	Chapter = {16 Metatheory of Subtyping},
	Date-Added = {2009-12-07 11:36:08 -0800},
	Date-Modified = {2009-12-08 17:34:45 -0800},
	Edition = {1},
	Keywords = {pl,types},
	Month = {February},
	Pages = {181--207},
	Publisher = {MIT Press},
	Title = {Types and Programming Languages},
	Year = {2002},
	Bdsk-Url-1 = {http://www.cis.upenn.edu/~bcpierce/tapl/}}

@inbook{pierce02subtyping,
	Author = {Benjamin C. Pierce},
	Chapter = {15 Subtyping},
	Date-Added = {2009-12-07 11:34:26 -0800},
	Date-Modified = {2009-12-08 17:34:38 -0800},
	Edition = {1},
	Keywords = {pl,types},
	Month = {February},
	Pages = {181--207},
	Publisher = {MIT Press},
	Title = {Types and Programming Languages},
	Year = {2002},
	Bdsk-Url-1 = {http://www.cis.upenn.edu/~bcpierce/tapl/}}

@phdthesis{dahlgren07contract,
	Abstract = {Several performance-driven approaches to selectively enforce interface contracts for scientific components are investigated. The goal is to facilitate debugging deployed applications built from plug-and-play components while keeping the cost of enforcement within acceptable overhead limits.  This paper describes a study of global enforcement using a priori execution cost estimates obtained from traces. Thirteen trials are formed from five, single-component programs. Enforcement experiments conducted using twenty-three enforcement policies are used to determine the nature of exercised contracts and the impact of a variety of sampling strategies. Performance-driven enforcement appears to be best suited to programs that exercise moderately expensive contracts.   },
	Author = {Dahlgren, Tamara},
	Date-Added = {2009-11-24 13:36:20 -0800},
	Date-Modified = {2009-11-24 13:36:20 -0800},
	Keywords = {component},
	School = {UC Davis},
	Title = {Performance-Driven Interface Contract Enforcement for Scientific Components},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZkYWhsZ3JlbjA3Y29udHJhY3QucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eex1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpkYWhsZ3JlbjA3Y29udHJhY3QucGRmAAAOAC4AFgBkAGEAaABsAGcAcgBlAG4AMAA3AGMAbwBuAHQAcgBhAGMAdAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9kYWhsZ3JlbjA3Y29udHJhY3QucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L2RhaGxncmVuMDdjb250cmFjdC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=}}

@article{aho89twig,
	Abstract = {Compiler-component generators, such as lexical analyzer generators and parser generators, have long been used to facilitate the construction of compilers. A tree-manipulation language called twig has been developed to help construct efficient code generators. Twig transforms a tree-translation scheme into a code generator that combines a fast top-down tree-pattern matching algorithm with dynamic programming. Twig has been used to specify and construct code generators for several experimental compilers targeted for different machines.},
	Address = {New York, NY, USA},
	Author = {Aho, Alfred V. and Ganapathi, Mahadevan and Tjiang, Steven W. K.},
	Date-Added = {2009-10-27 10:22:54 -0700},
	Date-Modified = {2009-10-27 10:24:41 -0700},
	Doi = {10.1145/69558.75700},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {generator,pl},
	Number = {4},
	Pages = {491--516},
	Publisher = {ACM},
	Title = {Code generation using tree matching and dynamic programming},
	Volume = {11},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAawAAAAAAawAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ1haG84OXR3aWcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d7x1O5FgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmWAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBITWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphaG84OXR3aWcucGRmAA4AHAANAGEAaABvADgAOQB0AHcAaQBnAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA7VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2Fobzg5dHdpZy5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBVMaWJyYXJ5L2Fobzg5dHdpZy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACUAJSAlcCYAJrAm8CfQKEAo0CpQKqAq0CugK/AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtE=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/69558.75700}}

@inproceedings{schordan03rose,
	Annote = {Recent vverview of the ROSE architecture.},
	Author = {Markus Schordan and Daniel Quinlan},
	Booktitle = {JMLC'03: Joint Modular Languages Conference},
	Date-Added = {2009-10-22 18:03:07 -0700},
	Date-Modified = {2009-10-22 18:06:15 -0700},
	Keywords = {compiler,rose},
	Month = aug,
	Pages = {214--223},
	Publisher = {Springer Verlag},
	Series = {Lecture Notes in Computer Science},
	Title = {A Source-To-Source Architecture for User-Defined Optimizations},
	Volume = {2789},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJzY2hvcmRhbjAzcm9zZS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gOx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzY2hvcmRhbjAzcm9zZS5wZGYAAA4AJgASAHMAYwBoAG8AcgBkAGEAbgAwADMAcgBvAHMAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9zY2hvcmRhbjAzcm9zZS5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvc2Nob3JkYW4wM3Jvc2UucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://www.rosecompiler.org/ROSE_HTML_Reference/ProjectPublications.html}}

@article{bentley86little,
	Abstract = {When you say "language," most programmers think of the big ones, like FORTRAN or COBOL or Pascal. In fact, a language is any mechanism to express intent, and the input to many programs can be viewed profitably as statements in a language. This column is about those ``little languages.''},
	Address = {New York, NY, USA},
	Author = {Bentley, Jon},
	Date-Added = {2009-10-22 17:43:13 -0700},
	Date-Modified = {2009-10-22 17:45:09 -0700},
	Doi = {http://doi.acm.org/10.1145/6424.315691},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Keywords = {dsl},
	Number = {8},
	Pages = {711--721},
	Publisher = {ACM},
	Title = {Programming pearls: little languages},
	Volume = {29},
	Year = {1986},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNiZW50bGV5ODZsaXR0bGUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f8x1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpiZW50bGV5ODZsaXR0bGUucGRmAA4AKAATAGIAZQBuAHQAbABlAHkAOAA2AGwAaQB0AHQAbABlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2JlbnRsZXk4NmxpdHRsZS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2JlbnRsZXk4NmxpdHRsZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/6424.315691}}

@article{deursen00dsls,
	Abstract = {We survey the literature available on the topic of domain-specific languages as used for the construction and maintenance of software systems. We list a selection of 75 key publications in the area, and provide a summary for each of the papers. Moreover, we discuss terminology, risks and benefits, example domain-specific languages, design methodologies, and implementation techniques.},
	Author = {Deursen, A. van and P. Klint and J. Visser},
	Date-Added = {2009-10-22 17:33:45 -0700},
	Date-Modified = {2009-10-22 17:42:15 -0700},
	Journal = {ACM SIGPLAN Notices},
	Keywords = {dsl},
	Month = jun,
	Number = 6,
	Pages = {26--36},
	Title = {Domain-Specific Languages: An Annotated Bibliography},
	Volume = 35,
	Year = 2000,
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFkZXVyc2VuMDBkc2xzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eix1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpkZXVyc2VuMDBkc2xzLnBkZgAOACQAEQBkAGUAdQByAHMAZQBuADAAMABkAHMAbABzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2RldXJzZW4wMGRzbHMucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9kZXVyc2VuMDBkc2xzLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://homepages.cwi.nl/~arie/papers/dslbib/}}

@article{clavel97maude,
	Author = {M. Clavel and S. Eker and J. Meseguer},
	Date-Added = {2009-10-22 17:21:15 -0700},
	Date-Modified = {2009-10-22 17:42:29 -0700},
	Journal = {Electronic Notes in Theoretical Computer Science 4},
	Keywords = {rewriting},
	Title = {Principles of Maude},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFjbGF2ZWw5N21hdWRlLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eXx1O5GQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmZAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjbGF2ZWw5N21hdWRlLnBkZgAOACQAEQBjAGwAYQB2AGUAbAA5ADcAbQBhAHUAZABlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2NsYXZlbDk3bWF1ZGUucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9jbGF2ZWw5N21hdWRlLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==}}

@inproceedings{smaragdakis97distil,
	Abstract = {DiSTiL is a software generator that implements a declarative domain-specific language (DSL) for container data structures. DiSTiL is a representative of a new approach to domain-specific language implementation. Instead of being the usual one-of-a-kind stand-alone compiler, DiSTiL is an extension library for the Intentional Programming (IP) transformation system (currently under development by Microsoft Research). DiSTiL relies on several reusable, general-purpose infrastructure tools offered by IP that substantially simplify DSL implementation.},
	Address = {Berkeley, CA, USA},
	Author = {Yannis Smaragdakis and Don Batory},
	Booktitle = {DSL'97: Proceedings of the Conference on Domain-Specific Languages on Conference on Domain-Specific Languages},
	Date-Added = {2009-10-22 17:03:23 -0700},
	Date-Modified = {2009-10-22 17:05:12 -0700},
	Keywords = {pl,rewriting},
	Location = {Santa Barbara, California},
	Publisher = {USENIX Association},
	Title = {{DiSTiL}: a transformation library for data structures},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdQAAAAAAdQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRdzbWFyYWdkYWtpczk3ZGlzdGlsLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gSx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBSTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzbWFyYWdkYWtpczk3ZGlzdGlsLnBkZgAOADAAFwBzAG0AYQByAGEAZwBkAGEAawBpAHMAOQA3AGQAaQBzAHQAaQBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBFVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3NtYXJhZ2Rha2lzOTdkaXN0aWwucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAfTGlicmFyeS9zbWFyYWdkYWtpczk3ZGlzdGlsLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJ4AnoCfwKIApMClwKlAqwCtQLXAtwC3wLsAvEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADAw==}}

@techreport{quinlan99rose,
	Abstract = {ROSE is a preprocessor generation tool for the support of compile time performance optimizations in Overture. The Overture framework is an object-oriented environment for solving partial differential equations in two and three space dimensions. It is a collection of C++ libraries that enables the use of finite difference and finite volume methods at a level that hides the details of the associated data structures. Overture can be used to solve problems in complicated, moving geometries using the method of overlapping grids. It has support for grid generation, difference operators, boundary conditions, database access and graphics. In this paper we briefly present Overture, and discuss our approach toward performance within Overture and the A++P++ array class abstractions upon which Overture depends, this work represents some of the newest work in Overture. The results we present show that the abstractions represented within Overture and the A++P++ array class library can be used to obtain application codes with performance equivalent to that of optimized C and Fortran 77. ROSE, the preprocessor generation tool, is general in its application to any object-oriented framework or application and is not specific to Overture.},
	Author = {Daniel Quinlan},
	Date-Added = {2009-10-22 15:59:21 -0700},
	Date-Modified = {2009-10-22 18:06:06 -0700},
	Institution = {US Department of Energy},
	Keywords = {rose,compiler},
	Number = {UCRL-ID-136515},
	Title = {ROSE: Compiler Support for Object-Oriented Frameworks},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFxdWlubGFuOTlyb3NlLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gBx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpxdWlubGFuOTlyb3NlLnBkZgAOACQAEQBxAHUAaQBuAGwAYQBuADkAOQByAG8AcwBlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3F1aW5sYW45OXJvc2UucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9xdWlubGFuOTlyb3NlLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://www.osti.gov/energycitations/product.biblio.jsp?osti_id=793936}}

@article{hudak96embedded,
	Address = {New York, NY, USA},
	Author = {Paul Hudak},
	Date-Added = {2009-10-22 15:56:04 -0700},
	Date-Modified = {2009-10-22 15:58:15 -0700},
	Doi = {10.1145/242224.242477},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {dsl,embedded},
	Month = {December},
	Pages = {196},
	Publisher = {ACM},
	Title = {Building domain-specific embedded languages},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNodWRhazk2ZW1iZWRkZWQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fIx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpodWRhazk2ZW1iZWRkZWQucGRmAA4AKAATAGgAdQBkAGEAawA5ADYAZQBtAGIAZQBkAGQAZQBkAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2h1ZGFrOTZlbWJlZGRlZC5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2h1ZGFrOTZlbWJlZGRlZC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/242224.242477}}

@inproceedings{ramsey10hoopl,
	Abstract = {We present Hoopl, a Haskell library that makes it easy for compiler writers to implement program transformations based on dataflow analyses. The compiler writer must identify (a) logical assertions on which the transformation will be based; (b) a representation of such assertions, which should form a lattice of finite height; (c) transfer functions that approximate weakest preconditions or strongest postconditions over the assertions; and (d) rewrite functions whose soundness is justified by the assertions. Hoopl uses the algorithm of Lerner, Grove, and Chambers (2002), which can compose very simple analyses and transformations in a way that achieves the same precision as complex, handwritten ``super-analyses.'' Hoopl will be the workhorse of a new back end for the Glasgow Haskell Compiler (version 6.12, forthcoming). },
	Author = {Norman Ramsey and Joao Dias and Simon Peyton Jones},
	Booktitle = {POPL '10},
	Date-Added = {2009-08-10 20:11:31 -0700},
	Date-Modified = {2009-08-10 20:13:18 -0700},
	Keywords = {pl,dataflow},
	Title = {Hoopl: Dataflow Optimization Made Simple},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFyYW1zZXkxMGhvb3BsLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gDx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyYW1zZXkxMGhvb3BsLnBkZgAOACQAEQByAGEAbQBzAGUAeQAxADAAaABvAG8AcABsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3JhbXNleTEwaG9vcGwucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9yYW1zZXkxMGhvb3BsLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://www.cs.tufts.edu/~nr/pubs/dfopt-abstract.html}}

@techreport{bertot08coq,
	Abstract = {These notes provide a quick introduction to the Coq system and show how it can be used to define logical concepts and functions and reason about them. It is designed as a tutorial, so that readers can quickly start their own experiments, learning only a few of the capabilities of the system. A much more comprehensive study is provided in [1], which also provides an extensive collection of exercises to train on.},
	Author = {Yves Bertot},
	Date-Added = {2009-08-10 19:16:14 -0700},
	Date-Modified = {2009-08-10 19:18:18 -0700},
	Institution = {INRIA},
	Keywords = {pl,coq},
	Month = {October},
	Number = {inria-00001173},
	Title = {Coq in a Hurry},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9iZXJ0b3QwOGNvcS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eJx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpiZXJ0b3QwOGNvcS5wZGYADgAgAA8AYgBlAHIAdABvAHQAMAA4AGMAbwBxAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2JlcnRvdDA4Y29xLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvYmVydG90MDhjb3EucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://cel.archives-ouvertes.fr/inria-00001173/fr/}}

@article{hughes00generalising,
	Author = {Hughes, J.},
	Date-Added = {2009-07-31 01:45:29 -0400},
	Date-Modified = {2009-07-31 01:46:29 -0400},
	Journal = {Science of computer programming},
	Keywords = {pl,arrows,monad},
	Number = {1-3},
	Pages = {67--111},
	Title = {{Generalising monads to arrows}},
	Volume = {37},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdgAAAAAAdgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRhodWdoZXMwMGdlbmVyYWxpc2luZy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fKx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBTTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpodWdoZXMwMGdlbmVyYWxpc2luZy5wZGYAAA4AMgAYAGgAdQBnAGgAZQBzADAAMABnAGUAbgBlAHIAYQBsAGkAcwBpAG4AZwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9odWdoZXMwMGdlbmVyYWxpc2luZy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QIExpYnJhcnkvaHVnaGVzMDBnZW5lcmFsaXNpbmcucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnwCfgKDAowClwKbAqkCsAK5AtwC4QLkAvEC9gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMI}}

@article{hudak03arrows,
	Abstract = {Functional reactive programming, or FRP, is a paradigm for programming hybrid systems -- i.e., systems containing a combination of both continuous and discrete components -- in a high-level, declarative way. The key ideas in FRP are its notions of continuous, time-varying values, and time-ordered sequences of discrete events.
Yampa is an instantiation of FRP as a domain-specific language embedded in Haskell. This paper describes Yampa in detail, and shows how it can be used to program a particular kind of hybrid system: a mobile robot. Because performance is critical in robotic programming, Yampa uses arrows (a generalization of monads) to create a disciplined style of programming with time-varying values that helps ensure that common kinds of time- and space-leaks do not occur.},
	Author = {Hudak, P. and Courtney, A. and Nilsson, H. and Peterson, J.},
	Date-Added = {2009-07-31 01:24:39 -0400},
	Date-Modified = {2009-07-31 01:25:35 -0400},
	Journal = {Lecture Notes in Computer Science},
	Keywords = {pl,arrows,frp},
	Pages = {159--187},
	Publisher = {Springer},
	Title = {{Arrows, robots, and functional reactive programming}},
	Volume = {2638},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFodWRhazAzYXJyb3dzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fHx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpodWRhazAzYXJyb3dzLnBkZgAOACQAEQBoAHUAZABhAGsAMAAzAGEAcgByAG8AdwBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2h1ZGFrMDNhcnJvd3MucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9odWRhazAzYXJyb3dzLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==}}

@article{ludascher05workflow,
	Abstract = {Many scientific disciplines are now data and information driven, and new scientific knowledge is often gained by scientists putting together data analysis and knowledge discovery ``pipelines''. A related trend is that more and more scientific communities realize the benefits of sharing their data and computational services, and are thus contributing to a distributed data and computational community infrastructure (a.k.a. ``the Grid''). However, this infrastructure is only a means to an end and scientists ideally should be bothered little with its existence. The goal is for scientists to focus on development and use of what we call scientific workflows. These are networks of analytical steps that may involve, e.g., database access and querying steps, data analysis and mining steps, and many other steps including computationally intensive jobs on high performance cluster computers. In this paper we describe characteristics of and requirements for scientific workflows as identified in a number of our application projects. We then elaborate on Kepler, a particular scientific workflow system, currently under development across a number of scientific data management projects. We describe some key features of Kepler and its underlying Ptolemy II system, planned extensions, and areas of future research. Kepler is a community-driven, open source project, and we always welcome related projects and new contributors to join.
},
	Author = {B. Ludascher and I. Altintas and C. Berkley and D. Higgins and E. Jaeger-Frank and M. Jones and E. Lee and J. Tao and Y. Zhao},
	Date-Added = {2009-07-27 19:41:44 -0700},
	Date-Modified = {2009-08-03 13:37:18 -0400},
	Journal = {Concurrency and Computation: Practice \& Experience},
	Keywords = {workflow,dataflow,haskell},
	Title = {Scientific Workflow Management and the Kepler System},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdQAAAAAAdQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRdsdWRhc2NoZXIwNXdvcmtmbG93LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fox1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBSTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsdWRhc2NoZXIwNXdvcmtmbG93LnBkZgAOADAAFwBsAHUAZABhAHMAYwBoAGUAcgAwADUAdwBvAHIAawBmAGwAbwB3AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBFVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2x1ZGFzY2hlcjA1d29ya2Zsb3cucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAfTGlicmFyeS9sdWRhc2NoZXIwNXdvcmtmbG93LnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJ4AnoCfwKIApMClwKlAqwCtQLXAtwC3wLsAvEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADAw==},
	Bdsk-Url-1 = {https://kepler-project.org/publications?tags=keplerworkflow}}

@techreport{ludascher03providing,
	Abstract = {In this technical note we first describe in some detail the structure of the Promoter-Identification-Workflow (PIW) demonstrated at SSDBM. We then point out some serious shortcomings of the current prototype. At the root of these problems lies a lack of capabilities for programming with collections (such as lists). We then propose a simple solution to this problem, based on a functional programming approach. The use of, e.g., Haskell as an underlying formal model has a number of advantages including clear semantics, compatibility with process networks, and powerful support for typing of workflows. We now have a host of workflow design and programming constructs we would like to add to Ptolemy II to make it a true SPA tool.},
	Author = {Bertram Ludascher and Ilkay Altintas},
	Date-Added = {2009-07-27 18:37:08 -0700},
	Date-Modified = {2009-07-27 21:06:25 -0700},
	Institution = {San Diego Supercomputer Center, UC San Diego},
	Keywords = {workflow,haskell},
	Month = {August},
	Title = {On Providing Declarative Design and Programming Constructs for Scientific Workflows based on Process Networks},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdgAAAAAAdgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRhsdWRhc2NoZXIwM3Byb3ZpZGluZy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fnx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBTTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsdWRhc2NoZXIwM3Byb3ZpZGluZy5wZGYAAA4AMgAYAGwAdQBkAGEAcwBjAGgAZQByADAAMwBwAHIAbwB2AGkAZABpAG4AZwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9sdWRhc2NoZXIwM3Byb3ZpZGluZy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QIExpYnJhcnkvbHVkYXNjaGVyMDNwcm92aWRpbmcucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnwCfgKDAowClwKbAqkCsAK5AtwC4QLkAvEC9gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMI},
	Bdsk-Url-1 = {http://sites.google.com/site/ludaesch/p}}

@inproceedings{lee95dataflowprocess,
	Abstract = {We review a model of computation used in industrial practice in signal processing software environments and experimentally in other contexts. We give this model the name "dataflow process networks," and study its formal properties as well as its utility as a basis for programming language design. Variants of this model are used in commercial visual programming systems such as SPW from the Alta Group of Cadence (formerly Comdisco Systems), COSSAP from Synopsys (formerly Cadis), the DSP Station from Mentor Graphics, and Hypersignal from Hyperception. They are also used in research software such as Khoros from the University of New Mexico and Ptolemy from the University of California at Berkeley, among many others. Dataflow process networks are shown to be a special case of Kahn process networks, a model of computation where a number of concurrent processes communicate through unidirectional FIFO channels, where writes to the channel are non-blocking, and reads are blocking. In dataflow process networks, each process consists of repeated "firings" of a dataflow "actor". An actor defines a (often functional) quantum of computation. By dividing processes into actor firings, the considerable overhead of context switching incurred in most implementations of Kahn process networks is avoided. We relate dataflow process networks to other dataflow models, including those used in dataflow machines, such as static dataflow and the tagged-token model. We also relate dataflow process networks to functional languages such as Haskell, and show that modern language concepts such as higher-order functions and polymorphism can be used effectively in dataflow process networks. A number of programming examples using a visual syntax are given.},
	Author = {Edward A. Lee and Thomas Parks},
	Booktitle = {Proceedings of the IEEE},
	Date-Added = {2009-07-27 18:32:54 -0700},
	Date-Modified = {2009-07-27 18:41:16 -0700},
	Keywords = {dataflow,workflow},
	Pages = {773--799},
	Title = {Dataflow Process Networks},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdgAAAAAAdgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRhsZWU5NWRhdGFmbG93cHJvY2Vzcy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fix1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBTTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsZWU5NWRhdGFmbG93cHJvY2Vzcy5wZGYAAA4AMgAYAGwAZQBlADkANQBkAGEAdABhAGYAbABvAHcAcAByAG8AYwBlAHMAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9sZWU5NWRhdGFmbG93cHJvY2Vzcy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QIExpYnJhcnkvbGVlOTVkYXRhZmxvd3Byb2Nlc3MucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnwCfgKDAowClwKbAqkCsAK5AtwC4QLkAvEC9gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMI},
	Bdsk-Url-1 = {http://ptolemy.eecs.berkeley.edu/papers/95/}}

@inproceedings{heidrich95automatic,
	Abstract = {In the past few years Tcl has found widespread interest as a extensible scripting language. Numerous Tcl interfaces for a variety of C libraries have been created. While most of these language bindings have been created by hand, others have made use of dedicated code generators designed for the specific library. In this paper we present a tool for the automatic generation of Tcl language bindings for arbitrary C libraries. Moreover, the mapping of C++ class hierarchies to [incr Tcl] classes will be described. 1 Introduction 1.1 Prior Work One of the reasons for the recent success of Tcl is its powerful API to C and C++, which allows the extension of the core language with commands implemented as C functions. This facility has been used to create a variety of language bindings for C libraries, ranging from different 3D graphics libraries (iris gl, OpenGL, vogle, sipp) to several X widget sets, for example Wafe and tclMotif.},
	Author = {Wolfgang Heidrich and Philipp Slusallek},
	Booktitle = {In Proceedings of the Tcl/Tk Workshop},
	Date-Added = {2009-06-25 17:26:59 -0700},
	Date-Modified = {2009-06-25 17:29:36 -0700},
	Keywords = {pl,ffi},
	Title = {Automatic Generation of {Tcl} Bindings for {C} and {C++} Libraries},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdQAAAAAAdQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRdoZWlkcmljaDk1YXV0b21hdGljLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fCx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBSTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpoZWlkcmljaDk1YXV0b21hdGljLnBkZgAOADAAFwBoAGUAaQBkAHIAaQBjAGgAOQA1AGEAdQB0AG8AbQBhAHQAaQBjAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBFVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2hlaWRyaWNoOTVhdXRvbWF0aWMucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAfTGlicmFyeS9oZWlkcmljaDk1YXV0b21hdGljLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJ4AnoCfwKIApMClwKlAqwCtQLXAtwC3wLsAvEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADAw==},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.9367}}

@article{ousterhout97scripting,
	Abstract = {A fundamental change is occurring in the way people write computer programs, away from system programming languages such as C or C++ to scripting languages such as Perl or Tcl. Although many people are participating in the change, few realize that the change is occurring and even fewer know why it is happening. This article explains why scripting languages will handle many of the programming tasks in the next century better than system programming languages. System programming languages were designed for building data structures and algorithms from scratch, starting from the most primitive computer elements. Scripting languages are designed for gluing. They assume the existence of a set of powerful components and are intended primarily for connecting components.},
	Author = {John K. Ousterhout},
	Date-Added = {2009-06-25 13:36:01 -0700},
	Date-Modified = {2009-06-25 13:39:27 -0700},
	Journal = {IEEE Computer},
	Keywords = {pl,scripting},
	Pages = {23--30},
	Title = {Scripting: Higher Level Programming for the 21st Century},
	Volume = {31},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdwAAAAAAdwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRlvdXN0ZXJob3V0OTdzY3JpcHRpbmcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f7x1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBUTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpvdXN0ZXJob3V0OTdzY3JpcHRpbmcucGRmAA4ANAAZAG8AdQBzAHQAZQByAGgAbwB1AHQAOQA3AHMAYwByAGkAcAB0AGkAbgBnAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBHVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L291c3RlcmhvdXQ5N3NjcmlwdGluZy5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfECFMaWJyYXJ5L291c3RlcmhvdXQ5N3NjcmlwdGluZy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACgAKCAocCkAKbAp8CrQK0Ar0C4QLmAukC9gL7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAw0=},
	Bdsk-Url-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=660187}}

@techreport{slee07thrift,
	Abstract = {Thrift is a software framework for scalable cross-language services development. It combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk, and OCaml.},
	Address = {Palo Alto, CA},
	Author = {Mark Slee and Aditya Agarwal and Marc Kwiatkowski},
	Date-Added = {2009-06-16 16:01:51 -0700},
	Date-Modified = {2009-06-16 16:04:17 -0700},
	Institution = {Facebook},
	Keywords = {rpc},
	Month = {April},
	Title = {Thrift: Scalable Cross-Language Services Implementation},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBzbGVlMDd0aHJpZnQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gRx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzbGVlMDd0aHJpZnQucGRmAAAOACIAEABzAGwAZQBlADAANwB0AGgAcgBpAGYAdAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9zbGVlMDd0aHJpZnQucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L3NsZWUwN3RocmlmdC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://incubator.apache.org/thrift/}}

@article{appel98ssa,
	Abstract = {Static Single-Assignment (SSA) form is an intermediate language designed to make optimization clean and efficient for imperative-language (Fortran, C) compilers. Lambda-calculus is an intermediate language that makes optimization clean and efficient for functional-language (Scheme, ML, Haskell) compilers. The SSA community draws pictures of graphs with basic blocks and flow edges, and the functional-language community writes lexically nested functions, but (as Richard Kelsey recently pointed out [9]) they're both doing exactly the same thing in different notation.
},
	Address = {New York, NY, USA},
	Author = {Andrew W. Appel},
	Date-Added = {2009-06-15 21:08:20 -0700},
	Date-Modified = {2009-06-15 21:10:34 -0700},
	Journal = {ACM SIGPLAN Notices},
	Keywords = {pl,functional,ssa},
	Number = {4},
	Pages = {17--20},
	Publisher = {ACM},
	Title = {SSA is functional programming},
	Volume = {33},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ5hcHBlbDk4c3NhLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eAx1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphcHBlbDk4c3NhLnBkZgAADgAeAA4AYQBwAHAAZQBsADkAOABzAHMAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9hcHBlbDk4c3NhLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS9hcHBlbDk4c3NhLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/278283.278285}}

@article{tay90rpc,
	Abstract = {The Remote Procedure Call (RPC) is a popular paradigm for inter-process communication (IPC) between processes in different computers across the network. It is widely used in various Distributed Systems. Although it is conceptually simple and straightforward to implement, there are a lot of different and subtle issues involved which result different RPC implementations. In this paper, various distinctive RPC implementations are surveyed, analyzed and compared: Xerox Courier RPC, Xerox Cedar RPC, Sun ONC/RPC, Apollo NCA/RPC, Cambridge Mayflower Project RPC, MIT Athena Project RPC, Stanford Modula/V RPC, and Rajdoot RPC are presented. The design objectives, features provided, call semantics, orphan treatment, binding, transport protocols supported, security/authentication, data representation and application programming interface of these RPCs are examined.},
	Address = {New York, NY, USA},
	Author = {B. H. Tay and A. L. Ananda},
	Date-Added = {2009-06-15 17:41:21 -0700},
	Date-Modified = {2009-06-15 21:10:42 -0700},
	Journal = {SIGOPS Oper. Syst. Rev.},
	Keywords = {rpc},
	Number = {3},
	Pages = {68--79},
	Publisher = {ACM},
	Title = {A survey of remote procedure calls},
	Volume = {24},
	Year = {1990},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAagAAAAAAagAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQx0YXk5MHJwYy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gax1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBHTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp0YXk5MHJwYy5wZGYAAA4AGgAMAHQAYQB5ADkAMAByAHAAYwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAOlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS90YXk5MHJwYy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QFExpYnJhcnkvdGF5OTBycGMucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAkwCTgJTAlwCZwJrAnkCgAKJAqACpQKoArUCugAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALM},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/382244.382832}}

@misc{rfc1832,
	Author = {R. Srinivasan},
	Date-Added = {2009-06-15 17:40:18 -0700},
	Date-Modified = {2009-06-15 21:11:05 -0700},
	Howpublished = {RFC 1832 (Draft Standard)},
	Keywords = {rpc},
	Month = August,
	Note = {Obsoleted by RFC 4506},
	Number = {1832},
	Organization = {Internet Engineering Task Force},
	Publisher = {IETF},
	Series = {Request for Comments},
	Title = {{XDR: External Data Representation Standard}},
	Url = {http://www.ietf.org/rfc/rfc1832.txt},
	Year = 1995,
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQtyZmMxODMyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gJx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBGTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyZmMxODMyLnBkZgAOABgACwByAGYAYwAxADgAMwAyAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA5VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3JmYzE4MzIucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxATTGlicmFyeS9yZmMxODMyLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJIAkoCTwJYAmMCZwJ1AnwChQKbAqACowKwArUAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACxw==},
	Bdsk-Url-1 = {http://www.ietf.org/rfc/rfc1832.txt}}

@inbook{coulouris94sunrpc,
	Author = {George Coulouris and Jean Dolllimore and Tim Kindberg},
	Chapter = {Sun RPC},
	Date-Added = {2009-06-15 17:34:04 -0700},
	Date-Modified = {2009-06-15 21:11:44 -0700},
	Edition = {2},
	Keywords = {distributed,rpc},
	Pages = {138--144},
	Publisher = {Addison Wesley},
	Series = {International Computer Science},
	Title = {Distributed Systems: Concepts and Design},
	Year = {1994},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVjb3Vsb3VyaXM5NHN1bnJwYy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ebx1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjb3Vsb3VyaXM5NHN1bnJwYy5wZGYADgAsABUAYwBvAHUAbABvAHUAcgBpAHMAOQA0AHMAdQBuAHIAcABjAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2NvdWxvdXJpczk0c3VucnBjLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvY291bG91cmlzOTRzdW5ycGMucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5}}

@inproceedings{abadi89dynamic,
	Abstract = {Statically-typed programming languages allow earlier error checking, better enforcement of disciplined programming styles, and generation of more efficient object code than languages where all type-consistency checks are performed at runtime. However, even in statically-type languages, there is often the need to deal with data whose type cannot be known at compile time. To handle such situations safely, we propose to add a type Dynamic whose values are pairs of a value v and a type tag T where v has the type denoted by T. Instances of Dynamic are built with an explicit tagging construct and inspected with a type-safe typecase construct. This paper is an exploration of the syntax, operational semantics, and denotational semantics of a simple language with the type Dynamic. We give examples of how dynamically-typed values might be used in programming. Then we discuss an operational semantics for our language and obtain a soundness theorem. We present two formulations of the denotational semantics of this language and relate them to the operational semantics. Finally, we consider the implications of polymorphism and some implementation issues.
},
	Address = {New York, NY, USA},
	Author = {Martin Abadi and Luca Cardelli and Benjamin C. Pierce and Gordon Plotkin},
	Booktitle = {POPL '89: Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2009-06-15 16:42:15 -0700},
	Date-Modified = {2009-06-15 16:43:48 -0700},
	Keywords = {types},
	Location = {Austin, Texas, United States},
	Pages = {213--227},
	Publisher = {ACM},
	Title = {Dynamic typing in a statically-typed language},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJhYmFkaTg5ZHluYW1pYy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d4x1O5FQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmVAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphYmFkaTg5ZHluYW1pYy5wZGYAAA4AJgASAGEAYgBhAGQAaQA4ADkAZAB5AG4AYQBtAGkAYwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9hYmFkaTg5ZHluYW1pYy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvYWJhZGk4OWR5bmFtaWMucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/75277.75296}}

@inproceedings{flanagan06hybrid,
	Abstract = {Traditional static type systems are very effective for verifying basic interface specifications, but are somewhat limited in the kinds specifications they support. Dynamically-checked contracts can enforce more precise specifications, but these are not checked until run time, resulting in incomplete detection of defects.Hybrid type checking is a synthesis of these two approaches that enforces precise interface specifications, via static analysis where possible, but also via dynamic checks where necessary. This paper explores the key ideas and implications of hybrid type checking, in the context of the simply-typed λ-calculus with arbitrary refinements of base types.},
	Address = {New York, NY, USA},
	Author = {Cormac Flanagan},
	Booktitle = {POPL '06: Conference record of the 33rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2009-06-15 16:40:11 -0700},
	Date-Modified = {2009-06-15 16:40:51 -0700},
	Keywords = {types,component,ffi},
	Location = {Charleston, South Carolina, USA},
	Pages = {245--256},
	Publisher = {ACM},
	Title = {Hybrid type checking},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRmbGFuYWdhbjA2aHlicmlkLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1etx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmbGFuYWdhbjA2aHlicmlkLnBkZgAADgAqABQAZgBsAGEAbgBhAGcAYQBuADAANgBoAHkAYgByAGkAZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9mbGFuYWdhbjA2aHlicmlkLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9mbGFuYWdhbjA2aHlicmlkLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1111037.1111059}}

@inproceedings{benton99interlang,
	Abstract = {A good foreign-language interface is crucial for the success of any modern programming language implementation. Although all serious compilers for functional languages have some facility for interlanguage working, these are often limited and awkward to use.This article describes the features for bidirectional interlanguage working with Java that are built into the latest version of the MLj compiler. Because the MLj foreign interface is to another high-level typed language which shares a garbage collector with compiled ML code, and because we are willing to extend the ML language, we are able to provide unusually powerful, safe and easy to use interlanguage working features. Indeed, rather then being a traditional foreign interface, our language extensions are more a partial integration of Java features into SML.We describe this integration of Standard ML and Java, first informally with example program fragments, and then formally in the notation used by The Definition of Standard ML.},
	Address = {New York, NY, USA},
	Author = {Nick Benton and Andrew Kennedy},
	Booktitle = {ICFP '99: Proceedings of the fourth ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2009-06-15 16:34:24 -0700},
	Date-Modified = {2009-06-15 16:35:05 -0700},
	Keywords = {types,ffi},
	Location = {Paris, France},
	Pages = {126--137},
	Publisher = {ACM},
	Title = {Interlanguage working without tears: blending SML with Java},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRViZW50b245OWludGVybGFuZy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eIx1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpiZW50b245OWludGVybGFuZy5wZGYADgAsABUAYgBlAG4AdABvAG4AOQA5AGkAbgB0AGUAcgBsAGEAbgBnAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2JlbnRvbjk5aW50ZXJsYW5nLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvYmVudG9uOTlpbnRlcmxhbmcucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/317636.317791}}

@article{matthews09semantics,
	Abstract = {Interoperability is big business, a fact to which .NET, the JVM, and COM can attest. Language designers are well aware of this, and they are designing programming languages that reflect it---for instance, SML.NET, F&num;, Mondrian, and Scala all treat interoperability as a central design feature. Still, current multi-language research tends not to focus on the semantics of these features, but only on how to implement them efficiently. In this article, we attempt to rectify that by giving a technique for specifying the operational semantics of a multi-language system as a composition of the models of its constituent languages. Our technique abstracts away the low-level details of interoperability like garbage collection and representation coherence, and lets us focus on semantic properties like type-safety, equivalence, and termination behavior. In doing so it allows us to adapt standard theoretical techniques such as subject-reduction, logical relations, and operational equivalence for use on multi-language systems. Generally speaking, our proofs of properties in a multi-language context are mutually referential versions of their single language counterparts.

We demonstrate our technique with a series of strategies for embedding a Scheme-like language into an ML-like language. We start by connecting very simple languages with a very simple strategy, and work our way up to languages that interact in sophisticated ways and have sophisticated features such as polymorphism and effects. Along the way, we prove relevant results such as type-soundness and termination for each system we present using adaptations of standard techniques.

Beyond giving simple expressive models, our studies have uncovered several interesting facts about interoperability. For example, higher-order function contracts naturally emerge as the glue to ensure that interoperating languages respect each other's type systems. Our models also predict that the embedding strategy where foreign values are opaque is as expressive as the embedding strategy where foreign values are translated to corresponding values in the other language, and we were able to experimentally verify this behavior using PLT Scheme's foreign function interface.},
	Address = {New York, NY, USA},
	Author = {Matthews, Jacob and Findler, Robert Bruce},
	Date-Added = {2009-06-15 16:32:24 -0700},
	Date-Modified = {2009-06-15 16:33:02 -0700},
	Journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	Keywords = {types,ffi},
	Number = {3},
	Pages = {1--44},
	Publisher = {ACM},
	Title = {Operational semantics for multi-language programs},
	Volume = {31},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdQAAAAAAdQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRdtYXR0aGV3czA5c2VtYW50aWNzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ftx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBSTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptYXR0aGV3czA5c2VtYW50aWNzLnBkZgAOADAAFwBtAGEAdAB0AGgAZQB3AHMAMAA5AHMAZQBtAGEAbgB0AGkAYwBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBFVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L21hdHRoZXdzMDlzZW1hbnRpY3MucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAfTGlicmFyeS9tYXR0aGV3czA5c2VtYW50aWNzLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJ4AnoCfwKIApMClwKlAqwCtQLXAtwC3wLsAvEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADAw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1498926.1498930}}

@article{trifonov99safe,
	Abstract = {Safety of interoperation of program fragments written in different safe languages may fail when the languages have different systems of computational effects: an exception raised by an ML function may have no valid semantic interpretation in the context of a Safe-C caller. Sandboxing costs performance and still may violate the semantics if effects are not taken into account.We show that effect annotations alone are insufficient to guarantee safety, and we present a type system with bounded effect polymorphism designed to verify the compatibility of abstract resources required by the computational models of the interoperating languages. The type system ensures single address space interoperability of statically typed languages with effect mechanisms built of modules for control and state. It is shown sound for safety with respect to the semantics of a language with constructs for selection, simulation, and blocking of resources, targeted as an intermediate language for optimization of resource handling. },
	Author = {Valery Trifonov and Zhong Shao},
	Date-Added = {2009-06-15 16:29:57 -0700},
	Date-Modified = {2009-06-15 16:30:23 -0700},
	Journal = {Programming Languages and Systems},
	Keywords = {ffi,types},
	Pages = {639--639},
	Title = {Safe and Principled Language Interoperation},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJ0cmlmb25vdjk5c2FmZS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gbx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp0cmlmb25vdjk5c2FmZS5wZGYAAA4AJgASAHQAcgBpAGYAbwBuAG8AdgA5ADkAcwBhAGYAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS90cmlmb25vdjk5c2FmZS5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvdHJpZm9ub3Y5OXNhZmUucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/3-540-49099-X_9}}

@inproceedings{necula02ccured,
	Abstract = {In this paper we propose a scheme that combines type inference and run-time checking to make existing C programs type safe. We describe the CCured type system, which extends that of C by separating pointer types according to their usage. This type system allows both pointers whose usage can be verified statically to be type safe, and pointers whose safety must be checked at run time. We prove a type soundness result and then we present a surprisingly simple type inference algorithm that is able to infer the appropriate pointer kinds for existing C programs.Our experience with the CCured system shows that the inference is very effective for many C programs, as it is able to infer that most or all of the pointers are statically verifiable to be type safe. The remaining pointers are instrumented with efficient run-time checks to ensure that they are used safely. The resulting performance loss due to run-time checks is 0-150%, which is several times better than comparable approaches that use only dynamic checking. Using CCured we have discovered programming bugs in established C programs such as several SPECINT95 benchmarks.},
	Address = {New York, NY, USA},
	Author = {George C. Necula and Scott McPeak and Westley Weimer},
	Booktitle = {POPL '02: Proceedings of the 29th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2009-06-15 16:26:21 -0700},
	Date-Modified = {2009-06-15 16:27:14 -0700},
	Keywords = {types},
	Location = {Portland, Oregon},
	Pages = {128--139},
	Publisher = {ACM},
	Title = {CCured: type-safe retrofitting of legacy code},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJuZWN1bGEwMmNjdXJlZC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f1x1O5IwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmjAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpuZWN1bGEwMmNjdXJlZC5wZGYAAA4AJgASAG4AZQBjAHUAbABhADAAMgBjAGMAdQByAGUAZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9uZWN1bGEwMmNjdXJlZC5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvbmVjdWxhMDJjY3VyZWQucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/503272.503286}}

@article{hamilton03clr,
	Abstract = {The Common Language Runtime (CLR) is language and platform-neutral, and provides the underlying infrastructure for the Microsoft .NET Framework. A key innovation in the CLR is its support for multiple programming languages, enabling programming language integration at the runtime level to a much greater degree than is currently possible.},
	Address = {New York, NY, USA},
	Author = {Jennifer Hamilton},
	Date-Added = {2009-06-15 16:20:52 -0700},
	Date-Modified = {2009-06-15 16:22:01 -0700},
	Journal = {ACM SIGPLAN Notices},
	Keywords = {types,dotnet,ffi},
	Number = {2},
	Pages = {19--28},
	Title = {Language integration in the common language runtime},
	Volume = {38},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFoYW1pbHRvbjAzY2xyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e/x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpoYW1pbHRvbjAzY2xyLnBkZgAOACQAEQBoAGEAbQBpAGwAdABvAG4AMAAzAGMAbAByAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2hhbWlsdG9uMDNjbHIucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9oYW1pbHRvbjAzY2xyLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/772970.772973}}

@inproceedings{grechanik04polylingual,
	Abstract = {Building systems from existing applications writtenin two or more languages is common practice. Such systems are polylingual. Polylingual systems are relatively easy to build when the number of APIs needed to achieve language interoperability is small. However, when the number of distinct APIs become large, maintaining and evolving polylingual systems becomes a notoriously difficult task. In this paper, we present a simple, practical, and effective way to develop, maintain, and evolve large-scale polylingual systems. Our approach relies on recursive type systems whose instances can be manipulated by reflection. Foreign objects (i.e. objects that are not defined in a host programming language) are abstracted as graphs and path expressions are used for accessing and manipulating data. Path expressions are implemented by type reification turning foreign type instances into first-class objects and enabling access to and manipulation of them in a host programming language. Doing this results in multiple benefits, including coding simplicity and uniformity that we demonstrate in a complex commercial project.},
	Address = {Washington, DC, USA},
	Author = {Grechanik, Mark and Batory, Don and Perry, Dewayne E.},
	Booktitle = {ICSE '04: Proceedings of the 26th International Conference on Software Engineering},
	Date-Added = {2009-06-15 16:15:54 -0700},
	Date-Modified = {2009-06-15 16:16:48 -0700},
	Keywords = {types,ffi},
	Pages = {357--366},
	Publisher = {IEEE Computer Society},
	Title = {Design of Large-Scale Polylingual Systems},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAeAAAAAAAeAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRpncmVjaGFuaWswNHBvbHlsaW5ndWFsLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e9x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBVTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpncmVjaGFuaWswNHBvbHlsaW5ndWFsLnBkZgAADgA2ABoAZwByAGUAYwBoAGEAbgBpAGsAMAA0AHAAbwBsAHkAbABpAG4AZwB1AGEAbAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIASFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9ncmVjaGFuaWswNHBvbHlsaW5ndWFsLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAiTGlicmFyeS9ncmVjaGFuaWswNHBvbHlsaW5ndWFsLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAKEAoYCiwKUAp8CowKxArgCwQLmAusC7gL7AwAAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADEg==},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?id=999440}}

@inproceedings{finne99hell,
	Abstract = {The increasing popularity of component-based programming tools offer a big opportunity to designers of advanced programming languages, such as Haskell. If we can package our programs as software components, then it is easy to integrate them into applications written in other languages.In earlier work we described a preliminary integration of Haskell with Microsoft's Component Object Model (COM), focusing on how Haskell can create and invoke COM objects. This paper develops that work, concentrating on the mechanisms that support externally-callable Haskell functions, and the encapsulation of Haskell programs as COM objects.},
	Address = {New York, NY, USA},
	Author = {Sigbjorn Finne and Daan Leijen and Erik Meijer and Simon Peyton Jones},
	Booktitle = {ICFP '99: Proceedings of the fourth ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2009-06-15 16:13:32 -0700},
	Date-Modified = {2009-06-15 16:14:44 -0700},
	Keywords = {ffi,component,types},
	Pages = {114--125},
	Publisher = {ACM},
	Title = {Calling hell from heaven and heaven from hell},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9maW5uZTk5aGVsbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1erx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmaW5uZTk5aGVsbC5wZGYADgAgAA8AZgBpAG4AbgBlADkAOQBoAGUAbABsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2Zpbm5lOTloZWxsLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvZmlubmU5OWhlbGwucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/317636.317790}}

@inproceedings{kaplan01exu,
	Abstract = { Exu is a new approach to automated support for safe, transparent and lightweight interoperability in multilanguage software systems. The approach is safe because it enforces appropriate type compatibility across language boundaries. It is transparent since it shields software developers from the details inherent in low-level language-based interoperability mechanisms. It is lightweight for developers because it eliminates tedious and error-prone coding (e.g., JNI) and lightweight at run-time since it does not unnecessarily incur the performance overhead of distributed, IDL-based approaches. The Exu approach exploits and extends the object-oriented concept of meta-object, encapsulating interoperability implementation in meta-classes so that developers can produce interoperating code by simply using meta-inheritance. In this paper, an example application of Exu to development of Java/C++ (i.e., multilanguage) programs illustrates the safety and transparency advantages of the approach. Comparing the performance of the Java/C++ programs produced by Exu to the same set of programs developed using IDL-based approaches provides preliminary evidence of the performance advantages of Exu.
},
	Address = {Washington, DC, USA},
	Author = {Alan Kaplan and John Bubba and Jack C. Wileden},
	Booktitle = {COMPSAC '01: Proceedings of the 25th International Computer Software and Applications Conference on Invigorating Software Development},
	Date-Added = {2009-06-15 16:09:58 -0700},
	Date-Modified = {2009-06-15 16:12:14 -0700},
	Keywords = {types,ffi},
	Pages = {393--394},
	Publisher = {IEEE Computer Society},
	Title = {The Exu Approach to Safe, Transparent and Lightweight Interoperability},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9rYXBsYW4wMWV4dS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fUx1O5HwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmfAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTprYXBsYW4wMWV4dS5wZGYADgAgAA8AawBhAHAAbABhAG4AMAAxAGUAeAB1AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2thcGxhbjAxZXh1LnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkva2FwbGFuMDFleHUucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/CMPSAC.2001.960644}}

@article{furr08check,
	Abstract = {Foreign function interfaces (FFIs) allow components in different languages to communicate directly with each other. While FFIs are useful, they often require writing tricky low-level code and include little or no static safety checking, thus providing a rich source of hard-to-find programming errors. In this article, we study the problem of enforcing type safety across the OCaml-to-C FFI and the Java Native Interface (JNI). We present O-Saffire and J-Saffire, a pair of multilingual type inference systems that ensure C code that uses these FFIs accesses high-level data safely. Our inference systems use representational types to model C's low-level view of OCaml and Java values, and singleton types to track integers, strings, memory offsets, and type tags through C. J-Saffire, our Java system, uses a polymorphic flow-insensitive, unification-based analysis. Polymorphism is important because it allows us to precisely model user-defined wrapper functions and the more than 200 JNI functions. O-Saffire, our OCaml system, uses a monomorphic flow-sensitive analysis because, while polymorphism is much less important for the OCaml FFI flow-sensitivity is critical to track conditional branches, which are used when pattern matching OCaml data in C. O-Saffire also tracks garbage collection information to ensure that local C pointers to the OCaml heap are registered properly, which is not necessary for the JNI. We have applied O-Saffire and J-Saffire to a set of benchmarks and found many bugs and questionable coding practices. These results suggest that static checking of FFIs can be a valuable tool in writing correct multilingual software.},
	Address = {New York, NY, USA},
	Author = {Michael Furr and Jeffrey S. Foster},
	Date-Added = {2009-06-15 16:01:53 -0700},
	Date-Modified = {2009-06-15 16:03:02 -0700},
	Journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	Keywords = {types,ffi},
	Month = {July},
	Number = {4},
	Pages = {1--63},
	Title = {Checking type safety of foreign function calls},
	Volume = {30},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9mdXJyMDhjaGVjay5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e0x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmdXJyMDhjaGVjay5wZGYADgAgAA8AZgB1AHIAcgAwADgAYwBoAGUAYwBrAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2Z1cnIwOGNoZWNrLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvZnVycjA4Y2hlY2sucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-File-2 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBmdXJyMDhjaGVjazAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASFKlx2kM1AAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHaX1UAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmdXJyMDhjaGVjazAucGRmAAAOACIAEABmAHUAcgByADAAOABjAGgAZQBjAGsAMAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9mdXJyMDhjaGVjazAucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2Z1cnIwOGNoZWNrMC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1377492.1377493}}

@inproceedings{runciman89poly,
	Address = {New York, NY, USA},
	Author = {Colin Runciman and Ian Toyn},
	Booktitle = {FPCA '89: Proceedings of the fourth international conference on Functional programming languages and computer architecture},
	Date-Added = {2009-06-15 15:13:01 -0700},
	Date-Modified = {2009-06-15 15:14:16 -0700},
	Keywords = {types,component},
	Pages = {166--173},
	Publisher = {ACM},
	Title = {Retrieving re-usable software components by polymorphic type},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJydW5jaW1hbjg5cG9seS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gMx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpydW5jaW1hbjg5cG9seS5wZGYAAA4AJgASAHIAdQBuAGMAaQBtAGEAbgA4ADkAcABvAGwAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9ydW5jaW1hbjg5cG9seS5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvcnVuY2ltYW44OXBvbHkucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/99370.99383}}

@article{nierstrasz95composition,
	Address = {New York, NY, USA},
	Author = {Oscar Nierstrasz and Theo Dirk Meijler},
	Date-Added = {2009-06-15 15:10:59 -0700},
	Date-Modified = {2009-06-15 15:45:58 -0700},
	Journal = {ACM Computing Surveys (CSUR)},
	Keywords = {component},
	Number = {2},
	Pages = {262--264},
	Title = {Research directions in software composition},
	Volume = {27},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAeQAAAAAAeQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRtuaWVyc3RyYXN6OTVjb21wb3NpdGlvbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f2x1O5IwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmjAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBWTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpuaWVyc3RyYXN6OTVjb21wb3NpdGlvbi5wZGYADgA4ABsAbgBpAGUAcgBzAHQAcgBhAHMAegA5ADUAYwBvAG0AcABvAHMAaQB0AGkAbwBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBJVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L25pZXJzdHJhc3o5NWNvbXBvc2l0aW9uLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QI0xpYnJhcnkvbmllcnN0cmFzejk1Y29tcG9zaXRpb24ucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAogCigKPApgCowKnArUCvALFAusC8ALzAwADBQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMX},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/210376.210389}}

@techreport{allen94formal,
	Abstract = {As software systems become more complex the overall system structure --- or software architecture --- becomes a central design problem. An important step towards an engineering discipline of software is a formal basis for describing and analyzing these designs. In this paper we present a theory for one aspect of architectural description: the interactions between components. The key idea is to define architectural connectors as explicit semantic entities. These are specified as a collection of protocols that characterize each of the participant roles in an interaction and how these roles interact. We illustrate how this scheme can be used to define a variety of common architectural connectors. We further provide a formal semantics and show how this leads to a system in which architectural compatibility can be checked in a way analogous to type checking in programming languages.},
	Address = {Pittsburgh, PA},
	Author = {Allen, R. and Garlan, D.},
	Date-Added = {2009-06-15 14:57:11 -0700},
	Date-Modified = {2009-06-15 14:59:48 -0700},
	Institution = {Carnegie Mellon University},
	Keywords = {component},
	Month = {March},
	Title = {Formal connectors (Technical Report: CS-94-115)},
	Year = {1994},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFhbGxlbjk0Zm9ybWFsLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d9x1O5FgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmWAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphbGxlbjk0Zm9ybWFsLnBkZgAOACQAEQBhAGwAbABlAG4AOQA0AGYAbwByAG0AYQBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2FsbGVuOTRmb3JtYWwucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9hbGxlbjk0Zm9ybWFsLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://acme.able.cs.cmu.edu/pubs/show.php?id=204}}

@article{hopkins00component,
	Author = {Jon Hopkins},
	Date-Added = {2009-06-15 14:50:22 -0700},
	Date-Modified = {2009-06-15 14:51:01 -0700},
	Journal = {Communications of the ACM},
	Keywords = {component},
	Month = {October},
	Number = {10},
	Pages = {27--30},
	Title = {Component primer},
	Volume = {43},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZob3BraW5zMDBjb21wb25lbnQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fFx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpob3BraW5zMDBjb21wb25lbnQucGRmAAAOAC4AFgBoAG8AcABrAGkAbgBzADAAMABjAG8AbQBwAG8AbgBlAG4AdAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9ob3BraW5zMDBjb21wb25lbnQucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L2hvcGtpbnMwMGNvbXBvbmVudC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?doid=352183.352198}}

@article{szyperski99component,
	Abstract = {This report summarizes the presentations, discussions, and thoughts expressed during the workshop sessions. Full proceedings are available as a technical report of the Department of Software Engineering and Computer Science at the University of Karlskrona Ronneby, Sweden. },
	Author = {Clemens Szyperski and Jan Bosch and Wolfgang Weck},
	Date-Added = {2009-06-15 14:42:01 -0700},
	Date-Modified = {2009-06-15 15:05:09 -0700},
	Journal = {Object-Oriented Technology ECOOP'99 Workshop Reader},
	Keywords = {component},
	Pages = {795--795},
	Title = {Component-Oriented Programming},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdgAAAAAAdgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRhzenlwZXJza2k5OWNvbXBvbmVudC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gZx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBTTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzenlwZXJza2k5OWNvbXBvbmVudC5wZGYAAA4AMgAYAHMAegB5AHAAZQByAHMAawBpADkAOQBjAG8AbQBwAG8AbgBlAG4AdAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9zenlwZXJza2k5OWNvbXBvbmVudC5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QIExpYnJhcnkvc3p5cGVyc2tpOTljb21wb25lbnQucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnwCfgKDAowClwKbAqkCsAK5AtwC4QLkAvEC9gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMI},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/3-540-46589-8_10}}

@article{vinoski97corba,
	Abstract = {Large computer networks such as corporate intranets and the Internet are inherently heterogeneous due to such factors as increasingly rapid technological change, engineering trade-offs, accumulation of legacy systems over time, and varying system costs. Unfortunately, such heterogeneity makes the development and maintenance of applications that make the best use of such networks difficult. The Common Object Request Broker Architecture specification created by the Object Management Group provides a stable model for distributed object-oriented systems that helps developers cope with heterogeneity and inevitable change. Applications written to the CORBA standard are abstracted away from underlying networking protocols and transports, instead relying on object request brokers to provide a fast and flexible communication and object activation substrated. The abstractions provided by CORBA ORBs are currently serving as the basis for applications in a wide variety of problem domains, including telecommunications, finance, medicine, and manufacturing, running on platforms ranging from mainframes down to test and measurement equipment. This article first provides an overview of the Object Management Architecture, then describes in detail the CORBA component of that architecture, and concludes with a description of the OMG organization along with some of its current and future work.},
	Author = {Steve Vinoski},
	Date-Added = {2009-06-15 14:29:58 -0700},
	Date-Modified = {2009-06-15 14:32:23 -0700},
	Journal = {IEEE Communications Magazine},
	Keywords = {component,corba},
	Month = {February},
	Number = {2},
	Pages = {46--55},
	Title = {CORBA: integrating diverse applications within distributed heterogeneous environments},
	Volume = {35},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJ2aW5vc2tpOTdjb3JiYS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gex1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp2aW5vc2tpOTdjb3JiYS5wZGYAAA4AJgASAHYAaQBuAG8AcwBrAGkAOQA3AGMAbwByAGIAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS92aW5vc2tpOTdjb3JiYS5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvdmlub3NraTk3Y29yYmEucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=565655}}

@inbook{goodale07expressing,
	Abstract = {The Cactus Framework is an open-source, modular, portable, programming environment for collaborative HPC computing. It was designed and written specifically to enable scientists and engineers to perform the large-scale simulations needed for their science. From the outset, Cactus has followed two fundamental tenets: respecting user needs and embracing new technologies. The framework and its associated components must be driven from the beginning by user requirements. This has been achieved by developing, supporting, and listening to a large user base. Among these needs are ease of use, portability, the ability to support large and geographically diverse collaborations and to handle enormous computing resources, visualization, file IO, and data management. It must also support the inclusion of legacy code, as well as a range of programming languages. It is essential that any living framework be able to incorporate new and developing cutting edge computation technologies and infrastructure, with minimal or no disruption to its user base. Cactus is now associated with many computational science research projects, particularly in visualization, data management, and Grid computing. },
	Author = {Tom Goodale},
	Chapter = {Expressing Workflow in the {Cactus} Framework},
	Date-Added = {2009-06-15 14:02:21 -0700},
	Date-Modified = {2009-06-15 14:04:45 -0700},
	Keywords = {component,cactus},
	Pages = {416--427},
	Publisher = {Springer London},
	Title = {Workflows for e-Science},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdQAAAAAAdQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRdnb29kYWxlMDdleHByZXNzaW5nLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e8x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBSTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpnb29kYWxlMDdleHByZXNzaW5nLnBkZgAOADAAFwBnAG8AbwBkAGEAbABlADAANwBlAHgAcAByAGUAcwBzAGkAbgBnAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBFVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2dvb2RhbGUwN2V4cHJlc3NpbmcucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAfTGlicmFyeS9nb29kYWxlMDdleHByZXNzaW5nLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJ4AnoCfwKIApMClwKlAqwCtQLXAtwC3wLsAvEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADAw==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-1-84628-757-2_25}}

@inproceedings{goodale03cactus,
	Abstract = {We describe Cactus, a framework for building a variety of computing applications in science and engineering, including astrophysics, relativity and chemical engineering. We first motivate by example the need for such frameworks to support multi-platform, high performance applications across diverse communities. We then describe the design of the latest release of Cactus (Version 4.0) a complete rewrite of earlier versions, which enables highly modular, multi-language, parallel applications to be developed by single researchers and large collaborations alike. Making extensive use of abstractions, we detail how we are able to provide the latest advances in computational science, such as interchangeable parallel data distribution and high performance IO layers, while hiding most details of the underlying computational libraries from the application developer. We survey how Cactus 4.0 is being used by various application communities, and describe how it will also enable these applications to run on the computational Grids of the near future.
},
	Author = {Tom Goodale and Gabrielle Allen and Gerd Lanfermann and Joan Masso and Edward Seidel and John Shalf},
	Booktitle = {Vector and Parallel Processing - VECPAR '2002, 5th International Conference},
	Date-Added = {2009-06-15 13:57:50 -0700},
	Date-Modified = {2009-06-15 14:05:07 -0700},
	Keywords = {component,cactus},
	Publisher = {Springer},
	Title = {The {Cactus} framework and toolkit: Design and applications},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNnb29kYWxlMDNjYWN0dXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e7x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpnb29kYWxlMDNjYWN0dXMucGRmAA4AKAATAGcAbwBvAGQAYQBsAGUAMAAzAGMAYQBjAHQAdQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2dvb2RhbGUwM2NhY3R1cy5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2dvb2RhbGUwM2NhY3R1cy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://www.cactuscode.org/Papers/cactuscode}}

@misc{demichiel06ejb,
	Author = {Linda DeMichiel and Michael Keith},
	Date-Added = {2009-06-15 12:27:27 -0700},
	Date-Modified = {2009-06-15 13:50:43 -0700},
	Howpublished = {http://java.sun.com/products/ejb/docs.html},
	Keywords = {java, component},
	Month = {May},
	Title = {{JSR-000220 Enterprise JavaBeans 3.0 Final Release Specification}},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJkZW1pY2hpZWwwNmVqYi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ehx1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpkZW1pY2hpZWwwNmVqYi5wZGYAAA4AJgASAGQAZQBtAGkAYwBoAGkAZQBsADAANgBlAGoAYgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9kZW1pY2hpZWwwNmVqYi5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvZGVtaWNoaWVsMDZlamIucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://java.sun.com/products/ejb/docs.html}}

@article{sousa99formal,
	Abstract = {An emerging trend in the engineering of complex systems is the use of component integration frameworks. Such a framework prescribes an architectural design that permits flexible composition of thirdparty components into applications. A good example is Sun Microsystems' Enterprise JavaBeans{\texttrademark} (EJB) framework, which supports object- oriented, distributed, enterprise-level applications, such as account management systems. One problem with frameworks like EJB is that they are documented informally, making it difficult to understand precisely what is provided by the framework, and what is required to use it. We believe formal specification can help, and in this paper show how a formal architectural description language can be used to describe and provide insight into such frameworks. },
	Author = {Sousa, Joao and Garlan, David},
	Date-Added = {2009-06-15 12:23:11 -0700},
	Date-Modified = {2009-06-15 12:24:03 -0700},
	Journal = {FM'99 -- Formal Methods},
	Keywords = {component},
	Pages = {714--714},
	Title = {Formal modeling of the enterprise {JavaBeans (TM)} component integration framework},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFzb3VzYTk5Zm9ybWFsLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gVx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzb3VzYTk5Zm9ybWFsLnBkZgAOACQAEQBzAG8AdQBzAGEAOQA5AGYAbwByAG0AYQBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3NvdXNhOTlmb3JtYWwucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9zb3VzYTk5Zm9ybWFsLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/3-540-48118-4_18}}

@article{rossberg06dynamic,
	Abstract = {Despite its powerful module system, ML has not yet evolved for the modern world of dynamic and open modular programming, to which more primitive languages have adapted better so far. We present the design and semantics of a simple yet expressive firstclass component system for ML. It provides dynamic linking in a type-safe and type-flexible manner, and allows selective execution in sandboxes. The system is defined solely by reduction to higherorder modules plus an extension with simple module-level dynamics, which we call packages. To represent components outside processes we employ generic pickling. We give a module calculus formalising the semantics of packages and pickling. },
	Address = {New York, NY, USA},
	Author = {Andreas Rossberg},
	Date-Added = {2009-06-15 11:37:21 -0700},
	Date-Modified = {2009-06-15 15:03:18 -0700},
	Journal = {ACM SIGPLAN Notices},
	Keywords = {component,ml,pl},
	Number = {9},
	Pages = {99--110},
	Title = {The missing link: dynamic components for {ML}},
	Volume = {41},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVyb3NzYmVyZzA2ZHluYW1pYy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gKx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyb3NzYmVyZzA2ZHluYW1pYy5wZGYADgAsABUAcgBvAHMAcwBiAGUAcgBnADAANgBkAHkAbgBhAG0AaQBjAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3Jvc3NiZXJnMDZkeW5hbWljLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvcm9zc2JlcmcwNmR5bmFtaWMucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1160074.1159816}}

@inproceedings{macqueen84modules,
	Abstract = {The functional programming language ML has been undergoing a thorough redesign during the past year, and the module facility described here has been proposed as part of the revised language, now called Standard ML. The design has three main goals: (1) to facilitate the structuring of large ML programs; (2) to support separate compilation and generic library units; and (3) to employ new ideas in the semantics of data types to extend the power of ML's polymorphic type system. It is based on concepts inherent in the structure of ML, primarily the notions of a declaration, its type signature, and the environment that it denotes.},
	Address = {New York, NY, USA},
	Author = {David MacQueen},
	Booktitle = {LFP '84: Proceedings of the 1984 ACM Symposium on LISP and functional programming},
	Date-Added = {2009-06-15 11:24:20 -0700},
	Date-Modified = {2009-06-15 11:25:48 -0700},
	Doi = {10.1145/800055.802036},
	Isbn = {0-89791-142-3},
	Keywords = {ml,module,component,pl},
	Location = {Austin, Texas, United States},
	Pages = {198--207},
	Publisher = {ACM},
	Title = {Modules for standard ML},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVtYWNxdWVlbjg0bW9kdWxlcy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fqx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptYWNxdWVlbjg0bW9kdWxlcy5wZGYADgAsABUAbQBhAGMAcQB1AGUAZQBuADgANABtAG8AZAB1AGwAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L21hY3F1ZWVuODRtb2R1bGVzLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvbWFjcXVlZW44NG1vZHVsZXMucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800055.802036}}

@inproceedings{furr06jni,
	Abstract = {We present a multi-lingual type inference system for checking type safety of programs that use the Java Native Interface (JNI). The JNI uses specially-formatted strings to represent class and field names as well as method signatures, and so our type system tracks the flow of string constants through the program. Our system embeds string variables in types, and as those variables are resolved to string constants during inference they are replaced with the structured types the constants represent. This restricted form of dependent types allows us to directly assign type signatures to each of the more than 200 functions in the JNI. Moreover, it allows us to infer types for user-defined functions that are parameterized by Java type strings, which we have found to be common practice. Our inference system allows such functions to be treated polymorphically by using instantiation constraints, solved with semi-unification, at function calls. Finally, we have implemented our system and applied it to a small set of benchmarks. Although semi-unification is undecidable, we found our system to be scalable and effective in practice. We discovered 155 errors and 36 cases of suspicious programming practices in our benchmarks. },
	Address = {Vienna, Austria},
	Author = {Michael Furr and Jeffrey S. Foster},
	Booktitle = {Proceedings of the 15th European Symposium on Programming (ESOP)},
	Date-Added = {2009-06-12 17:00:30 -0700},
	Date-Modified = {2009-06-12 17:04:29 -0700},
	Keywords = {pl,java,types},
	Month = {March},
	Pages = {309--324},
	Title = {Polymorphic Type Inference for the {JNI}},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAawAAAAAAawAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ1mdXJyMDZqbmkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eyx1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBITWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmdXJyMDZqbmkucGRmAA4AHAANAGYAdQByAHIAMAA2AGoAbgBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA7VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2Z1cnIwNmpuaS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBVMaWJyYXJ5L2Z1cnIwNmpuaS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACUAJSAlcCYAJrAm8CfQKEAo0CpQKqAq0CugK/AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtE=},
	Bdsk-Url-1 = {http://www.cs.umd.edu/~jfoster/papers/esop06.html}}

@inproceedings{gokhale98corba,
	Abstract = {The Internet Inter-ORB Protocol (IIOP) enables heterogeneous CORBA-compliant object request brokers (ORBs) to interoperate over TCP/IP networks. The IIOP uses the Common Data Representation (CDR) transfer syntax to map OMG Interface Definition Language (IDL) data types into a portable network format. Due to the excessive marshaling/demarshaling overhead, data copying and high-levels of function call overhead, some implementations of IIOP protocols have yielded relatively poor performance over high-speed networks. To meet the demands of emerging distributed multimedia applications, however, CORBA-compliant ORBs must support interoperable and highly efficient IIOP implementations. This paper provides contributions to the study and design of efficient CORBA IIOP implementations. We outline the software architecture of the SunSoft's public domain implementation of IIOP version 1.0. We pin-point the key sources of overhead in the SunSoft IIOP implementation by measuring its performance for transferring richly-typed data over a high-speed ATM network. We empirically demonstrate the benefits of systematically applying protocol optimizations to SunSoft IIOP. The results of applying these optimizations to SunSoft IIOP improved its performance substantially for all data types. The resulting optimized IIOP implementation is competitive with existing commercial ORBs using CORBA's static invocation interface and 2 to 4.5 times faster than commercial ORBs using the dynamic skeleton interface. We have integrated the optimized IIOP implementation into TAO, which is a CORBA ORB targeted for real-time systems.},
	Address = {Washington, DC, USA},
	Author = {Aniruddha S. Gokhale and Douglas C. Schmidt},
	Booktitle = {HICSS '98: Proceedings of the Thirty-First Annual Hawaii International Conference on System Sciences},
	Date-Added = {2009-06-12 16:40:13 -0700},
	Date-Modified = {2009-06-12 16:52:52 -0700},
	Doi = {10.1109/HICSS.1998.649232},
	Keywords = {ffi,component},
	Pages = {376},
	Publisher = {IEEE Computer Society},
	Title = {Principles for Optimizing CORBA Internet Inter-ORB Protocol Performance},
	Volume = {7},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJnb2toYWxlOThjb3JiYS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e6x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpnb2toYWxlOThjb3JiYS5wZGYAAA4AJgASAGcAbwBrAGgAYQBsAGUAOQA4AGMAbwByAGIAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9nb2toYWxlOThjb3JiYS5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvZ29raGFsZTk4Y29yYmEucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/HICSS.1998.649232}}

@misc{ms06cli,
	Abstract = {This International Standard defines the Common Language Infrastructure (CLI) in which applications written in multiple high-level languages can be executed in different system environments without the need to rewrite those applications to take into consideration the unique characteristics of those environments. This International Standard consists of the following parts:

Partition I: Concepts and Architecture -- Describes the overall architecture of the CLI, and provides the normative description of the Common Type System (CTS), the Virtual Execution System (VES), and the Common Language Specification (CLS). It also provides an informative description of the metadata.

Partition II: Metadata Definition and Semantics -- Provides the normative description of the metadata: its physical layout (as a file format), its logical contents (as a set of tables and their relationships), and its semantics (as seen from a hypothetical assembler, ilasm).

Partition III: CIL Instruction Set -- Describes the Common Intermediate Language (CIL) instruction set.

Partition IV: Profiles and Libraries -- Provides an overview of the CLI Libraries, and a specification of their factoring into Profiles and Libraries. A companion file, CLILibrary.xml, considered to be part of this Partition, but distributed in XML format, provides details of each class, value type, and interface in the CLI Libraries.

Partition V: Debug Interchange Format.

Partition VI: Annexes -- Contains some sample programs written in CIL Assembly Language (ILAsm), information about a particular implementation of an assembler, a machine-readable description of the CIL instruction set which can be used to derive parts of the grammar used by this assembler as well as other tools that manipulate CIL, a set of guidelines used in the design of the libraries of Partition IV , and portability considerations.
},
	Date-Added = {2009-06-12 16:19:07 -0700},
	Date-Modified = {2009-06-12 16:23:08 -0700},
	Howpublished = {http://www.ecma-international.org/publications/standards/Ecma-335.htm},
	Keywords = {pl,ffi},
	Month = {June},
	Title = {Standard {ECMA}-335: {Common Language Infrastructure (CLI)}},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAaQAAAAAAaQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQttczA2Y2xpLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fyx1O5IwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmjAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBGTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptczA2Y2xpLnBkZgAOABgACwBtAHMAMAA2AGMAbABpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA5VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L21zMDZjbGkucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxATTGlicmFyeS9tczA2Y2xpLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJIAkoCTwJYAmMCZwJ1AnwChQKbAqACowKwArUAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAACxw==},
	Bdsk-Url-1 = {http://www.ecma-international.org/publications/standards/Ecma-335.htm}}

@techreport{huelsbergen96mlffi,
	Abstract = {This paper describes the design and implementation of an interface to C for the SML/NJ ML compiler. The interface supplies ML datatypes with which programmers specify C types and C data. An ML program uses these datatypes to register a foreign C function with the interface and to build specifications of structured C data. The interface automatically instantiates C function arguments from C data specifications upon foreign function application. Most C types, including aggregate and function-pointer types, are supported. A runtime code generation technique converts ML closures to C-callable function pointers. Function pointers allow C programs to call ML programs. We solve the problems due to differences in data representation, function calling conventions, and storage management by copying data between the ML and C heaps, converting representations and changing calling conventions in the process. We find that this copying strategy provides adequate performance in practice. The interface is portable in the sense that its implementation does not require changes to the SML/NJ compiler proper; it is isolated in a pair of libraries (ML and C). The interface has already found use in several non-trivial applications. },
	Author = {Lorenz Huelsbergen},
	Date-Added = {2009-06-12 15:52:43 -0700},
	Date-Modified = {2009-06-12 15:55:37 -0700},
	Institution = {AT\&T Bell Laboratories},
	Keywords = {pl,ml,ffi},
	Month = {January},
	Title = {A Portable {C} Interface for {Standard ML} of {New Jersey}},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZodWVsc2Jlcmdlbjk2bWxmZmkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fJx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpodWVsc2Jlcmdlbjk2bWxmZmkucGRmAAAOAC4AFgBoAHUAZQBsAHMAYgBlAHIAZwBlAG4AOQA2AG0AbABmAGYAaQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9odWVsc2Jlcmdlbjk2bWxmZmkucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L2h1ZWxzYmVyZ2VuOTZtbGZmaS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://www.smlnj.org/doc/SMLNJ-C/}}

@book{liang99jni,
	Abstract = {The Java Native Interface (JNI) is a powerful feature of the Java platform. Applications that use the JNI can incorporate native code written in programming languages such as C and C++, as well as code written in the Java programming language. The JNI allows programmers to take advantage of the power of the Java platform, without having to abandon their investments in legacy code. Because the JNI is a part of the Java platform, programmers can address interoperability issues once, and expect their solution to work with all implementations of the Java platform. },
	Author = {Sheng Liang},
	Date-Added = {2009-06-12 15:29:30 -0700},
	Date-Modified = {2009-06-12 15:32:59 -0700},
	Keywords = {ffi,java},
	Month = {June},
	Publisher = {Addison-Wesley},
	Title = {Java Native Interface: Programmer's Guide and Specification},
	Year = {2002},
	Bdsk-Url-1 = {http://java.sun.com/docs/books/jni/html/titlepage.html}}

@book{gosling00java,
	Abstract = {The Java programming language is a general-purpose, concurrent, class-based, object-oriented language. It is designed to be simple enough that many programmers can achieve fluency in the language. The Java programming language is related to C and C++ but is organized rather differently, with a number of aspects of C and C++ omitted and a few ideas from other languages included. It is intended to be a production language, not a research language, and so, as C. A. R. Hoare suggested in his classic paper on language design, the design has avoided including new and untested features.},
	Author = {James Gosling and Bill Joy and Guy Steele and Gilad Bracha},
	Date-Added = {2009-06-12 15:23:18 -0700},
	Date-Modified = {2009-06-12 15:26:46 -0700},
	Edition = {Second Edition},
	Keywords = {pl,java},
	Month = {June},
	Publisher = {Prentice Hall PTR},
	Title = {The Java Language Specification},
	Year = {2000},
	Bdsk-Url-1 = {http://java.sun.com/docs/books/jls/second_edition/html/j.title.doc.html}}

@misc{chakravarty03haskellffi,
	Author = {Manuel Chakravarty and Sigbjorn Finne and Fergus Henderson and Marcin Kowalczyk and Daan Leijen and Simon Marlow and Erik Meijer and Sven Panne and Simon Peyton Jones and Alastair Reid and Malcolm Wallace and Michael Weber},
	Date-Added = {2009-06-12 15:17:07 -0700},
	Date-Modified = {2009-06-12 15:21:08 -0700},
	Howpublished = {http://www.cse.unsw.edu.au/~chak/haskell/ffi/},
	Keywords = {pl,haskell,ffi},
	Title = {The Haskell 98 Foreign Function Interface 1.0: An Addendum to the Haskell 98 Report},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAeQAAAAAAeQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRtjaGFrcmF2YXJ0eTAzaGFza2VsbGZmaS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eTx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBWTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjaGFrcmF2YXJ0eTAzaGFza2VsbGZmaS5wZGYADgA4ABsAYwBoAGEAawByAGEAdgBhAHIAdAB5ADAAMwBoAGEAcwBrAGUAbABsAGYAZgBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBJVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2NoYWtyYXZhcnR5MDNoYXNrZWxsZmZpLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QI0xpYnJhcnkvY2hha3JhdmFydHkwM2hhc2tlbGxmZmkucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAogCigKPApgCowKnArUCvALFAusC8ALzAwADBQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMX},
	Bdsk-Url-1 = {http://www.cse.unsw.edu.au/~chak/haskell/ffi/}}

@inproceedings{hirzel07jeannie,
	Abstract = {Higher-level languages interface with lower-level languages such as C to access platform functionality, reuse legacy libraries, or improve performance. This raises the issue of how to best integrate different languages while also reconciling productivity, safety, portability, and efficiency. This paper presents Jeannie, a new language design for integrating Java with C. In Jeannie, both Java and C code are nested within each other in the same file and compile down to JNI, the Java platform's standard foreign function interface. By combining the two languages' syntax and semantics, Jeannie eliminates verbose boiler-plate code, enables static error detection across the language boundary, and simplifies dynamic resource management. We describe the Jeannie language and its compiler, while also highlighting lessons from composing two mature programming languages.},
	Address = {New York, NY, USA},
	Author = {Martin Hirzel and Robert Grimm},
	Booktitle = {Proceedings of the 2007 OOPSLA conference},
	Date-Added = {2009-06-12 15:13:01 -0700},
	Date-Modified = {2009-06-12 16:33:48 -0700},
	Doi = {10.1145/1297105.1297030},
	Keywords = {pl,ffi,java},
	Number = {10},
	Pages = {19--38},
	Publisher = {ACM},
	Title = {Jeannie: granting {J}ava native interface developers their wishes},
	Volume = {42},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNoaXJ6ZWwwN2plYW5uaWUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fDx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpoaXJ6ZWwwN2plYW5uaWUucGRmAA4AKAATAGgAaQByAHoAZQBsADAANwBqAGUAYQBuAG4AaQBlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2hpcnplbDA3amVhbm5pZS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2hpcnplbDA3amVhbm5pZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1297105.1297030}}

@article{fisher01interop,
	Abstract = {Practical implementations of high-level languages must provide access to libraries and system services that have APIs specified in a low-level language (usually C). An important characteristic of such mechanisms is the foreign-interface policy that defines how to bridge the semantic gap between the high-level language and C. For example, IDL-based tools generate code to marshal data into and out of the high-level representation according to user annotations. The design space of foreign-interface policies is large and there are pros and cons to each approach. Rather than commit to a particular policy, we choose to focus on the problem of supporting a gamut of interoperability policies. In this paper, we describe a framework for language interoperability that is expressive enough to support very efficient implementations of a wide range of different foreign-interface policies. We describe two tools that implement substantially different policies on top of our framework and present benchmarks that demonstrate their efficiency.
},
	Author = {Kathleen Fisher and Riccardo Pucella and John Reppy},
	Date-Added = {2009-06-12 15:02:43 -0700},
	Date-Modified = {2009-06-12 15:05:28 -0700},
	Journal = {Electronic Notes in Theoretical Computer Science},
	Keywords = {ffi},
	Month = {September},
	Number = {1},
	Pages = {3--19},
	Title = {A Framework for Interoperability},
	Volume = {59},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNmaXNoZXIwMWludGVyb3AucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1esx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmaXNoZXIwMWludGVyb3AucGRmAA4AKAATAGYAaQBzAGgAZQByADAAMQBpAG4AdABlAHIAbwBwAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2Zpc2hlcjAxaW50ZXJvcC5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2Zpc2hlcjAxaW50ZXJvcC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=}}

@inproceedings{kohn01babel,
	Address = {Portsmouth, VA},
	Author = {Scott Kohn and Gary Kumfert and Jeff Painter and Cal Ribbens},
	Booktitle = {Proceedings of the 10th SIAM Conference on Parallel Processes},
	Date-Added = {2009-06-12 14:48:28 -0700},
	Date-Modified = {2009-06-12 14:51:19 -0700},
	Keywords = {component,ffi},
	Month = {March},
	Title = {Divorcing Langauge Dependencies from a Scientific Software Library},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9rb2huMDFiYWJlbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fax1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTprb2huMDFiYWJlbC5wZGYADgAgAA8AawBvAGgAbgAwADEAYgBhAGIAZQBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2tvaG4wMWJhYmVsLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkva29objAxYmFiZWwucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://eprints.cca-forum.org/84/}}

@article{reid08fortran,
	Abstract = {The aim of this paper is to summarize the new features of the draft Fortran 2008 standard (ISO/IEC 2008). We take as our starting point Fortran 2003 (ISO/IEC 2008). An official extension for enhanced module facilities (ISO/IEC 2005) that has been published as a Type 2 Technical Report (TR), and WG5 is committed to include this in Fortran 2008. For an informal description of Fortran 2003 and Enhanced Module Facilities see Metcalf, Reid, and Cohen (2004). The major proposed extension consists of coarrays for parallel computing. Since the author has already summarised coarrays in another WG5 paper (Reid 2008), we refer the reader to this for further details.},
	Address = {New York, NY, USA},
	Author = {John Reid},
	Date-Added = {2009-06-12 14:46:21 -0700},
	Date-Modified = {2009-06-12 14:51:55 -0700},
	Doi = {10.1145/1408643.1408645},
	Journal = {SIGPLAN Fortran Forum},
	Keywords = {pl,fortran,ffi},
	Number = {2},
	Pages = {8--21},
	Publisher = {ACM},
	Title = {The new features of Fortran 2008},
	Volume = {27},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFyZWlkMDhmb3J0cmFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gHx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyZWlkMDhmb3J0cmFuLnBkZgAOACQAEQByAGUAaQBkADAAOABmAG8AcgB0AHIAYQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3JlaWQwOGZvcnRyYW4ucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9yZWlkMDhmb3J0cmFuLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1408643.1408645}}

@article{reid07fortran,
	Abstract = {The aim of this paper is to summarize the new features of the Fortran 2003 standard (WG5 2004). We take as our starting point Fortran 95 plus the two official extensions (Cohen 2001, Reid 2001) that have been published as Type 2 Technical Reports (TRs). These provide features for Allocatable dummy arguments and type components, and Support for the five exceptions of the IEEE Floating Point Standard (IEEE 1989) and for other features of this Standard.},
	Address = {New York, NY, USA},
	Author = {John Reid},
	Date-Added = {2009-06-12 14:44:38 -0700},
	Date-Modified = {2009-06-12 14:51:55 -0700},
	Doi = {10.1145/1243413.1243415},
	Journal = {SIGPLAN Fortran Forum},
	Keywords = {pl,fortran,ffi},
	Number = {1},
	Pages = {10--33},
	Publisher = {ACM},
	Title = {The new features of Fortran 2003},
	Volume = {26},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFyZWlkMDdmb3J0cmFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gGx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyZWlkMDdmb3J0cmFuLnBkZgAOACQAEQByAGUAaQBkADAANwBmAG8AcgB0AHIAYQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3JlaWQwN2ZvcnRyYW4ucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9yZWlkMDdmb3J0cmFuLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1243413.1243415}}

@article{reid00fortran,
	Abstract = {The aim of this paper is to summarize the new features in the draft Fortran 2000 standard (J3 2002). We take as our starting point Fortran 95 plus the two official extensions (Cohen 2001, Reid 2001) that have been published as Type 2 Technical Reports. These provide features for1. Allocatable dummy arguments and type components, and2. Support for the five exceptions of the IEEE Floating Point Standard (IEEE 1989) and for other features of this Standard.There is a firm commitment to include the features of these TRs in Fortran 2000, apart from changes that follow from errors and omissions found during implementation. Therefore, these features are not open to comment and are not described here. For an informal description, see chapters 12 and 13 of Metcalf and Reid (1999).Fortran 2000 is a major extension of Fortran 95. This contrasts with Fortran 95, which was a minor extension of Fortran 90. The major changes concei'n the two TR items, object orientation, and interfacing with C. Allocatable arrays are very important for optimization - after all, good execution speed is Fortran's forte. Exception handling is needed to write robust code. Object orientation provides an effective way to separate programming into independent tasks and to build upon existing codes; we describe these features in Section 1. Interfacing with C is needed for access to the all the hardware features and to allow C programmers to call efficient Fortran codes; we describe these features in Section 4. There are also many less major enhancements, described in Sections 2 and 3.},
	Address = {New York, NY, USA},
	Author = {John Reid},
	Date-Added = {2009-06-12 14:42:37 -0700},
	Date-Modified = {2009-06-12 14:51:32 -0700},
	Doi = {10.1145/1216213.1216214},
	Journal = {SIGPLAN Fortran Forum},
	Keywords = {pl,fortran,ffi},
	Number = {2},
	Pages = {1--31},
	Publisher = {ACM},
	Title = {The new features of Fortran 2000},
	Volume = {21},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFyZWlkMDBmb3J0cmFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gFx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyZWlkMDBmb3J0cmFuLnBkZgAOACQAEQByAGUAaQBkADAAMABmAG8AcgB0AHIAYQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3JlaWQwMGZvcnRyYW4ucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9yZWlkMDBmb3J0cmFuLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1216213.1216214}}

@article{waldo98jrmi,
	Abstract = {Remote procedure call systems have been around since around 1984 when they were first proposed (A.D. Birrell and B.J. Nelson, 1984). During the intervening 15 years, numerous evolutionary improvements have occurred in the basic RPC system, leading to improved systems-such as NCS (T.H. Dineen et al., 1987)-that offer programmers more functionality or greater simplicity. The Common Object Request Broker Architecture from the Object Management Group and Microsoft's Distributed Common Object Model are this evolutionary process's latest outgrowths. With the introduction of Java Developer's Kit release 1.1, a third alternative for creating distributed applications has emerged. The Java Remote Method Invocation system has many of the same features of other RPC systems, letting an object running in one Java virtual machine make a method call on an object running in another, perhaps on a different physical machine. On the surface, the RMI system is just another RPC mechanism, much like Corba and DCOM. But on closer inspection, RMI represents a very different evolutionary progression, one that results in a system that differs not just in detail but in the very set of assumptions made about the distributed systems in which it operates. These differences lead to differences in the programming model, capabilities, and the way the mechanisms interact with the code that implements and built the distributed systems.},
	Author = {J. Waldo},
	Date-Added = {2009-06-11 22:52:56 -0700},
	Date-Modified = {2009-06-11 22:54:25 -0700},
	Doi = {10.1109/4434.708248},
	Journal = {Concurrency, IEEE},
	Keywords = {rmi,java},
	Month = {Jul-Sep},
	Number = {3},
	Pages = {5--7},
	Title = {Remote procedure calls and {J}ava Remote Method Invocation},
	Volume = {6},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ93YWxkbzk4anJtaS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gix1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp3YWxkbzk4anJtaS5wZGYADgAgAA8AdwBhAGwAZABvADkAOABqAHIAbQBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3dhbGRvOThqcm1pLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvd2FsZG85OGpybWkucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/4434.708248}}

@article{curbera02soap,
	Abstract = {This tutorial explores the most salient and stable specifications in each of the three major areas of the emerging Web services framework. They are the simple object access protocol, the Web Services Description Language and the Universal Description, Discovery, and Integration directory, which is a registry of Web services descriptions },
	Author = {F. Curbera and M. Duftler and R. Khalaf and W. Nagy and N. Mukhi and S. Weerawarana},
	Date-Added = {2009-06-11 22:46:03 -0700},
	Date-Modified = {2009-06-12 16:25:06 -0700},
	Doi = {10.1109/4236.991449},
	Journal = {Internet Computing, IEEE},
	Keywords = {soap,webservices},
	Month = {March/April},
	Number = {2},
	Pages = {86--93},
	Title = {Unraveling the Web services web: an introduction to {SOAP}, {WSDL}, and {UDDI}},
	Volume = {6},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFjdXJiZXJhMDJzb2FwLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1edx1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjdXJiZXJhMDJzb2FwLnBkZgAOACQAEQBjAHUAcgBiAGUAcgBhADAAMgBzAG8AYQBwAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2N1cmJlcmEwMnNvYXAucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9jdXJiZXJhMDJzb2FwLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/4236.991449}}

@inproceedings{kitchin09orc,
	Abstract = {Orc was originally presented as a process calculus. It has now evolved into a full programming language, which we describe in this paper. The language has the structure and feel of a functional programming language, yet it handles many non-functional aspects effectively, including spawning of concurrent threads, time-outs and mutable state. We first describe the original concurrency combinators of the process calculus. Next we describe a small functional programming language that forms the core language. Then we show how the concurrency combinators of the process calculus and the functional core language are integrated seamlessly. The resulting language and its supporting libraries have proven very effective in describing typical concurrent computations; we demonstrate how several practical concurrent programming problems are easily solved in Orc.
},
	Author = {David Kitchin and Adrian Quark and William Cook and Jayadev Misra},
	Booktitle = {Proceedings of FMOODS/FORTE},
	Date-Added = {2009-06-11 22:29:18 -0700},
	Date-Modified = {2009-06-11 22:31:46 -0700},
	Keywords = {orc},
	Title = {The {O}rc Programming Language},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBraXRjaGluMDlvcmMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fYx1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpraXRjaGluMDlvcmMucGRmAAAOACIAEABrAGkAdABjAGgAaQBuADAAOQBvAHIAYwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9raXRjaGluMDlvcmMucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2tpdGNoaW4wOW9yYy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://orc.csres.utexas.edu/research.shtml}}

@inproceedings{cook06orc,
	Abstract = {Van der Aalst recently proposed a set of workflow patterns to characterize the kinds of control flow that appear frequently in workflow processes. These patterns are useful for evaluating the capabilities of workflow systems and models. In this paper we provide implementations of the workflow patterns in Orc, a new process calculus for orchestrating wide-area computations. A key feature of the Orc implementations is that they are expressed as definitions that can be reused as needed.},
	Author = {William Cook and Sourabh Patwardhan and Jayadev Misra},
	Booktitle = {Proceedings of the International Conference on Coordination Models and Languages (COORDINATION)},
	Date-Added = {2009-06-11 22:22:11 -0700},
	Date-Modified = {2009-06-11 22:24:50 -0700},
	Keywords = {workflow},
	Pages = {82--96},
	Title = {Workflow Patterns in Orc},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAawAAAAAAawAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ1jb29rMDZvcmMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eax1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBITWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjb29rMDZvcmMucGRmAA4AHAANAGMAbwBvAGsAMAA2AG8AcgBjAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA7VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2Nvb2swNm9yYy5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBVMaWJyYXJ5L2Nvb2swNm9yYy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACUAJSAlcCYAJrAm8CfQKEAo0CpQKqAq0CugK/AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtE=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/11767954%5C_6}}

@article{ashcroft77lucid,
	Abstract = {Lucid is a formal system in which programs can be written and proofs of programs carried out. The proofs are particularly easy to follow and straightforward to produce because the statements in a Lucid program are simply axioms from which the proof proceeds by (almost) conventional logical reasoning, with the help of a few axioms and rules of inference for the special Lucid functions. As a programming language, Lucid is unconventional because, among other things, the order of statements is irrelevant and assignment statements are equations. Nevertheless, Lucid programs need not look much different than iterative programs in a conventional structured programming language using assignment and conditional statements and loops.},
	Address = {New York, NY, USA},
	Author = {E. A. Ashcroft and W. W. Wadge},
	Date-Added = {2009-06-11 17:35:46 -0700},
	Date-Modified = {2009-06-12 14:52:09 -0700},
	Doi = {10.1145/359636.359715},
	Journal = {Communications of the ACM},
	Keywords = {pl,streams},
	Number = {7},
	Pages = {519--526},
	Publisher = {ACM},
	Title = {Lucid, a nonprocedural language with iteration},
	Volume = {20},
	Year = {1977},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNhc2hjcm9mdDc3bHVjaWQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eEx1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphc2hjcm9mdDc3bHVjaWQucGRmAA4AKAATAGEAcwBoAGMAcgBvAGYAdAA3ADcAbAB1AGMAaQBkAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2FzaGNyb2Z0NzdsdWNpZC5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2FzaGNyb2Z0NzdsdWNpZC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/359636.359715}}

@techreport{dijkstra65coop,
	Abstract = {These lectures are intended for all those that expect that in their future activities they will become seriously involved in the problems that arise in either the design or the more advanced applications of digital information processing equipment; they are further intended for all those that are just interested.},
	Address = {Eindhoven, The Netherlands},
	Author = {E. W. Dijkstra},
	Date-Added = {2009-06-11 17:19:14 -0700},
	Date-Modified = {2009-06-11 17:23:46 -0700},
	Institution = {Math Dept. Technological University},
	Keywords = {classic},
	Title = {Cooperating sequential processes},
	Year = {1965},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJkaWprc3RyYTY1Y29vcC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ekx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpkaWprc3RyYTY1Y29vcC5wZGYAAA4AJgASAGQAaQBqAGsAcwB0AHIAYQA2ADUAYwBvAG8AcAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9kaWprc3RyYTY1Y29vcC5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvZGlqa3N0cmE2NWNvb3AucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD123.html}}

@article{hoare78csp,
	Abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of a familiar programming exercises.},
	Address = {New York, NY, USA},
	Author = {C. A. R. Hoare},
	Date-Added = {2009-06-11 17:08:45 -0700},
	Date-Modified = {2009-06-12 14:52:30 -0700},
	Doi = {10.1145/359576.359585},
	Journal = {Communications of the ACM},
	Keywords = {pl,concurrent},
	Number = {8},
	Pages = {666--677},
	Publisher = {ACM},
	Title = {Communicating sequential processes},
	Volume = {21},
	Year = {1978},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ5ob2FyZTc4Y3NwLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fEx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpob2FyZTc4Y3NwLnBkZgAADgAeAA4AaABvAGEAcgBlADcAOABjAHMAcAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9ob2FyZTc4Y3NwLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS9ob2FyZTc4Y3NwLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/359576.359585}}

@article{wayman87occam,
	Abstract = {The programming language OCCAM has been developed for the design and implementation of systems of concurrent processes communicating over channels.  It is primarily intended for use as a programming language for the Inmos Transputer.  This paper has two aims: to review the major features of OCCAM, and to show how the language relates to various stages of the software development process.  It also reviews some of the decisions in the design of the language in the light of the criteria outlined in the introductory paper to this series on high-level languages.},
	Author = {Russell Wayman},
	Date-Added = {2009-06-11 16:08:03 -0700},
	Date-Modified = {2009-06-11 17:29:18 -0700},
	Journal = {Microprocessors and Microsystems},
	Keywords = {pl},
	Number = {8},
	Pages = {414--422},
	Title = {OCCAM 2: an overview from a software engineering perpective},
	Volume = {11},
	Year = {1987},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRF3YXltYW44N29jY2FtLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gjx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp3YXltYW44N29jY2FtLnBkZgAOACQAEQB3AGEAeQBtAGEAbgA4ADcAbwBjAGMAYQBtAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3dheW1hbjg3b2NjYW0ucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS93YXltYW44N29jY2FtLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?id=43432}}

@unpublished{hyde95occam,
	Abstract = {Occam is a parallel programming language developed in Great Britain. This Chapter describes the language, the circumstances surrounding its creation and its relationship to Inmos' Transputer. Occam is a good language for exploring the ideas of the message passing style of parallel programming. It has the important advantage that for a modest investment one can write truly parallel programs executing on an ensemble of Transputers.
},
	Annote = {Practical introduction to OCCAM.},
	Author = {Daniel C. Hyde},
	Date-Added = {2009-06-11 16:04:30 -0700},
	Date-Modified = {2009-06-11 17:05:06 -0700},
	Keywords = {pl},
	Month = {March},
	Note = {Online introduction},
	Title = {Introduction to the Programming Language {Occam}},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9oeWRlOTVvY2NhbS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fMx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpoeWRlOTVvY2NhbS5wZGYADgAgAA8AaAB5AGQAZQA5ADUAbwBjAGMAYQBtAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2h5ZGU5NW9jY2FtLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvaHlkZTk1b2NjYW0ucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb}}

@article{brookes84csp,
	Abstract = {A mathematical model for communicating sequential processes is given, and a number of its interesting and useful properties are stated and proved. The possibilities of nondetermimsm are fully taken into account.},
	Address = {New York, NY, USA},
	Author = {S. D. Brookes and C. A. R. Hoare and A. W. Roscoe},
	Date-Added = {2009-06-11 15:54:45 -0700},
	Date-Modified = {2009-06-12 14:52:21 -0700},
	Doi = {10.1145/828.833},
	Journal = {Journal of the ACM},
	Keywords = {pl,concurrent},
	Number = {3},
	Pages = {560--599},
	Title = {A Theory of Communicating Sequential Processes},
	Volume = {31},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBicm9va2VzODRjc3AucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eNx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpicm9va2VzODRjc3AucGRmAAAOACIAEABiAHIAbwBvAGsAZQBzADgANABjAHMAcAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9icm9va2VzODRjc3AucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2Jyb29rZXM4NGNzcC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/828.833}}

@inproceedings{agha86actor,
	Address = {New York, NY, USA},
	Author = {Gul Agha},
	Booktitle = {Proceedings of the 1986 SIGPLAN workshop on Object-oriented programming},
	Date-Added = {2009-06-11 15:48:42 -0700},
	Date-Modified = {2009-06-11 15:49:17 -0700},
	Doi = {10.1145/323779.323743},
	Keywords = {pl},
	Pages = {58--67},
	Publisher = {ACM},
	Title = {An overview of actor languages},
	Year = {1986},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9hZ2hhODZhY3Rvci5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d6x1O5FgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmWAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphZ2hhODZhY3Rvci5wZGYADgAgAA8AYQBnAGgAYQA4ADYAYQBjAHQAbwByAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2FnaGE4NmFjdG9yLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvYWdoYTg2YWN0b3IucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/323779.323743}}

@inproceedings{maessen95ph,
	Abstract = {The semantics of kernel pH are defined in the form of a parallel, normalizing interpreter. A description of I-structure and M-structure operators is also given within the same framework. Semantics of barriers in pH are presented by translation into the kernel language without barriers. The framework presented is also suitable for multithreaded compilation of pH.},
	Author = {Jan-Willem Maessen and Arvind and Shail Aditya and Lennart Augustsson and Rishiyur S. Nikhil},
	Booktitle = {In Proceedings from the {Haskell} Workshop (at FPCA 95)},
	Date-Added = {2009-06-11 15:02:18 -0700},
	Date-Modified = {2009-06-11 15:13:40 -0700},
	Keywords = {pl,dataflow},
	Pages = {35--49},
	Title = {Semantics of {pH}: A parallel dialect of {Haskell}},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9tYWVzc2VuOTVwaC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1frx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptYWVzc2VuOTVwaC5wZGYADgAgAA8AbQBhAGUAcwBzAGUAbgA5ADUAcABoAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L21hZXNzZW45NXBoLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvbWFlc3Nlbjk1cGgucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://csg.csail.mit.edu/projects/languages/ph.shtml}}

@inbook{jensen94petri,
	Abstract = {This paper presents the basic theoretical aspects of Coloured Petri Nets (CP-nets or CPN). CP-nets have been developed, from being a promising theoretical model, to being a full-fledged language for the design, specification, simulation, validation and implementation of large software systems (and other systems in which human beings and/or computers communicate by means of some more or less formal rules). The paper contains the formal definition of CP-nets and their basic concepts (e.g., the different dynamic properties such as liveness and fairness). The paper also contains a short introduction to the analysis methods, in particular occurrence graphs and place invariants.},
	Author = {Kurt Jensen},
	Chapter = {An introduction to the theoretical aspects of {C}oloured {P}etri {N}ets},
	Date-Added = {2009-06-11 13:00:50 -0700},
	Date-Modified = {2009-06-11 13:00:50 -0700},
	Keywords = {petrinets,pl},
	Pages = {230--272},
	Publisher = {Springer Berlin / Heidelberg},
	Series = {Lecture Notes in Computer Science},
	Title = {A Decade of Concurrency Reflections and Perspectives},
	Volume = {803/1994},
	Year = {1994},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFqZW5zZW45NHBldHJpLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fOx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpqZW5zZW45NHBldHJpLnBkZgAOACQAEQBqAGUAbgBzAGUAbgA5ADQAcABlAHQAcgBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2plbnNlbjk0cGV0cmkucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9qZW5zZW45NHBldHJpLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/3-540-58043-3_21}}

@inproceedings{turi07taverna,
	Abstract = {This paper presents the formal syntax and the operational semantics of Taverna, a workflow management system with a large user base among the e-Science community. Such formal foundation, which has so far been lacking, opens the way to the translation between Taverna workflows and other process models. In particular, the ability to automatically compile a simple domain-specific process description into Taverna facilitates its adoption by e-scientists who are not expert workflow developers. We demonstrate this potential through a practical use case. },
	Address = {Washington, DC, USA},
	Author = {Daniele Turi and Paolo Missier and Carole Goble and David {De Roure} and Tom Oinn},
	Booktitle = {E-SCIENCE '07: Proceedings of the Third IEEE International Conference on e-Science and Grid Computing},
	Date-Added = {2009-06-10 17:39:25 -0700},
	Date-Modified = {2009-06-10 17:40:56 -0700},
	Doi = {10.1109/E-SCIENCE.2007.71},
	Keywords = {workflow,pl},
	Pages = {441--448},
	Publisher = {IEEE Computer Society},
	Title = {Taverna Workflows: Syntax and Semantics},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRF0dXJpMDd0YXZlcm5hLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gdx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp0dXJpMDd0YXZlcm5hLnBkZgAOACQAEQB0AHUAcgBpADAANwB0AGEAdgBlAHIAbgBhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3R1cmkwN3RhdmVybmEucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS90dXJpMDd0YXZlcm5hLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/E-SCIENCE.2007.71}}

@article{zaharia08mapreduce,
	Author = {Matei Zaharia and Andy Konwinski and Anthony D. Joseph and Randy Katz and Ion Stoica},
	Date-Added = {2009-06-04 18:27:15 -0700},
	Date-Modified = {2009-06-04 18:38:38 -0700},
	Journal = {Proceedings of USENIX OSDI},
	Keywords = {concurrent},
	Title = {Improving {MapReduce} Performance in Heterogeneous Environments},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZ6YWhhcmlhMDhtYXByZWR1Y2UucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gox1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp6YWhhcmlhMDhtYXByZWR1Y2UucGRmAAAOAC4AFgB6AGEAaABhAHIAaQBhADAAOABtAGEAcAByAGUAZAB1AGMAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS96YWhhcmlhMDhtYXByZWR1Y2UucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L3phaGFyaWEwOG1hcHJlZHVjZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://techreports.lib.berkeley.edu/accessPages/EECS-2008-99.html}}

@article{broy98rw,
	Abstract = {The definitions and discussions below were contributed via e-mail. They are arranged by date. The experts, listed alphabetically above, participated in this virtual round table during the first quarter of 1998.},
	Author = {Manfred Broy and Anton Deimel and Juergen Henn and Kai Koskimies and Frantisek Plasil and Gustav Pomberger and Wolfgang Pree and Michael Stal and Clemens Szyperski},
	Date-Added = {2009-05-31 20:13:11 -0700},
	Date-Modified = {2009-05-31 20:15:05 -0700},
	Journal = {Software - Concepts \& Tools},
	Keywords = {component},
	Month = {June},
	Number = {1},
	Pages = {49--56},
	Title = {What characterizes a (software) component?},
	Volume = {19},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAagAAAAAAagAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQxicm95OThydy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eOx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBHTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpicm95OThydy5wZGYAAA4AGgAMAGIAcgBvAHkAOQA4AHIAdwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAOlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9icm95OThydy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QFExpYnJhcnkvYnJveTk4cncucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAkwCTgJTAlwCZwJrAnkCgAKJAqACpQKoArUCugAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALM},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/s003780050007}}

@inbook{smolinski99interop,
	Abstract = {Component technologies offer a promising approach for managing the increasing complexity and interdisciplinary nature of high-performance scientific applications. Language interoperability is required for components written in different languages to communicate. In this paper, we present an approach to language interoperability for high-performance parallel components. Based on Interface Definition Language (IDL) techniques, we have developed a Scientific IDL (SIDL) that focuses on the abstractions and performance requirements of the scientific domain. We are developing a SIDL compiler and the associated run-time support for reference counting, reflection, object management, and basic exception handling. The SIDL approach has been validated for a scientific linear solver library. Initial timing results indicate that the performance overhead is minimal (less than 1%), whereas the savings in development time for interoperable software libraries can be substantial. },
	Author = {Brent A. Smolinski and Scott Kohn and Noah Elliott and Nathan Dykman},
	Chapter = {Language Interoperability for High-Performance Parallel Scientific Components},
	Date-Added = {2009-05-31 20:09:30 -0700},
	Date-Modified = {2009-05-31 20:10:54 -0700},
	Keywords = {component},
	Pages = {61--71},
	Publisher = {Springer Berlin / Heidelberg},
	Title = {Computing in Object-Oriented Parallel Environments},
	Volume = {1732},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZzbW9saW5za2k5OWludGVyb3AucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gTx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzbW9saW5za2k5OWludGVyb3AucGRmAAAOAC4AFgBzAG0AbwBsAGkAbgBzAGsAaQA5ADkAaQBuAHQAZQByAG8AcAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9zbW9saW5za2k5OWludGVyb3AucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L3Ntb2xpbnNraTk5aW50ZXJvcC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/10704054_7}}

@inproceedings{armstrong99common,
	Abstract = {This paper describes work in progress to develop a standard for interoperability among high-performance scientific components. This research stems from growing recognition that the scientific community needs to better manage the complexity of multidisciplinary simulations and better address scalable performance issues on parallel and distributed architectures. Driving forces are the need for fast connections among components that perform numerically intensive work and for parallel collective interactions among components that use multiple processes or threads. This paper focuses on the areas we believe are most crucial in this context, namely, an interface definition language that supports scientific abstractions for specifying component interfaces and a ports connection model for specifying component interactions.},
	Author = {Robert C. Armstrong and Dennis Gannon and Al Geist and Katarzyna Keahey and Scott R. Kohn and Lois C. McInnes and Steve R. Parker and Brent A. Smolinski},
	Booktitle = {Proceedings of the 8th IEEE International Symposium on High Performance Distributed Computing},
	Date-Added = {2009-05-31 19:16:40 -0700},
	Date-Modified = {2009-05-31 19:22:32 -0700},
	Keywords = {component},
	Pages = {13--23},
	Title = {Toward a Common Component Architecture for High-Performance Scientific Computing},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVhcm1zdHJvbmc5OWNvbW1vbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eDx1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphcm1zdHJvbmc5OWNvbW1vbi5wZGYADgAsABUAYQByAG0AcwB0AHIAbwBuAGcAOQA5AGMAbwBtAG0AbwBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2FybXN0cm9uZzk5Y29tbW9uLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvYXJtc3Ryb25nOTljb21tb24ucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5}}

@article{meyer92design,
	Abstract = {Methodological guidelines for object-oriented software construction that improve the reliability of the resulting software systems are presented. It is shown that the object-oriented techniques rely on the theory of design by contract, which underlies the design of the Eiffel analysis, design, and programming language and of the supporting libraries, from which a number of examples are drawn. The theory of contract design and the role of assertions in that theory are discussed.},
	Author = {Bertrand Meyer},
	Date-Added = {2009-05-31 15:59:26 -0700},
	Date-Modified = {2009-05-31 16:04:29 -0700},
	Journal = {IEEE Computer},
	Keywords = {component},
	Month = {October},
	Number = {10},
	Pages = {40--51},
	Title = {Applying ``Design by contract''},
	Volume = {25},
	Year = {1992},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFtZXllcjkyZGVzaWduLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fvx1O5IgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmiAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptZXllcjkyZGVzaWduLnBkZgAOACQAEQBtAGUAeQBlAHIAOQAyAGQAZQBzAGkAZwBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L21leWVyOTJkZXNpZ24ucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9tZXllcjkyZGVzaWduLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/2.161279}}

@book{pierce02types,
	Author = {Benjamin C. Pierce},
	Date-Added = {2009-05-31 15:46:13 -0700},
	Date-Modified = {2009-05-31 15:47:59 -0700},
	Edition = {1},
	Keywords = {pl,types},
	Month = {February},
	Publisher = {MIT Press},
	Title = {Types and Programming Languages},
	Year = {2002},
	Bdsk-Url-1 = {http://www.cis.upenn.edu/~bcpierce/tapl/}}

@article{aalst98petri,
	Abstract = {Describes how to use Petri nets for workflow modeling. States advantages of Petri nets in this domain (formal semantics, graphical nature, expressiveness, analysis, vendor independence) (These advantages are disputed (if I recall correctly) by Eshuis et al. in his thesis and several publications). Gives references to other people advocating Petri nets as modeling formalism. Defines workflow management and shows how to model this using Petri nets. Introduces analysis techniques for Petri net workflow models.},
	Author = {W. M. P. van der Aalst},
	Date-Added = {2009-05-31 15:40:04 -0700},
	Date-Modified = {2009-05-31 15:41:24 -0700},
	Journal = {The Journal of Circuits, Systems and Computers},
	Keywords = {petrinets,workflow},
	Number = {1},
	Pages = {21--66},
	Title = {The Application of {Petri} Nets to Workflow Management},
	Volume = {8},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBhYWxzdDk4cGV0cmkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d3x1O5FQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmVAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphYWxzdDk4cGV0cmkucGRmAAAOACIAEABhAGEAbABzAHQAOQA4AHAAZQB0AHIAaQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9hYWxzdDk4cGV0cmkucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2FhbHN0OThwZXRyaS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://wwwis.win.tue.nl/~wsinwa/Publications/p53.PDF}}

@book{baader98term,
	Author = {Franz Baader and Tobias Nipkow},
	Date-Added = {2009-05-31 15:08:30 -0700},
	Date-Modified = {2009-05-31 15:48:21 -0700},
	Keywords = {pl,rewriting},
	Publisher = {Cambridge University Press},
	Title = {Term Rewriting and All That},
	Year = {1998}}

@inproceedings{seres99prolog,
	Abstract = {We propose an embedding of logic programming into lazy functional programming in which each predicate in a Prolog program becomes a Haskell function, in such a way that both the declarative and the procedural reading of the Prolog predicate are preserved. The embedding computes by means of operations on lazy lists. The state of each step in computation is passed on as a stream of answer substitutions, and all the logic operators of Prolog are implemented by explicit Haskell operators on these streams. The search strategy can be changed by altering the basic types of the embedding and the implementation of these operators. This model results in a perspicuous semantics for logic programs, and serves as a good example of modularisation in functional programming.},
	Author = {Silvija Seres and Michael Spivey},
	Booktitle = {Proceedings of the 1999 Haskell Workshop, Technical Report UU-CS-1999-28},
	Date-Added = {2009-05-31 14:58:56 -0700},
	Date-Modified = {2009-05-31 15:07:05 -0700},
	Institution = {Department of Computer Science, University of Utrecht},
	Keywords = {pl,logic,haskell},
	Pages = {25--38},
	Title = {Embedding {PROLOG} in {H}askell},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFzZXJlczk5cHJvbG9nLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gPx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzZXJlczk5cHJvbG9nLnBkZgAOACQAEQBzAGUAcgBlAHMAOQA5AHAAcgBvAGwAbwBnAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3NlcmVzOTlwcm9sb2cucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9zZXJlczk5cHJvbG9nLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://lambda-the-ultimate.org/node/112}}

@inproceedings{beazley96swig,
	Abstract = {I present SWIG (Simplified Wrapper and Interface Generator), a program development tool that automatically generates the bindings between C/C++ code and common scripting languages including Tcl, Python, Perl and Guile. SWIG supports most C/C++ datatypes including pointers, structures, and classes. Unlike many other approaches, SWIG uses ANSI C/C++ declarations and requires the user to make virtually no modifications to the underlying C code. In addition, SWIG automatically produces documentation in HTML, LaTeX, or ASCII format. SWIG has been primarily designed for scientists, engineers, and application developers who would like to use scripting languages with their C/C++ programs without worrying about the underlying implementation details of each language or using a complicated software development tool. This paper concentrates on SWIG's use with Tcl/Tk.},
	Author = {David M. Beazley},
	Booktitle = {TCLTK'96: Proceedings of the 4th conference on USENIX Tcl/Tk Workshop, 1996},
	Date-Added = {2009-05-31 14:44:28 -0700},
	Date-Modified = {2009-05-31 14:47:24 -0700},
	Keywords = {pl,ffi},
	Month = {July},
	Title = {{SWIG}: an easy to use tool for integrating scripting languages with {C} and {C++}},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFiZWF6bGV5OTZzd2lnLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eHx1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpiZWF6bGV5OTZzd2lnLnBkZgAOACQAEQBiAGUAYQB6AGwAZQB5ADkANgBzAHcAaQBnAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2JlYXpsZXk5NnN3aWcucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9iZWF6bGV5OTZzd2lnLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?id=1267498.1267513}}

@inproceedings{jones97greencard,
	Abstract = {A foreign-languge interface provides a way for software components written in one language to interact with components written in another.  Programming langauges that lack foreign-language interfaces die a lingering death.  This document describes Green Card, a foreign-language interface for the non-strict, purely functional language Haskell.  We assume some knowledge of Haskell and C.},
	Author = {Simon Peyton Jones and Thomas Nordin and Alastair Reid},
	Booktitle = {ACM SIGPLAN Haskell Workshop (in conjuction with ICFP97)},
	Date-Added = {2009-05-31 14:29:21 -0700},
	Date-Modified = {2009-05-31 14:34:14 -0700},
	Keywords = {pl,ffi},
	Month = {February},
	Title = {Green Card: a foreign language interface for {H}askell},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRqb25lczk3Z3JlZW5jYXJkLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fTx1O5HgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmeAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpqb25lczk3Z3JlZW5jYXJkLnBkZgAADgAqABQAagBvAG4AZQBzADkANwBnAHIAZQBlAG4AYwBhAHIAZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9qb25lczk3Z3JlZW5jYXJkLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9qb25lczk3Z3JlZW5jYXJkLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://www.haskell.org/haskell-workshop/1997/}}

@misc{erwig06rules,
	Abstract = {We present a domain-specific embedded language that allows the definition of rule systems in Haskell. As one particular example, we consider the modeling of type systems, which is an important part of programming language design. Type systems are most conveniently described using rule systems. Our approach is well integrated into Haskell's type system and thus facilitates the convenient modeling of type systems and language semantics in general. We also demonstrate how our DSEL allows functional-logic programming in Haskell.

Our system generalizes previous work by operating on user-defined data types, taking advantage of static typing, representing rules as functions, and allows a creative integration of logical variables into data structures which generalizes two previous approaches. We describe a straightforward method for translating rule systems into our DSEL.},
	Author = {Steve Kollmansberger and Martin Erwig},
	Date-Added = {2009-05-20 13:11:57 -0700},
	Date-Modified = {2009-05-20 13:11:57 -0700},
	Keywords = {pl,haskell,rewriting,rules},
	Month = {June},
	Title = {Haskell Rules: Embedding Rule Systems in {H}askell},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBlcndpZzA2cnVsZXMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1emx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTplcndpZzA2cnVsZXMucGRmAAAOACIAEABlAHIAdwBpAGcAMAA2AHIAdQBsAGUAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9lcndpZzA2cnVsZXMucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2Vyd2lnMDZydWxlcy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://web.engr.oregonstate.edu/~erwig/HaskellRules/}}

@inproceedings{coutts07fusion,
	Address = {New York, NY, USA},
	Author = {Duncan Coutts and Roman Leshchinskiy and Don Stewart},
	Booktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming, ICFP 2007},
	Date-Added = {2009-05-19 08:10:48 -0700},
	Date-Modified = {2009-05-19 08:13:08 -0700},
	Keywords = {pl,streams,optimization},
	Month = apr,
	Pages = {315--326},
	Publisher = {ACM},
	Title = {Stream Fusion: From Lists to Streams to Nothing at All},
	Year = 2007,
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJjb3V0dHMwN2Z1c2lvbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ecx1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjb3V0dHMwN2Z1c2lvbi5wZGYAAA4AJgASAGMAbwB1AHQAdABzADAANwBmAHUAcwBpAG8AbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9jb3V0dHMwN2Z1c2lvbi5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvY291dHRzMDdmdXNpb24ucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1291151.1291199}}

@article{visser98core,
	Abstract = {
System S is a calculus providing the basic abstractions of term rewriting: matching and building terms, term traversal, combining computations and handling failure. The calculus forms a core language for implementation of a wide variety of rewriting languages, or more generally, languages for specifying tree transformations. In this paper we show how a conventional rewriting language based on conditional term rewriting can be implemented straightforwardly in System S. Subsequently we show how this implementation can be extended with features such as matching conditions, negative conditions, default rules, non-strictness annotations and alternative evaluation strategies.

We thank Bas Luttik and Andrew Tolmach for many discussions on rewriting strategies and their applications. Jan Bergstra pointed out the problems of non-determinism and conditional rules in languages such as ASF+SDF. Eu-genio Moggi made clear that our semantics does not model programs with global backtracking, but rather local backtracking, which was what we were looking for.},
	Author = {Eelco Visser and Zine-el-Abidine Benaissa},
	Date-Added = {2009-05-16 13:32:08 -0700},
	Date-Modified = {2009-05-16 13:33:10 -0700},
	Doi = {10.1016/S1571-0661(05)80027-1},
	Issn = {1571-0661},
	Journal = {Electronic Notes in Theoretical Computer Science},
	Keywords = {rewriting,pl},
	Note = {International Workshop on Rewriting Logic and its Applications},
	Pages = {422 - 441},
	Title = {A Core Language for Rewriting},
	Volume = {15},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRB2aXNzZXI5OGNvcmUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ggx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp2aXNzZXI5OGNvcmUucGRmAAAOACIAEAB2AGkAcwBzAGUAcgA5ADgAYwBvAHIAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS92aXNzZXI5OGNvcmUucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L3Zpc3Nlcjk4Y29yZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/B75H1-4G6932F-31/2/dc0916abf9a2668f4f128ba5e305e733}}

@article{visser01survey,
	Abstract = {Program transformation is used in a wide range of applications including compiler construction, optimization, program synthesis, refactoring, software renovation, and reverse engineering. Complex program transformations are achieved through a number of consecutive modifications of a program. Transformation rules define basic modifications. A transformation strategy is an algorithm for choosing a path in the rewrite relation induced by a set of rules. This paper surveys the support for the definition of strategies in program transformation systems. After a discussion of kinds of program transformation and choices in program representation, the basic elements of a strategy system are discussed and the choices in the design of a strategy language are considered. Several styles of strategy systems as provided in existing languages are then analyzed.},
	Author = {Eelco Visser},
	Date-Added = {2009-05-16 13:29:10 -0700},
	Date-Modified = {2009-05-16 13:30:16 -0700},
	Doi = {10.1016/S1571-0661(04)00270-1},
	Issn = {1571-0661},
	Journal = {Electronic Notes in Theoretical Computer Science},
	Keywords = {rewriting,pl},
	Note = {WRS 2001, 1st International Workshop on Reduction Strategies in Rewriting and Programming},
	Pages = {109 - 143},
	Title = {A Survey of Rewriting Strategies in Program Transformation Systems},
	Volume = {57},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJ2aXNzZXIwMXN1cnZleS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gfx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp2aXNzZXIwMXN1cnZleS5wZGYAAA4AJgASAHYAaQBzAHMAZQByADAAMQBzAHUAcgB2AGUAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS92aXNzZXIwMXN1cnZleS5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvdmlzc2VyMDFzdXJ2ZXkucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/B75H1-4DD870G-6M/2/72a193f604d68ab5805ca4665c019960}}

@techreport{cheney03phantom,
	Abstract = {Classical phantom types are datatypes in which type constraints are expressed using type variables that do not appear in the datatype cases themselves. They can be used to embed typed languages into Haskell or ML. However, while such encodings guarantee that only well-formed data can be constructed, they do not permit type-safe deconstruction without additional tagging and run-time checks. We introduce first-class phantom types, which make such constraints explicit via type equations. Examples of first-class phantom types include typed type representations and typed higher-order abstract syntax trees. These types can be used to support typed generic functions, dynamic typing, and staged compilation in higher-order, statically typed languages such as Haskell or Standard ML. In our system, type constraints can be equations between type constructors as well as type functions of higher-order kinds. We prove type soundness and decidability for a Haskell-like language extended by first-class phantom types.},
	Author = {James Cheney and Ralf Hinze},
	Date-Added = {2009-05-15 17:17:47 -0700},
	Date-Modified = {2009-05-18 14:08:40 -0700},
	Institution = {Cornell University},
	Keywords = {types},
	Title = {First-class phantom types},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNjaGVuZXkwM3BoYW50b20ucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eUx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjaGVuZXkwM3BoYW50b20ucGRmAA4AKAATAGMAaABlAG4AZQB5ADAAMwBwAGgAYQBuAHQAbwBtAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2NoZW5leTAzcGhhbnRvbS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2NoZW5leTAzcGhhbnRvbS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://hdl.handle.net/1813/5614}}

@misc{klop09prod,
	Abstract = {Infinite objects like streams of natural numbers or other data can be specified by a variety of methods. Our framework is that of 
recursive equations, common in functional languages, based on infinitary term rewriting. For many specifications such as alt = 0 
: 1 : alt, defining the stream of alternating bits, well-definedness is evident. For more involved specifications such as fib = 0 : 1 : 
(fib + tail(fib)) well-definedness is not obvious, and decision methods are needed. This is the issue of productivity, consisting of 
determining whether a specification yields an infinite normal form composed of constructors. In a slogan: productivity is for 
infinite objects what termination is for finite data specifications. There are various methods to ensure productivity. For `pure' 
stream specifications such as above, a powerful automated method has been developed based on a fine-grained pebbleflow 
network analysis. 

Pebbles * are abstracted data: 0 = 1 = *. This data-oblivious approach can be extended by taking the identity of data into 
consideration (data-aware). In this proposal we extend the approach by admitting stream dependent data functions such as 
head of a stream. This involves dealing with `foresight' as in Y = 0 : head(tail(tail(Y))) : Y. Our primary concern is to treat stream 
dependent data functions, by explicitation of the input-output behaviour via a dependency analysis of the stream elements. 
Thus, we can deal also with partially defined stream terms. Second, we aim to generalize the methods to infinite data structures 
other than streams, such as infinite trees, lambda terms, and proof objects.},
	Author = {Jan Willem Klop and Roel de Vrijer},
	Date-Added = {2009-05-15 17:11:21 -0700},
	Date-Modified = {2009-05-15 17:15:52 -0700},
	Keywords = {logic, productivity, streams},
	Month = {February},
	Title = {Research Proposal: Lazy Productivity},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ5rbG9wMDlwcm9kLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fZx1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTprbG9wMDlwcm9kLnBkZgAADgAeAA4AawBsAG8AcAAwADkAcAByAG8AZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9rbG9wMDlwcm9kLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS9rbG9wMDlwcm9kLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==}}

@inproceedings{blume01nlffi,
	Abstract = {We present a new foreign-function interface for SML/NJ. It is based on the idea of datalevel interoperability---the ability of ML programs to inspect as well as manipulate C data structures directly. The core component of this work is an encoding of the almost 2 complete C type system in ML types. The encoding makes extensive use of a ``folklore '' typing trick, taking advantage of ML's polymorphism, its type constructors, its abstraction mechanisms, and even functors. A small low-level component which deals with C struct and union declarations as well as program linkage is hidden from the programmer's eye by a simple program-generator tool that translates C declarations to corresponding ML glue code. 1 An example Suppose you are an ML programmer who wants to link a program with some C routines. The following example (designed to demonstrate data-level interoperability rather than motivate the need for FFIs in the first place) there are two C functions: input reads a list of records from a file and findmin returns the record with the smallestiin a given list. The C library comes with a header fileixdb.h that describes this interface: typedef struct record *list; struct record { int i; double x; list next;}; extern list input (char *); extern list findmin (list); Our ml-nlffigen tool translates ixdb.h into an ML interface that corresponds nearly perfectly to the original C interface. Moreover, we hooked mlnlffigen into the compilation manager CM [2] of SML/NJ [1] in such a way 2 Variable-argument functions are the only feature of the C type system that we do not handle very well yet.},
	Author = {Matthias Blume},
	Booktitle = {Electronic Notes in Theoretical Computer Science},
	Date-Added = {2009-05-14 11:25:46 -0700},
	Date-Modified = {2009-05-14 11:51:51 -0700},
	Keywords = {ffi, pl},
	Title = {No-longer-foreign: Teaching an {ML} compiler to speak {C} natively},
	Volume = {59},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBibHVtZTAxbmxmZmkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eKx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpibHVtZTAxbmxmZmkucGRmAAAOACIAEABiAGwAdQBtAGUAMAAxAG4AbABmAGYAaQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9ibHVtZTAxbmxmZmkucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2JsdW1lMDFubGZmaS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.91.3171}}

@inproceedings{reppy06ffi,
	Abstract = {A  foreign interface  (FI) mechanism to support interoperability with libraries written in other languages (especially C) is an important feature in most high-level language implementations. Such FI mechanisms provide a  Foreign Function Interface  (FFI) for the high-level language to call C functions and marshaling and unmarshaling mechanisms to support conversion between the high-level and C data representations. Often, systems provide tools to automate the generation of FIs, but these tools typically lock the user into a specific model of interoperability. It is our belief that the  policy  used to craft the mapping between the high-level language and C should be distinct from the underlying  mechanism  used to implement the mapping.In this paper, we describe a FI generation tool, called FIG (for  Foreign Interface Generator ) that embodies a new approach to the problem of generating foreign interfaces for high-level languages. FIG takes as input raw C header files plus a declarative script that specifies the generation of the foreign interface from the header file. The script sets the policy for the translation, which allows the user to tailor the resulting FI to his or her application. We call this approach  application-specific  foreign-interface generation. The scripting language uses rewriting strategies as its execution model. The other major feature of the scripting language is a novel notion of composable  typemaps  that describe the mapping between high-level and low-level types.},
	Address = {New York, NY, USA},
	Author = {John Reppy and Chunyan Song},
	Booktitle = {GPCE '06: Proceedings of the 5th international conference on Generative programming and component engineering},
	Date-Added = {2009-05-14 11:25:37 -0700},
	Date-Modified = {2009-05-14 11:51:00 -0700},
	Doi = {10.1145/1173706.1173714},
	Keywords = {ffi, pl},
	Location = {Portland, Oregon, USA},
	Pages = {49--58},
	Publisher = {ACM},
	Title = {Application-specific foreign-interface generation},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ5yZXBweTA2ZmZpLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gIx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyZXBweTA2ZmZpLnBkZgAADgAeAA4AcgBlAHAAcAB5ADAANgBmAGYAaQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9yZXBweTA2ZmZpLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS9yZXBweTA2ZmZpLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1173706.1173714}}

@inproceedings{filinski94monads,
	Abstract = {We show that any monad whose unit and extension operations are expressible as purely functional terms can be embedded in a call-by-value language with ``composable continuations''. As part of the development, we extend Meyer and Wand's characterization of the relationship between continuation-passing and direct style to one for continuation-passing vs. general ``monadic'' style. We further show that the composable continuations construct can itself be represented using ordinary, non-composable first-class continuations and a single piece of state. Thus, in the presence of two specific computational effects -- storage and escapes -- any expressible monadic structure (e.g., nondeterminism as represented by the list monad) can be added as a purely definitional extension, without requiring a reinterpretation of the whole language. The paper includes an implementation of the construction (in Standard ML with some New Jersey extensions) and several examples.},
	Author = {Filinski, Andrzej},
	Booktitle = {Proceedings of the Twenty-First Annual ACM Symposium on Principles of Programming Languages},
	Date-Added = {2009-05-14 11:25:24 -0700},
	Date-Modified = {2009-05-14 11:48:27 -0700},
	Keywords = {monad, nondeterminism, pl},
	Pages = {446--457},
	Title = {Representing monads},
	Year = {1994},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRmaWxpbnNraTk0bW9uYWRzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eqx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmaWxpbnNraTk0bW9uYWRzLnBkZgAADgAqABQAZgBpAGwAaQBuAHMAawBpADkANABtAG8AbgBhAGQAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9maWxpbnNraTk0bW9uYWRzLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9maWxpbnNraTk0bW9uYWRzLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.8213}}

@inproceedings{launchbury94threads,
	Abstract = {Some algorithms make critical internal use of updatable state, even though their external specification is purely functional. Based on earlier work on monads, we present a way of securely encapsulating such stateful computations, in the context of a non-strict, purely-functional language. There are two main new developments in this paper. First, we show how to use the type system to securely encapsulate stateful computations, including ones which manipulate multiple, named, mutable objects. Second, we give a formal semantics for our system. This paper has been submitted to Programming Languages Design and Implementation (PLDI) \&\#039;94. 1},
	Author = {John Launchbury and Simon P. Jones},
	Booktitle = {Programming Languages Design and Implementation},
	Date-Added = {2009-05-14 11:25:10 -0700},
	Date-Modified = {2009-05-14 11:47:29 -0700},
	Keywords = {datastructures, haskell, pl},
	Pages = {24--35},
	Title = {Lazy functional state threads},
	Year = {1994},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdQAAAAAAdQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRdsYXVuY2hidXJ5OTR0aHJlYWRzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fdx1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBSTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsYXVuY2hidXJ5OTR0aHJlYWRzLnBkZgAOADAAFwBsAGEAdQBuAGMAaABiAHUAcgB5ADkANAB0AGgAcgBlAGEAZABzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBFVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2xhdW5jaGJ1cnk5NHRocmVhZHMucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAfTGlicmFyeS9sYXVuY2hidXJ5OTR0aHJlYWRzLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJ4AnoCfwKIApMClwKlAqwCtQLXAtwC3wLsAvEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADAw==},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.3299}}

@techreport{armbrust09cloud,
	Abstract = {Provided certain obstacles are overcome, we believe Cloud Computing has the potential to transform a large part of the IT industry, making software even more attractive as a service and shaping the way IT hardware is designed and purchased. Developers with innovative ideas for new interactive Internet services no longer require the large capital outlays in hardware to deploy their service or the human expense to operate it. They need not be concerned about over-provisioning for a service whose popularity does not meet their predictions, thus wasting costly resources, or under-provisioning for one that becomes wildly popular, thus missing potential customers and revenue. Moreover, companies with large batch-oriented tasks can get their results as quickly as their programs can scale, since using 1000 servers for one hour costs no more than using one server for 1000 hours. This elasticity of resources, without paying a premium for large scale, is unprecedented in the history of IT. The economies of scale of very large-scale datacenters combined with ``pay-as-you-go'' resource usage has heralded the rise of Cloud Computing. It is now attractive to deploy an innovative new Internet service on a third party's Internet Datacenter rather than your own infrastructure, and to gracefully scale its resources as it grows or declines in popularity and revenue. Expanding and shrinking daily in response to normal diurnal patterns could lower costs even further. Cloud Computing transfers the risks of over-provisioning or under-provisioning to the Cloud Computing provider, who mitigates that risk by statistical multiplexing over a much larger set of users and who offers relatively low prices due better utilization and from the economy of purchasing at a larger scale. We define terms, present an economic model that quantifies the key buy vs. pay-as-you-go decision, offer a spectrum to classify Cloud Computing providers, and give our view of the top 10 obstacles and opportunities to the growth of Cloud Computing.},
	Author = {Michael Armbrust and Armando Fox and Rean Griffith and Anthony D. Joseph and Randy H. Katz and Andrew Konwinski and Gunho Lee and David A. Patterson and Ariel Rabkin and Ion Stoica and Matei Zaharia},
	Date-Added = {2009-05-14 11:24:57 -0700},
	Date-Modified = {2009-05-14 12:06:56 -0700},
	Institution = {EECS Department, University of California, Berkeley},
	Keywords = {cloud},
	Month = {February},
	Title = {Above the Clouds: A {B}erkeley View of Cloud Computing},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNhcm1icnVzdDA5Y2xvdWQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eBx1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphcm1icnVzdDA5Y2xvdWQucGRmAA4AKAATAGEAcgBtAGIAcgB1AHMAdAAwADkAYwBsAG8AdQBkAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2FybWJydXN0MDljbG91ZC5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2FybWJydXN0MDljbG91ZC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://www.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-28.html}}

@article{fraser07locks,
	Abstract = {Mutual exclusion locks remain the de facto mechanism for concurrency control on shared-memory data structures. However, their apparent simplicity is deceptive: It is hard to design scalable locking strategies because locks can harbor problems such as priority inversion, deadlock, and convoying. Furthermore, scalable lock-based systems are not readily composable when building compound operations. In looking for solutions to these problems, interest has developed in nonblocking systems which have promised scalability and robustness by eschewing mutual exclusion while still ensuring safety. However, existing techniques for building nonblocking systems are rarely suitable for practical use, imposing substantial storage overheads, serializing nonconflicting operations, or requiring instructions not readily available on today's CPUs.

In this article we present three APIs which make it easier to develop nonblocking implementations of arbitrary data structures. The first API is a multiword compare-and-swap operation (MCAS) which atomically updates a set of memory locations. This can be used to advance a data structure from one consistent state to another. The second API is a word-based software transactional memory (WSTM) which can allow sequential code to be reused more directly than with MCAS and which provides better scalability when locations are being read rather than being updated. The third API is an object-based software transactional memory (OSTM). OSTM allows a simpler implementation than WSTM, but at the cost of reengineering the code to use OSTM objects.

We present practical implementations of all three of these APIs, built from operations available across all of today's major CPU families. We illustrate the use of these APIs by using them to build highly concurrent skip lists and red-black trees. We compare the performance of the resulting implementations against one another and against high-performance lock-based systems. These results demonstrate that it is possible to build useful nonblocking data structures with performance comparable to, or better than, sophisticated lock-based designs.},
	Address = {New York, NY, USA},
	Author = {Keir Fraser and Tim Harris},
	Date-Added = {2009-05-14 11:24:46 -0700},
	Date-Modified = {2009-05-14 11:42:28 -0700},
	Doi = {10.1145/1233307.1233309},
	Journal = {ACM Trans. Comput. Syst.},
	Keywords = {concurrent},
	Month = {May},
	Number = {2},
	Publisher = {ACM Press},
	Title = {Concurrent programming without locks},
	Volume = {25},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFmcmFzZXIwN2xvY2tzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ewx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmcmFzZXIwN2xvY2tzLnBkZgAOACQAEQBmAHIAYQBzAGUAcgAwADcAbABvAGMAawBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2ZyYXNlcjA3bG9ja3MucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9mcmFzZXIwN2xvY2tzLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1233307.1233309}}

@inproceedings{jones96concurrent,
	Abstract = {Some applications are most easily expressed in a programming language that supports concurrency, notably interactive and distributed systems. We propose extensions to the purely functional language Haskell that allow it to express explicitly concurrent applications; we call the resulting language Concurrent Haskell.  The resulting system appears to be both expressive and efficient and we give a number of examples of useful abstractions that can be built from our primitives.  We have developed a freely available implementation of Concurrent Haskell and are now using it as a substrate for a graphical user interface toolkit.},
	Address = {New York, NY, USA},
	Author = {Simon P. Jones and Andrew Gordon and Sigbjorn Finne},
	Booktitle = {POPL '96: Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2009-05-14 11:24:37 -0700},
	Date-Modified = {2009-05-18 14:08:12 -0700},
	Doi = {10.1145/237721.237794},
	Keywords = {concurrent, functional, haskell},
	Pages = {295--308},
	Publisher = {ACM},
	Title = {Concurrent Haskell},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVqb25lczk2Y29uY3VycmVudC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fSx1O5HgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmeAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpqb25lczk2Y29uY3VycmVudC5wZGYADgAsABUAagBvAG4AZQBzADkANgBjAG8AbgBjAHUAcgByAGUAbgB0AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2pvbmVzOTZjb25jdXJyZW50LnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvam9uZXM5NmNvbmN1cnJlbnQucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/237721.237794}}

@article{karp87parallel,
	Abstract = {The state of the art of parallel programming and what a sorry state that art is in.},
	Address = {Los Alamitos, CA, USA},
	Author = {Alan H. Karp},
	Date-Added = {2009-05-14 11:24:25 -0700},
	Date-Modified = {2009-05-14 11:41:46 -0700},
	Doi = {10.1109/MC.1987.1663563},
	Journal = {Computer},
	Keywords = {messagepassing, parallel, pl},
	Number = {5},
	Pages = {43--57},
	Publisher = {IEEE Computer Society Press},
	Title = {Programming for Parallelism},
	Volume = {20},
	Year = {1987},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJrYXJwODdwYXJhbGxlbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fWx1O5HwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmfAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTprYXJwODdwYXJhbGxlbC5wZGYAAA4AJgASAGsAYQByAHAAOAA3AHAAYQByAGEAbABsAGUAbAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9rYXJwODdwYXJhbGxlbC5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkva2FycDg3cGFyYWxsZWwucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/MC.1987.1663563}}

@techreport{nikhil94id,
	Author = {Rishiyur S. Nikhil},
	Date-Added = {2009-05-14 11:23:27 -0700},
	Date-Modified = {2009-05-31 15:49:29 -0700},
	Institution = {Digital Equipment Corporation, Cambridge Research Laboratory},
	Keywords = {dataflow, pl},
	Title = {An Overview of the Parallel Language {I}d (A Foundation for {pH}, a Parallel Dialect of {H}askell)},
	Year = {1994},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ5uaWtoaWw5NGlkLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f5x1O5IwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmjAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpuaWtoaWw5NGlkLnBkZgAADgAeAA4AbgBpAGsAaABpAGwAOQA0AGkAZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9uaWtoaWw5NGlkLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS9uaWtoaWw5NGlkLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.5676}}

@article{nikhil89subsume,
	Abstract = {We explore the question: ``What can a von Neumann processor borrow from dataflow to make it more suitable for a multiprocessor?'' Starting with a simple, ``RISC-like'' instruction set, we show how to change the underlying processor organization to make it multithreaded. Then, we extend it with three instructions that give it a fine-grained, dataflow capability. We call the result P-RISC, for ``Parallel RISC.'' Finally, we discuss memory support for such multiprocessors. We compare our approach to existing MIMD machines and to other dataflow machines.},
	Address = {New York, NY, USA},
	Author = {R.S. Nikhil},
	Date-Added = {2009-05-14 11:22:01 -0700},
	Date-Modified = {2009-05-14 11:22:32 -0700},
	Doi = {10.1145/74926.74955},
	Journal = {ACM SIGARCH Computer Architecture News},
	Keywords = {dataflow, pl},
	Number = {3},
	Pages = {262--272},
	Publisher = {ACM},
	Title = {Can dataflow subsume {V}on {N}eumann computing?},
	Volume = {17},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNuaWtoaWw4OXN1YnN1bWUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f3x1O5IwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmjAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpuaWtoaWw4OXN1YnN1bWUucGRmAA4AKAATAG4AaQBrAGgAaQBsADgAOQBzAHUAYgBzAHUAbQBlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L25pa2hpbDg5c3Vic3VtZS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L25pa2hpbDg5c3Vic3VtZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/74926.74955}}

@inproceedings{claessen00quickcheck,
	Abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
	Address = {New York, NY, USA},
	Author = {Koen Claessen and John Hughes},
	Booktitle = {ICFP '00: Proceedings of the fifth ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2009-05-14 11:20:48 -0700},
	Date-Modified = {2009-05-18 14:08:12 -0700},
	Doi = {10.1145/351240.351266},
	Keywords = {functional, haskell, pl},
	Pages = {268--279},
	Publisher = {ACM},
	Title = {QuickCheck: a lightweight tool for random testing of Haskell programs},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdgAAAAAAdgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRhjbGFlc3NlbjAwcXVpY2tjaGVjay5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eWx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBTTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjbGFlc3NlbjAwcXVpY2tjaGVjay5wZGYAAA4AMgAYAGMAbABhAGUAcwBzAGUAbgAwADAAcQB1AGkAYwBrAGMAaABlAGMAawAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9jbGFlc3NlbjAwcXVpY2tjaGVjay5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QIExpYnJhcnkvY2xhZXNzZW4wMHF1aWNrY2hlY2sucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnwCfgKDAowClwKbAqkCsAK5AtwC4QLkAvEC9gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMI},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/351240.351266}}

@article{hulette08wool,
	Abstract = {Workflows offer scientists a simple but flexible programming model at a level of abstraction closer to the domain-specific activities that they seek to perform.  However, languages for describing workflows tend to be highly complex, or specialized towards a particular domain, or both.  WOOL is an abstract workflow language with human-readable syntax, intuitive semantics, and a powerful abstract type system.  WOOL workflows can be targeted to almost any kind of runtime system supporting data-flow computation.  This paper describes the design of the WOOL language and the implementation of its compiler, along with a simple example runtime.  We demonstrate its use in an image-processing workflow.},
	Address = {Los Alamitos, CA, USA},
	Author = {Geoffrey C. Hulette and Matthew J. Sottile and Allen D. Malony},
	Date-Added = {2009-05-14 11:11:12 -0700},
	Date-Modified = {2009-05-14 11:20:47 -0700},
	Doi = {10.1109/eScience.2008.43},
	Journal = {IEEE International Conference on eScience},
	Keywords = {concurrent, dataflow, workflow},
	Pages = {71--78},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {WOOL: A Workflow Programming Language},
	Volume = {0},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFodWxldHRlMDh3b29sLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fLx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpodWxldHRlMDh3b29sLnBkZgAOACQAEQBoAHUAbABlAHQAdABlADAAOAB3AG8AbwBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2h1bGV0dGUwOHdvb2wucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9odWxldHRlMDh3b29sLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/eScience.2008.43}}

@article{johnston04dataflow,
	Abstract = {Many developments have taken place within dataflow programming languages in the past decade. In particular, there has been a great deal of activity and advancement in the field of dataflow visual programming languages. The motivation for this article is to review the content of these recent developments and how they came about. It is supported by an initial review of dataflow programming in the 1970s and 1980s that led to current topics of research. It then discusses how dataflow programming evolved toward a hybrid von Neumann dataflow formulation, and adopted a more coarse-grained approach. Recent trends toward dataflow visual programming languages are then discussed with reference to key graphical dataflow languages and their development environments. Finally, the article details four key open topics in dataflow programming languages.},
	Annote = {Excellent overview of data flow languages and research.  Some conclusions: 
* Research has moved away from fine-grained data flow to medium-grained.  This is related to the idea that data flow languages can be treated as coordination languages, rather than general purpose programming languages. 
* Visual languages have been the focus of recent research 
* Open problems include representing iteration in a way that is concise but that also fits with "pure" data flow theory, data structures, and non-determinism.},
	Author = {Wesley M. Johnston and J. R. Paul Hanna and Richard J. Millar},
	Citeulike-Article-Id = {86951},
	Date-Added = {2009-05-14 09:59:50 -0700},
	Date-Modified = {2009-05-14 10:03:59 -0700},
	Doi = {10.1145/1013208.1013209},
	Issn = {0360-0300},
	Journal = {ACM Computing Surveys (CSUR)},
	Keywords = {dataflow, pl},
	Month = {March},
	Number = {1},
	Pages = {1--34},
	Posted-At = {2009-03-09 17:19:22},
	Priority = {2},
	Publisher = {ACM Press},
	Read = {Yes},
	Title = {Advances in dataflow programming languages},
	Url = {http://dx.doi.org/10.1145/1013208.1013209},
	Volume = {36},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZqb2huc3RvbjA0ZGF0YWZsb3cucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fPx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpqb2huc3RvbjA0ZGF0YWZsb3cucGRmAAAOAC4AFgBqAG8AaABuAHMAdABvAG4AMAA0AGQAYQB0AGEAZgBsAG8AdwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9qb2huc3RvbjA0ZGF0YWZsb3cucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L2pvaG5zdG9uMDRkYXRhZmxvdy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1013208.1013209}}

@inproceedings{kennedy07hpf,
	Abstract = {High Performance Fortran (HPF) is a high-level data-parallel programming system based on Fortran. The effort to standardize HPF began in 1991, at the Supercomputing Conference in Albuquerque, where a group of industry leaders asked Ken Kennedy to lead an effort to produce a common programming language for the emerging class of distributed-memory parallel computers. The proposed language would focus on data-parallel operations in a single thread of control, a strategy which was pioneered by some earlier commercial and research systems, including Thinking Machines' CM Fortran, Fortran D, and Vienna Fortran.

The standardization group, called the High Performance Fortran Forum (HPFF), took a little over a year to produce a language definition that was published in January 1993 as a Rice technical report [50] and, later that same year, as an article in Scientific Programming [49].

The HPF project had created a great deal of excitement while it was underway and the release was initially well received in the community. However, over a period of several years, enthusiasm for the language waned in the United States, although it has continued to be used in Japan.

This paper traces the origins of HPF through the programming languages on which it was based, leading up to the standardization effort. It reviews the motivation underlying technical decisions that led to the set of features incorporated into the original language and its two follow-ons: HPF 2 (extensions defined by a new series of HPFF meetings) and HPF/JA (the dialect that was used by Japanese manufacturers and runs on the Earth Simulator).

A unique feature of this paper is its discussion and analysis of the technical and sociological mistakes made by both the language designers and the user community:, mistakes that led to the premature abandonment of the very promising approach employed in HPF. It concludes with some lessons for the future and an exploration of the influence of ideas from HPF on new languages emerging from the High Productivity Computing Systems program sponsored by DARPA.},
	Address = {New York, NY, USA},
	Author = {Ken Kennedy and Charles Koelbel and Hans Zima},
	Booktitle = {{HOPL III}: Proceedings of the third ACM SIGPLAN conference on History of programming languages},
	Date-Added = {2009-01-28 14:18:10 -0800},
	Date-Modified = {2009-05-14 11:58:53 -0700},
	Doi = {10.1145/1238844.1238851},
	Isbn = {978-1-59593-766-X},
	Keywords = {pl},
	Location = {San Diego, California},
	Pages = {7-1--7-22},
	Publisher = {ACM},
	Title = {The rise and fall of {H}igh {P}erformance {F}ortran: an historical object lesson},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBrZW5uZWR5MDdocGYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fXx1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTprZW5uZWR5MDdocGYucGRmAAAOACIAEABrAGUAbgBuAGUAZAB5ADAANwBoAHAAZgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9rZW5uZWR5MDdocGYucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2tlbm5lZHkwN2hwZi5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1238844.1238851}}

@article{trinder98strategy,
	Author = {Philip W. Trinder and Kevin Hammond and Hans-Wolfgang Loidl and Simon P. Jones},
	Date-Added = {2008-11-30 10:11:41 -0800},
	Date-Modified = {2009-05-14 12:03:34 -0700},
	Journal = {Journal of Functional Programming},
	Keywords = {haskell,parallel},
	Month = {January},
	Number = {1},
	Pages = {23--60},
	Title = {{A}lgorithm + {S}trategy = {P}arallelism},
	Volume = {8},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRV0cmluZGVyOThzdHJhdGVneS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gcx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp0cmluZGVyOThzdHJhdGVneS5wZGYADgAsABUAdAByAGkAbgBkAGUAcgA5ADgAcwB0AHIAYQB0AGUAZwB5AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3RyaW5kZXI5OHN0cmF0ZWd5LnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvdHJpbmRlcjk4c3RyYXRlZ3kucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5},
	Bdsk-Url-1 = {http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/strategies.html}}

@inproceedings{wadler90monads,
	Abstract = {Category theorists invented monads in the 1960's to concisely express certain aspects of universal algebra. Functional programmers invented list comprehensions in the 1970's to concisely express certain programs involving lists. This paper shows how list comprehensions may be generalised to an arbitrary monad, and how the resulting programming feature can concisely express in a pure functional language some programs that manipulate state, handle exceptions, parse text, or invoke continuations. A new solution to the old problem of destructive array update is also presented. No knowledge of category theory is assumed.},
	Address = {New York, NY, USA},
	Author = {Philip Wadler},
	Booktitle = {LFP '90: Proceedings of the 1990 ACM conference on LISP and functional programming},
	Date-Added = {2008-11-26 12:01:01 -0500},
	Date-Modified = {2008-11-26 12:02:53 -0500},
	Keywords = {haskell,monad},
	Location = {Nice, France},
	Pages = {61--78},
	Publisher = {ACM},
	Title = {Comprehending monads},
	Year = {1990},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJ3YWRsZXI5MG1vbmFkcy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ghx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp3YWRsZXI5MG1vbmFkcy5wZGYAAA4AJgASAHcAYQBkAGwAZQByADkAMABtAG8AbgBhAGQAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS93YWRsZXI5MG1vbmFkcy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvd2FkbGVyOTBtb25hZHMucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/91556.91592}}

@unpublished{lee08gpu,
	Author = {Sean Lee},
	Date-Added = {2008-11-22 13:41:09 -0800},
	Date-Modified = {2008-11-22 13:43:40 -0800},
	Keywords = {haskell,gpgpu},
	Month = {September},
	Note = {Slides},
	Read = {Yes},
	Title = {{GpuGen: Bringing the power of GPUs into the Haskell world}},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAagAAAAAAagAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQxsZWUwOGdwdS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fgx1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBHTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsZWUwOGdwdS5wZGYAAA4AGgAMAGwAZQBlADAAOABnAHAAdQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAOlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9sZWUwOGdwdS5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QFExpYnJhcnkvbGVlMDhncHUucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAkwCTgJTAlwCZwJrAnkCgAKJAqACpQKoArUCugAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALM}}

@techreport{zhou08gpukdtree,
	Abstract = {We present an algorithm for constructing kd-trees on GPUs. This algorithm achieves real-time performance by exploiting the GPU's streaming architecture at all stages of kd-tree construction. Unlike previous parallel kd-tree algorithms, our method builds tree nodes completely in BFS (breadth-first search) order. We also develop a special strategy for large nodes at upper tree levels so as to further exploit the fine-grained parallelism of GPUs. For these nodes, we parallelize the computation over all geometric primitives instead of nodes at each level. Finally, in order to maintain kd-tree quality, we introduce novel schemes for fast evaluation of node split costs. As far as we know, ours is the first real-time kd-tree algorithm on the GPU. The kd-trees built by our algorithm are of comparable quality as those constructed by off-line CPU algorithms. In terms of speed, our algorithm is significantly faster than well-optimized single-core CPU algorithms and competitive with multi-core CPU algorithms. Our algorithm provides a general way for handling dynamic scenes on the GPU. We demonstrate the potential of our algorithm in applications involving dynamic scenes, including GPU ray tracing, interactive photon mapping, and point cloud modeling.},
	Author = {Kun Zhou and Qiming Hou and Rui Wang and Baining Guo},
	Date-Added = {2008-11-10 17:26:08 -0800},
	Date-Modified = {2008-11-10 17:27:54 -0800},
	Institution = {Microsoft Research},
	Keywords = {gpgpu, concurrent, kdtree},
	Month = {April},
	Title = {Real-Time KD-Tree Construction on Graphics Hardware},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRN6aG91MDhncHVrZHRyZWUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gpx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp6aG91MDhncHVrZHRyZWUucGRmAA4AKAATAHoAaABvAHUAMAA4AGcAcAB1AGsAZAB0AHIAZQBlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3pob3UwOGdwdWtkdHJlZS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L3pob3UwOGdwdWtkdHJlZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://research.microsoft.com/research/pubs/view.aspx?type=Technical%20Report&id=1468}}

@article{milner93picalc,
	Abstract = {The pi-calculus is a model of concurrent computation based upon the notion of naming. It is first presented in its simplest and original form, with the help of several illustrative applications. Then it is generalized from monadic to polyadic form. Semantics is done in terms of both a reduction system and a version of labelled transitions called commitment; the known algebraic axiomatization of strong bisimilarity is given in the new setting, and so also is a characterization in modal logic. Some theorems about the replication operator are proved.

Justification for the polyadic form is provided by the concept of sort, sorting and sort discipline which it supports. Several illustrations of different sortings are given. One example is the presentation of data structures as processes which respect a particular sorting; another is the sorting for a known translation of the lambda-calculus in to pi-calculus. For this translation, the equational validity of beta-conversion is proved with the help of replication theorems. The paper ends with an extension of the pi-calculus to w-order processes, and a brief account of the demonstration by Davide Sangiorgi that higher-order processes may be faithfully encoded at first-order. This extends and strengthens the original result of this kind given by Bent Thomsen for second-order processes.},
	Author = {Robin Milner},
	Date-Added = {2008-10-30 11:51:36 -0700},
	Date-Modified = {2008-10-30 11:55:34 -0700},
	Journal = {Logic and Algebra of Specification},
	Keywords = {concurrent},
	Title = {The Polyadic pi-Calculus: A Tutorial},
	Year = {1993},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJtaWxuZXI5M3BpY2FsYy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fxx1O5IgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmiAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptaWxuZXI5M3BpY2FsYy5wZGYAAA4AJgASAG0AaQBsAG4AZQByADkAMwBwAGkAYwBhAGwAYwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9taWxuZXI5M3BpY2FsYy5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvbWlsbmVyOTNwaWNhbGMucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://www.lfcs.inf.ed.ac.uk/reports/91/ECS-LFCS-91-180/}}

@article{jones01awkward,
	Abstract = {Functional programming may be beautiful, but to write real applications we must grapple with awkward real-world issues: input/output, robustness, concurrency, and interfacing to programs written in other languages. These lecture notes give an overview of the techniques that have been developed by the Haskell community to address these problems. I introduce various proposed extensions to Haskell along the way, and I offer an operational semantics that explains what these extensions mean. This tutorial was given at the Marktoberdorf Summer School 2000. It will appear in the book ``Engineering theories of software construction'', to be published in the NATO ASI series during 2001. This version has a few errors corrected compared with the published version.},
	Author = {Simon P. Jones},
	Date-Added = {2008-11-04 09:08:06 -0800},
	Date-Modified = {2008-11-04 09:11:45 -0800},
	Journal = {Engineering theories of software construction},
	Keywords = {monad, haskell, concurrent},
	Pages = {47--96},
	Title = {Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJqb25lczAxYXdrd2FyZC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fQx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpqb25lczAxYXdrd2FyZC5wZGYAAA4AJgASAGoAbwBuAGUAcwAwADEAYQB3AGsAdwBhAHIAZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9qb25lczAxYXdrd2FyZC5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvam9uZXMwMWF3a3dhcmQucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://research.microsoft.com/~simonpj/papers/marktoberdorf/}}

@article{jones08multicores,
	Abstract = {If you want to program a parallel computer, a purely functional language like Haskell is a promising starting point. Since the language is pure, it is by-default safe for parallel evaluation, whereas imperative languages are by-default unsafe. But that doesn't make it easy! Indeed it has proved quite difficult to get robust, scalable performance increases through parallel functional programming, especially as the number of processors increases. A particularly promising and well-studied approach to employing large numbers of processors is data parallelism. Blelloch's pioneering work on NESL showed that it was possible to combine a rather flexible programming model (nested data parallelism) with a fast, scalable execution model (flat data parallelism). In this paper we describe Data Parallel Haskell, which embodies nested data parallelism in a modern, general-purpose language, implemented in a state-of-the-art compiler, GHC. We focus particularly on the vectorisation transformation, which transforms nested to flat data parallelism.},
	Author = {Simon P. Jones and Roman Leshchinskiy and Gabriele Keller and Manuel M. T. Chakravarty},
	Date-Added = {2008-10-30 11:40:19 -0700},
	Date-Modified = {2009-05-14 12:00:45 -0700},
	Journal = {IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS 2008)},
	Keywords = {haskell, multicore},
	Title = {Harnessing the Multicores: Nested Data Parallelism in Haskell},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVqb25lczA4bXVsdGljb3Jlcy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fRx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpqb25lczA4bXVsdGljb3Jlcy5wZGYADgAsABUAagBvAG4AZQBzADAAOABtAHUAbAB0AGkAYwBvAHIAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2pvbmVzMDhtdWx0aWNvcmVzLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvam9uZXMwOG11bHRpY29yZXMucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5},
	Bdsk-Url-1 = {http://www.cse.unsw.edu.au/~chak/papers/PLKC08.html}}

@manual{nikhil91id,
	Abstract = {Id is a general-purpose parallel programming language designed by members of the Computation Structures Group in MIT's Laboratory for Computer Science, and is used for programming dataflow and other parallel machines. The major subset of Id (syntactically distinguishable) is a pure functional language with non-strict semantics. Features include: higher-order functions, a Milner-style statically type-checked polymorphic type system with overloading, user defined types and patternmatching notation, lists and list comprehensions, arrays and array comprehensions, and facilities for delayed evaluation. The non-functional aspects of Id include I-structures and M-structures (for both arrays and user-defined types), and input/output. With respect to the functional subset, programs with I-structures remain deterministic but may not be referentially transparent, and programs with M-structures and i/o may even be non-deterministic. Id programs are implicitly parallel to a very fine grain. Some programs with M-structures and i/o may need explicity sequencing, for which facilities are provided.},
	Address = {Cambridge, MA},
	Annote = {Id is functional, but adds two classes of non-functional contructs.   First, I-arrays are interesting because they are constructed as empty arrays that then allow single-assignment into cells.  Multiple assignment is a critical error.  Reads can be interleaved, and delayed until the write occurs.  Because there is only one write, there is no race.},
	Author = {Rishiyur S. Nikhil},
	Date-Added = {2008-10-08 20:57:39 -0700},
	Date-Modified = {2008-10-08 21:30:30 -0700},
	Doi = {10.1.1.18.4920},
	Keywords = {pl,concurrent,dataflow},
	Month = {July},
	Organization = {MIT Computational Structures Group},
	Read = {Yes},
	Title = {ID Language Reference Manual (Version 90.1)},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ5uaWtoaWw5MWlkLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f4x1O5IwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmjAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpuaWtoaWw5MWlkLnBkZgAADgAeAA4AbgBpAGsAaABpAGwAOQAxAGkAZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9uaWtoaWw5MWlkLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS9uaWtoaWw5MWlkLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.4920}}

@inproceedings{ford04peg,
	Abstract = {For decades we have been using Chomsky's generative system of grammars, particularly context-free grammars (CFGs) and regular expressions (REs), to express the syntax of programming languages and protocols. The power of generative grammars to express ambiguity is crucial to their original purpose of modelling natural languages, but this very power makes it unnecessarily difficult both to express and to parse machine-oriented languages using CFGs. Parsing Expression Grammars (PEGs) provide an alternative, recognition-based formal foundation for describing machine-oriented syntax, which solves the ambiguity problem by not introducing ambiguity in the first place. Where CFGs express nondeterministic choice between alternatives, PEGs instead use prioritized choice. PEGs address frequently felt expressiveness limitations of CFGs and REs, simplifying syntax definitions and making it unnecessary to separate their lexical and hierarchical components. A linear-time parser can be built for any PEG, avoiding both the complexity and fickleness of LR parsers and the inefficiency of generalized CFG parsing. While PEGs provide a rich set of operators for constructing grammars, they are reducible to two minimal recognition schemas developed around 1970, TS/TDPL and gTS/GTDPL, which are here proven equivalent in effective recognition power.},
	Address = {New York, NY, USA},
	Author = {Bryan Ford},
	Booktitle = {POPL '04: Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-10-06 07:58:49 -0700},
	Date-Modified = {2008-10-30 11:44:14 -0700},
	Doi = {10.1145/964001.964011},
	Isbn = {1-58113-729-X},
	Keywords = {grammar},
	Location = {Venice, Italy},
	Pages = {111--122},
	Publisher = {ACM},
	Title = {Parsing expression grammars: a recognition-based syntactic foundation},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAawAAAAAAawAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ1mb3JkMDRwZWcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eux1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBITWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmb3JkMDRwZWcucGRmAA4AHAANAGYAbwByAGQAMAA0AHAAZQBnAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA7VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2ZvcmQwNHBlZy5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBVMaWJyYXJ5L2ZvcmQwNHBlZy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACUAJSAlcCYAJrAm8CfQKEAo0CpQKqAq0CugK/AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtE=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/964001.964011}}

@article{aalst2003workflow,
	Abstract = {Differences in features supported by the various contemporary commercial workflow management systems point to different insights of suitability and different levels of expressive power. The challenge, which we undertake in this paper, is to systematically address workflow requirements, from basic to complex. Many of the more complex requirements identified, recur quite frequently in the analysis phases of workflow projects, however their implementation is uncertain in current products. Requirements for workflow languages are indicated through workflow patterns. In this context, patterns address business requirements in an imperative workflow style expression, but are removed from specific workflow languages. The paper describes a number of workflow patterns addressing what we believe identify comprehensive workflow functionality. These patterns provide the basis for an in-depth comparison of a number of commercially availablework flow management systems. As such, this paper can be seen as the academic response to evaluations made by prestigious consulting companies. Typically, these evaluations hardly consider the workflow modeling language and routing capabilities, and focus more on the purely technical and commercial aspects.},
	Author = {W. M. P. van der Aalst and A. H. M. ter Hofstede and B. Kiepuszewski and A. P. Barros},
	Date-Added = {2008-10-05 11:19:14 -0700},
	Date-Modified = {2009-05-31 15:42:35 -0700},
	Journal = {Distributed and Parallel Databases},
	Keywords = {workflow},
	Number = {1},
	Pages = {5--51},
	Title = {Workflow Patterns},
	Volume = {14},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVhYWxzdDIwMDN3b3JrZmxvdy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d2x1O5FQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmVAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphYWxzdDIwMDN3b3JrZmxvdy5wZGYADgAsABUAYQBhAGwAcwB0ADIAMAAwADMAdwBvAHIAawBmAGwAbwB3AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2FhbHN0MjAwM3dvcmtmbG93LnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvYWFsc3QyMDAzd29ya2Zsb3cucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5},
	Bdsk-Url-1 = {http://dx.doi.org/10.1023/A:1022883727209}}

@article{ahuja86linda,
	Abstract = {Linda consists of a few simple primitives that support an "uncoupled" style of parallel programming. Implementations exist on a broad spectrum of parallel machines.},
	Address = {Los Alamitos, CA, USA},
	Author = {Sudhir Ahuja and Nicholas Carriero and David Gelernter},
	Date-Added = {2008-09-15 21:04:39 -0700},
	Date-Modified = {2008-10-05 11:23:37 -0700},
	Doi = {10.1109/MC.1986.1663305},
	Issn = {0018-9162},
	Journal = {Computer},
	Keywords = {concurrent},
	Number = {8},
	Pages = {26--34},
	Publisher = {IEEE Computer Society Press},
	Title = {Linda and Friends},
	Volume = {19},
	Year = {1986},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBhaHVqYTg2bGluZGEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d8x1O5FgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmWAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphaHVqYTg2bGluZGEucGRmAAAOACIAEABhAGgAdQBqAGEAOAA2AGwAaQBuAGQAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9haHVqYTg2bGluZGEucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2FodWphODZsaW5kYS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/MC.1986.1663305}}

@article{parr95antlr,
	Abstract = {Despite the parsing power of LR/LALR algorithms, e.g. YACC, programmers often choose to write recursive-descent parsers by hand to obtain increased flexibility, better error handling, and ease of debugging. We introduce ANTLR, a public-domain parser generator that combines the flexibility of hand-coded parsing with the convenience of a parser generator, which is a component of PCCTS. ANTLR has many features that make it easier to use than other language tools. Most important, ANTLR provides predicates which let the programmer systematically direct the parse via arbitrary expressions using semantic and syntactic context; in practice, the use of predicates eliminates the need to hand-tweak the ANTLR output, even for difficult parsing problems. ANTLR also integrates the description of lexical and syntactic analysis, accepts LL(k) grammars for k > 1 with extended BNF notation, and can automatically generate abstract syntax trees.  ANTLR is widely used, with over 1000 registered industrial and academic users in 37 countries. It has been ported to many popular systems such as the PC, Macintosh, and a variety of UNIX platforms; a commercial C++ front-end has been developed as a result of one of our industrial collaborations.
},
	Address = {New York, NY, USA},
	Author = {T. J. Parr and R. W. Quong},
	Date-Added = {2008-09-12 09:08:56 -0700},
	Date-Modified = {2009-05-14 12:06:18 -0700},
	Doi = {10.1002/spe.4380250705},
	Issn = {0038-0644},
	Journal = {Software: Practice and Experience},
	Keywords = {pl},
	Number = {7},
	Pages = {789--810},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {{ANTLR}: a predicated-{LL(k)} parser generator},
	Volume = {25},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9wYXJyOTVhbnRsci5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f9x1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpwYXJyOTVhbnRsci5wZGYADgAgAA8AcABhAHIAcgA5ADUAYQBuAHQAbAByAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3BhcnI5NWFudGxyLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvcGFycjk1YW50bHIucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/spe.4380250705}}

@article{conery05workflow,
	Abstract = {We describe a data-centric software architecture for bioinformatics workflows and a rule-based workflow enactment system that uses declarative specifications of data dependences between steps to automatically order the execution of those steps. A data-centric view allows researchers to develop abstract descriptions of workflow products and provides mechanisms for describing workflow steps as objects. The rule-based approach supports an iterative design methodology for creating new workflows, where steps can be developed in small, incremental updates, and the object orientation allows workflow steps developed for one project to be reused in other projects.},
	Author = {John Conery and Julian Catchen and Michael Lynch},
	Date-Added = {2008-10-01 12:29:49 -0700},
	Date-Modified = {2008-10-01 12:31:01 -0700},
	Doi = {10.1007/s00778-005-0153-9},
	Journal = {The VLDB Journal},
	Keywords = {workflow,bio},
	Number = {3},
	Pages = {318--329},
	Title = {Rule-based workflow management for bioinformatics},
	Volume = {14},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRjb25lcnkwNXdvcmtmbG93LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eZx1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjb25lcnkwNXdvcmtmbG93LnBkZgAADgAqABQAYwBvAG4AZQByAHkAMAA1AHcAbwByAGsAZgBsAG8AdwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9jb25lcnkwNXdvcmtmbG93LnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9jb25lcnkwNXdvcmtmbG93LnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/s00778-005-0153-9}}

@book{scott06pragmatics,
	Address = {San Francisco, CA, USA},
	Author = {Michael L. Scott},
	Date-Added = {2008-09-10 17:46:58 -0700},
	Date-Modified = {2008-09-10 17:51:27 -0700},
	Edition = {second},
	Isbn = {1-55860-442-1},
	Keywords = {pl},
	Publisher = {Morgan Kaufmann Publishers Inc.},
	Title = {Programming Language Pragmatics},
	Year = {2006},
	Bdsk-Url-1 = {http://www.cs.rochester.edu/~scott/pragmatics/}}

@inproceedings{pereira08puzzle,
	Abstract = {We have shown that register allocation can be viewed as solving a collection of puzzles. We model the register file as a puzzle board and the program variables as puzzle pieces; pre-coloring and register aliasing fit in naturally. For architectures such as x86, PowerPC, and StrongARM, we can solve the puzzles in polynomial time, and we have augmented the puzzle solver with a simple heuristic for spilling. For SPEC CPU2000, our implementation is as fast as the extended version of linear scan used by LLVM, which is the JIT compiler in the openGL stack of Mac OS 10.5. Our implementation produces Pentium code that is of similar quality to the code produced by the slower, state-of-the-art iterated register coalescing algorithm of George and Appel augmented with extensions by Smith, Ramsey, and Holloway.},
	Author = {Fernando Magno Quintao Pereira and Jens Palsberg},
	Booktitle = {{ACM SIGPLAN 2008 Conference on Programming Language Design and Implementation (PLDI'08)}},
	Date-Added = {2008-09-03 17:16:35 -0700},
	Date-Modified = {2008-09-03 17:17:48 -0700},
	Keywords = {pl,llvm},
	Title = {Register Allocation by Puzzle Solving},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNwZXJlaXJhMDhwdXp6bGUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f+x1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpwZXJlaXJhMDhwdXp6bGUucGRmAA4AKAATAHAAZQByAGUAaQByAGEAMAA4AHAAdQB6AHoAbABlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3BlcmVpcmEwOHB1enpsZS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L3BlcmVpcmEwOHB1enpsZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://llvm.org/pubs/2008-06-PLDI-PuzzleSolving.html}}

@inproceedings{dhurjati06bounds,
	Abstract = {The problem of enforcing correct usage of array and pointer references in C and C++ programs remains unsolved. The approach proposed by Jones and Kelly (extended by Ruwase and Lam) is the only one we know of that does not require significant manual changes to programs, but it has extremely high overheads of 5x-6x and 11x--12x in the two versions. In this paper, we describe a collection of techniques that dramatically reduce the overhead of this approach, by exploiting a fine-grain partitioning of memory called Automatic Pool Allocation. Together, these techniques bring the average overhead checks down to only 12\% for a set of benchmarks (but 69\% for one case). We show that the memory partitioning is key to bringing down this overhead. We also show that our technique successfully detects all buffer overrun violations in a test suite modeling reported violations in some important real-world programs.},
	Address = {Shanghai, China},
	Author = {Dinakar Dhurjati and Vikram Adve},
	Booktitle = {Proceedings of the 2006 International Conference on Software Engineering (ICSE'06)},
	Date-Added = {2008-09-03 17:14:25 -0700},
	Date-Modified = {2008-09-03 17:16:21 -0700},
	Keywords = {pl,llvm},
	Month = {May},
	Title = {Backwards-Compatible Array Bounds Checking for {C} with Very Low Overhead},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRkaHVyamF0aTA2Ym91bmRzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ejx1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpkaHVyamF0aTA2Ym91bmRzLnBkZgAADgAqABQAZABoAHUAcgBqAGEAdABpADAANgBiAG8AdQBuAGQAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9kaHVyamF0aTA2Ym91bmRzLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9kaHVyamF0aTA2Ym91bmRzLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://llvm.org/pubs/2006-05-24-SAFECode-BoundsCheck.html}}

@inproceedings{lattner04llvm,
	Abstract = {This paper describes LLVM (Low Level Virtual Machine), a compiler framework designed to support transparent, lifelong program analysis and transformation for arbitrary programs, by providing high-level information to compiler transformations at compile-time, link-time, run-time, and in idle time between runs. LLVM defines a common, low-level code representation in Static Single Assignment (SSA) form, with several novel features: a simple, language-independent type-system that exposes the primitives commonly used to implement high-level language features; an instruction for typed address arithmetic; and a simple mechanism that can be used to implement the exception handling features of high-level languages (and setjmp/longjmp in C) uniformly and efficiently. The LLVM compiler framework and code representation together provide a combination of key capabilities that are important for practical, lifelong analysis and transformation of programs. To our knowledge, no existing compilation approach provides all these capabilities. We describe the design of the LLVM representation and compiler framework, and evaluate the design in three ways: (a) the size and effectiveness of the representation, including the type information it provides; (b) compiler performance for several interprocedural problems; and (c) illustrative examples of the benefits LLVM provides for several challenging compiler problems.},
	Address = {Palo Alto, California},
	Author = {Chris Lattner and Vikram Adve},
	Booktitle = {{Proceedings of the 2004 International Symposium on Code Generation and Optimization (CGO'04)}},
	Date-Added = {2008-09-03 17:11:33 -0700},
	Date-Modified = {2008-09-03 17:12:48 -0700},
	Keywords = {pl,llvm},
	Month = {Mar},
	Title = {{LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation}},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFsYXR0bmVyMDRsbHZtLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fcx1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsYXR0bmVyMDRsbHZtLnBkZgAOACQAEQBsAGEAdAB0AG4AZQByADAANABsAGwAdgBtAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2xhdHRuZXIwNGxsdm0ucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9sYXR0bmVyMDRsbHZtLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://llvm.org/pubs/2004-01-30-CGO-LLVM.html}}

@techreport{biron04xsd,
	Abstract = {XML Schema: Datatypes is part 2 of the specification of the XML Schema language. It defines facilities for defining datatypes to be used in XML Schemas as well as other XML specifications. The datatype language, which is itself represented in XML 1.0, provides a superset of the capabilities found in XML 1.0 document type definitions (DTDs) for specifying datatypes on elements and attributes.},
	Author = {Paul V. Biron and Ashok Malhotra},
	Date-Added = {2008-07-31 08:14:57 -0700},
	Date-Modified = {2009-05-18 14:08:40 -0700},
	Institution = {World Wide Web Consortium},
	Keywords = {types},
	Month = {October},
	Title = {{XML} Schema Part 2: Datatypes Second Edition},
	Type = {{W3C} Recommendation},
	Url = {http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/},
	Year = {2004},
	Bdsk-Url-1 = {http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/}}

@misc{deelman06swf,
	Abstract = {Significant scientific advances are increasingly achieved through complex sets of computations and data analyses. These computations, often represented as workflows of executable jobs and associated data flows, may comprise thousands of steps. Each step may integrate diverse models and data sources, which may be developed by different groups. The applications and data may be also distributed in the execution environment. The assembly and management of such workflows present many challenges, and increasingly ambitious scientific inquiry is continuously pushing the limits of current technology.

Today's workflow systems are able to manage quite complex computations that include thousands of components, use dozens of data repositories, and harness resources at dozens of sites. However, these applications are structurally simple compared with new emerging requirements from scientists to handle streaming data, accommodate interactive steering, support event-driven analysis, and enable their creation through collaborative design processes involving many scientists across disciplines.

To examine the nature of these challenges and to consider what steps should be taken to address them, a Workshop on the Challenges of Scientific Workflows was held at the National Science Foundation on May 1-2, 2006. The meeting brought together domain scientists, computer scientists, and social scientists to discuss requirements of future scientific applications and the challenges that they present to current workflow technologies.},
	Author = {Ewa Deelman and Yolanda Gil},
	Date-Added = {2008-07-30 16:51:20 -0700},
	Date-Modified = {2008-07-30 16:53:58 -0700},
	Howpublished = {http://vtcpc.isi.edu/wiki/images/b/bf/NSFWorkflow-Final.pdf},
	Keywords = {workflow},
	Month = {May},
	Title = {Final Report of {NSF} Workshop on Challenges of Scientific Workflows},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBkZWVsbWFuMDZzd2YucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1egx1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpkZWVsbWFuMDZzd2YucGRmAAAOACIAEABkAGUAZQBsAG0AYQBuADAANgBzAHcAZgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9kZWVsbWFuMDZzd2YucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2RlZWxtYW4wNnN3Zi5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://vtcpc.isi.edu/wiki/index.php/Main_Page}}

@article{foster02grid,
	Abstract = {Increasingly, computing addresses collaboration, data sharing, and interaction modes that involve distributed resources, resulting in an increased focus on the interconnection of systems both within and across enterprises. These evolutionary pressures have led to the development of Grid technologies.The authors' work focuses on the nature of the services that respond to protocol messages. Grid provides an extensible set of services that can be aggregated in various ways to meet the needs of virtual organizations, which themselves can be defined in part by the services they operate and share.},
	Address = {Los Alamitos, CA, USA},
	Annote = {Includes a sidebar on Globus/OGSA.},
	Author = {Ian Foster and Carl Kesselman and Jeffrey M. Nick and Steven Tuecke},
	Date-Added = {2008-07-30 13:25:22 -0700},
	Date-Modified = {2008-07-30 13:28:52 -0700},
	Doi = {10.1109/MC.2002.1009167},
	Journal = {Computer},
	Keywords = {grid},
	Month = {June},
	Number = {6},
	Pages = {37--46},
	Read = {Yes},
	Title = {Grid Services for Distributed System Integration},
	Volume = {35},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBmb3N0ZXIwMmdyaWQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1evx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmb3N0ZXIwMmdyaWQucGRmAAAOACIAEABmAG8AcwB0AGUAcgAwADIAZwByAGkAZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9mb3N0ZXIwMmdyaWQucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2Zvc3RlcjAyZ3JpZC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/MC.2002.1009167}}

@inproceedings{majithia04triana,
	Abstract = {Service composition refers to the aggregation of services to build complex applications to achieve client requirements. It is an important challenge to make it possible for users to construct complex workflows transparently and thereby insulating them from the complexity of interacting with numerous heterogeneous services. We present an extension to the Triana PSE to facilitate graphical Web service discovery, composition and invocation. Our framework has several novel features which distinguish it from other work in this area. First, users can graphically create complex service compositions. Second, Triana allows the user to share the composite service as a BPEL4WS graph or expose it as a service in a one-click manner. Third, Triana allows the user to easily carry out "what-if" analysis by altering existing workflows. Fourth, Triana allows the user to record provenance data for a workflow. Finally, our framework allows the user to execute the composed graph on a Grid or P2P network. Triana is a part of the GridLab and GridOneD projects and is used in the GEO 600 project.},
	Address = {Los Alamitos, CA, USA},
	Author = {Shalil Majithia and Matthew Shields and Ian Taylor and Ian Wang},
	Booktitle = {Proceedings of the IEEE International Conference on Web Services (ICWS'04)},
	Date-Added = {2008-07-29 18:56:03 -0700},
	Date-Modified = {2008-07-29 18:57:48 -0700},
	Doi = {10.1109/ICWS.2004.1314777},
	Keywords = {workflow},
	Pages = {514--522},
	Publisher = {IEEE Computer Society},
	Title = {Triana: A Graphical Web Service Composition and Execution Toolkit},
	Volume = {0},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRtYWppdGhpYTA0dHJpYW5hLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fsx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptYWppdGhpYTA0dHJpYW5hLnBkZgAADgAqABQAbQBhAGoAaQB0AGgAaQBhADAANAB0AHIAaQBhAG4AYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9tYWppdGhpYTA0dHJpYW5hLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9tYWppdGhpYTA0dHJpYW5hLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/ICWS.2004.1314777}}

@inproceedings{huang05workflow,
	Abstract = {This paper presents the SWFL workflow engine, a general workflow framework that meets the 
needs of business processes as well as scientific computing processes with fine multi-level 
parallelism supports. The workflow description language, SWFL, follows a graph-oriented model to 
specify workflow processes composed of services. The workflow engine provides an efficient 
enactment environment for SWFL flow model composed of services. It provides multi-level 
parallelism supports: a server-level parallelism support using flexible server-level schedule 
algorithms, a flow-level parallelism support by partitioning a workflow into sub-flows and running 
the sub-flows  in multiple job processing servers in parallel, and a message-passing parallelism 
support by using the MPFL, an extension language to SWFL and its associated tools. The 
architecture of the workflow engine and some other related implementation issues are also 
presented in the paper. },
	Address = {Nottingham UK},
	Author = {Qifeng Huang and Yan Huang},
	Booktitle = {Proceedings of the UK e-Science All Hands Meeting 2005},
	Date-Added = {2008-07-25 17:39:35 -0700},
	Date-Modified = {2008-07-25 17:47:54 -0700},
	Keywords = {workflow},
	Month = {September},
	Title = {Workflow Engine with Multi-Level Parallelism Supports},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNodWFuZzA1d29ya2Zsb3cucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fGx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpodWFuZzA1d29ya2Zsb3cucGRmAA4AKAATAGgAdQBhAG4AZwAwADUAdwBvAHIAawBmAGwAbwB3AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2h1YW5nMDV3b3JrZmxvdy5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2h1YW5nMDV3b3JrZmxvdy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://www.allhands.org.uk/2005/proceedings}}

@misc{krishnan02gsfl,
	Abstract = {The Open Grid Services Architecture (OGSA) is addressing the challenge of integrating services spread across dis- 
tributed, heterogeneous, dynamic virtual organizations, using the concepts and technologies from both the Grid and 
Web service communities. The Web service community has realized that Web services can reach their full potential 
only if there exists a mechanism to describe the various interactions between the services and dynamically compose 
new services out of existing ones. This situation is true in the case of Grid services as well. In this paper, we analyze 
existing technologies that address workflow for Web services, and try to leverage them for Grid services, which have 
different needs from standard Web services. We discuss these special needs and present the Grid Services Flow Lan- 
guage (GSFL), which addresses them for Grid services within the OGSA framework.},
	Author = {Sriram Krishnan and Patrick Wagstrom and Gregor von Laszewski},
	Date-Added = {2008-07-25 15:25:33 -0700},
	Date-Modified = {2008-07-25 16:51:13 -0700},
	Keywords = {workflow},
	Title = {{GSFL}: A Workflow Framework for Grid Services},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJrcmlzaG5hbjAyZ3NmbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fbx1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTprcmlzaG5hbjAyZ3NmbC5wZGYAAA4AJgASAGsAcgBpAHMAaABuAGEAbgAwADIAZwBzAGYAbAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9rcmlzaG5hbjAyZ3NmbC5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkva3Jpc2huYW4wMmdzZmwucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://citeseer.ist.psu.edu/article/krishnan02gsfl.html}}

@inproceedings{yu04tuple,
	Abstract = {Grid workflow can be defined as the composition of grid application services which execute on heterogeneous and distributed resources in a well-defined order to accomplish a specific goal. Uncertainties within grid environments pose new challenges for grid workflow management systems such as lacking central control and undedicated resource sharing. In this paper, we provide a workflow enactment engine together with an XML-based workflow language (xWFL). The workflow engine supports a just in-time scheduling system, thus allowing the resource allocation decision to be made at the time of task execution and hence adapt to changing grid environments. We also show that an event-driven scheduling architecture using tuple spaces provides a highly flexible approach for executing large scale complex grid workflows.},
	Address = {Washington, DC, USA},
	Annote = {Uses tuple spaces for workflow scheduling.  Also defines a workflow language called xWFL, a very simple XML-based language that has activities, ports, connections, and parameters.  Parameters can be filenames, ranges of numbers, constants, etc.  This seems like an important aspect of a scientific workflow language, since it allows for easily creating a parameter study.  },
	Author = {Jia Yu and Rajkumar Buyya},
	Booktitle = {GRID '04: Proceedings of the Fifth IEEE/ACM International Workshop on Grid Computing},
	Date-Added = {2008-07-25 15:14:47 -0700},
	Date-Modified = {2008-07-25 16:30:41 -0700},
	Doi = {10.1109/GRID.2004.3},
	Keywords = {workflow},
	Pages = {119--128},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {A Novel Architecture for Realizing Grid Workflow using Tuple Spaces},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAawAAAAAAawAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ15dTA0dHVwbGUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gnx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBITWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp5dTA0dHVwbGUucGRmAA4AHAANAHkAdQAwADQAdAB1AHAAbABlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA7VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3l1MDR0dXBsZS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBVMaWJyYXJ5L3l1MDR0dXBsZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACUAJSAlcCYAJrAm8CfQKEAo0CpQKqAq0CugK/AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAtE=},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/GRID.2004.3}}

@techreport{leymann01wsfl,
	Abstract = {The Web Services Flow Language (WSFL) is an XML language for the description of Web 
Services compositions. WSFL considers two types of Web Services compositions: 

The first type specifies the appropriate usage pattern of a collection of Web 
Services, in such a way that the resulting composition describes how to achieve a 
particular business goal; typically, the result is a description of a business process. 

The second type specifies the interaction pattern of a collection of Web Services; in 
this case, the result is a description of the overall partner interactions.},
	Annote = {WSFL is a business workflow language, based on XML and utilizing web services.},
	Author = {Frank Leymann},
	Date-Added = {2008-07-25 13:32:11 -0700},
	Date-Modified = {2008-07-25 13:36:58 -0700},
	Institution = {IBM},
	Keywords = {workflow},
	Month = {May},
	Read = {Yes},
	Title = {{Web Services Flow Language (WSFL 1.0)}},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFsZXltYW5uMDF3c2ZsLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fkx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsZXltYW5uMDF3c2ZsLnBkZgAOACQAEQBsAGUAeQBtAGEAbgBuADAAMQB3AHMAZgBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2xleW1hbm4wMXdzZmwucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9sZXltYW5uMDF3c2ZsLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==}}

@manual{doc07quartzcomposer,
	Abstract = {The Quartz Composer framework defines classes and protocols that work with compositions built 
using the Quartz Composer development tool. This book describes how to use the QCView and 
QCRenderer classes, and how to include compositions in webpages and widgets. 

You should read this document if you are a developer who wants to load, play, and control 
compositions programmatically from a Cocoa application. This document assumes that you are 
familiar with the Quartz Composer development tool and the information in Quartz Composer User 
Guide. If you want to learn how to use the QCPlugIn class to create custom patches that you can use 
from within the Quartz Composer development tool, see Quartz Composer Custom Patch Programming 
Guide. 
},
	Date-Added = {2008-07-25 11:01:20 -0700},
	Date-Modified = {2008-07-25 16:01:43 -0700},
	Keywords = {workflow,graphics},
	Organization = {Apple Inc.},
	Title = {{Quartz Composer Programming Guide}},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdQAAAAAAdQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRdkb2MwN3F1YXJ0emNvbXBvc2VyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1elx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBSTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpkb2MwN3F1YXJ0emNvbXBvc2VyLnBkZgAOADAAFwBkAG8AYwAwADcAcQB1AGEAcgB0AHoAYwBvAG0AcABvAHMAZQByAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBFVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2RvYzA3cXVhcnR6Y29tcG9zZXIucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAfTGlicmFyeS9kb2MwN3F1YXJ0emNvbXBvc2VyLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJ4AnoCfwKIApMClwKlAqwCtQLXAtwC3wLsAvEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADAw==},
	Bdsk-Url-1 = {http://developer.apple.com/documentation/GraphicsImaging/Conceptual/QuartzComposer}}

@inproceedings{fahringer05agwl,
	Abstract = {Currently grid application developers often configure available application components into a workflow of tasks that they can submit for executing on the grid. In this paper, we present an abstract grid workflow language (AGWL) for describing grid workflow applications at a high level of abstraction. AGWL has been designed such that the user can concentrate on specifying grid applications without dealing with either the complexity of the grid or any specific implementation technology (e.g. Web service). AGWL is an XML-based language which allows a programmer to define a graph of activities that refer mostly to computational tasks. Activities are connected by control and data flow links. A rich set of constructs (compound activities) is provided to simplify the specification of grid workflow applications which includes compound activities such as if, forEach and while loops as well as advanced compound activities including parallel sections, parallel loops and collection iterators. Moreover, AGWL supports a generic high level access mechanism to data repositories. AGWL is the main interface to the ASKALON grid application development environment and has been applied to numerous real world applications. We describe a material science workflow that has been successfully ported to a grid infrastructure based on an AGWL specification. Only a dozen AGWL activities are needed to describe a workflow with several hundred activity instances.},
	Address = {Washington, DC, USA},
	Author = {Thomas Fahringer and Jun Qin and Stefan Hainzer},
	Booktitle = {CCGRID '05: Proceedings of the Fifth IEEE International Symposium on Cluster Computing and the Grid (CCGrid'05) - Volume 2},
	Date-Added = {2008-07-24 19:02:21 -0700},
	Date-Modified = {2008-07-25 15:21:18 -0700},
	Doi = {10.1109/CCGRID.2005.1558629},
	Isbn = {0-7803-9074-1},
	Keywords = {workflow},
	Pages = {676--685},
	Publisher = {IEEE Computer Society},
	Title = {Specification of grid workflow applications with {AGWL}: an Abstract Grid Workflow Language},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNmYWhyaW5nZXIwNWFnd2wucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eox1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmYWhyaW5nZXIwNWFnd2wucGRmAA4AKAATAGYAYQBoAHIAaQBuAGcAZQByADAANQBhAGcAdwBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2ZhaHJpbmdlcjA1YWd3bC5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2ZhaHJpbmdlcjA1YWd3bC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/CCGRID.2005.1558629}}

@misc{andrews03bpel,
	Abstract = {Business Process Execution Language for Web Services provides a means to formally specify business processes and interaction protocols.  BPEL4WS provides a language for the formal specification of business processes and business interaction protocols. By doing so, it extends the Web Services interaction model and enables it to support business transactions. BPEL4WS defines an interoperable integration model that should facilitate the expansion of automated process integration in both the intra-corporate and the business-to-business spaces.},
	Annote = {Interesting mainly as an illustration of how byzantine the world of business workflows is.  BPEL is a joint standard from IBM and Microsoft, based on IBM's WSFL system and Microsoft's XLANG.},
	Author = {Tony Andrews and Francisco Curbera and Hitesh Dholakia and Yaron Goland and Johannes Klein and Frank Leymann and Kevin Liu and Dieter Roller and Doug Smith and Satish Thatte and Ivana Trickovic and Sanjiva Weerawarana},
	Date-Added = {2008-07-24 18:30:03 -0700},
	Date-Modified = {2008-07-25 17:33:24 -0700},
	Howpublished = {http://www.ibm.com/developerworks/library/specification/ws-bpel/},
	Keywords = {workflow},
	Month = {May},
	Read = {Yes},
	Title = {{Business Process Execution Language} for Web Services Version 1.1},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFhbmRyZXdzMDNicGVsLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d/x1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphbmRyZXdzMDNicGVsLnBkZgAOACQAEQBhAG4AZAByAGUAdwBzADAAMwBiAHAAZQBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2FuZHJld3MwM2JwZWwucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9hbmRyZXdzMDNicGVsLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://www.ibm.com/developerworks/library/specification/ws-bpel/}}

@inproceedings{fahringer04agwl,
	Abstract = {Grid workflow applications are emerging as one of the most interesting application classes for the Grid. In this paper we present A-GWL, a novel Grid workflow language to describe the workflow of Grid applications at a high level of abstraction. A-GWL has been designed to allow the user to concentrate on describing scientific Grid applications. The user is shielded from details of the underlying Grid infrastructure. A-GWL is XML-based which defines a graph of activities that refers to computational tasks or user interactions. Activities are connected by control- and data-flow links. We have defined A-GWL to support the user in orchestrating Grid workflow applications through a rich set of constructs including sequence of activities, sub-activities, control-flow mechanisms (sequential flow, exclusive choice, and sequential loops), data-flow mechanisms (input/output ports), and data repositories. Moreover, our work differs from most existing Grid workflow languages by advanced workflow constructs such as parallel execution of activities with pre- and post-conditions, parallel loops, event-based synchronization mechanisms, and property-based selection of activities. In addition, the user can specify high-level constraints and properties for activities and data-flow links.},
	Annote = {AGWL specifies workflows at a high level in an XML format.  These representations are translated down into CGWL - the Concrete Grid Workflow Language - which is apparently targeted to a particular execution environment.  

AGWL supports several interesting features.  "Activities" are the basic units of work, and they can be connected using both control- and data-flow constructs.  There is a rich set of primitives for specifying parallelism, including pre- and post-conditions.  Dataflow is achieved by connecting inputs and outputs of activities.  The model is "subscription" - an input can subscribe to a named output.

Activities can be hierarchical - a connected set of activities effectively constitutes a single named activity that can be used normally.

Dataflow supports the idea of constraints and properties.  Constraints are things like "store locally" or "use cache" that allow users to provide hints to the system.  Properties are just extra information, such as data types, estimated throughput, etc.

There is also a notion of "repositories".  These are used in the dataflow as simply pools of data objects.},
	Author = {Thomas Fahringer and Sabri Pllana and Alex Villazon},
	Booktitle = {4th International Conference on Computational Science (ICCS 2004)},
	Date-Added = {2008-07-09 15:02:53 -0700},
	Date-Modified = {2008-07-24 17:13:41 -0700},
	Doi = {10.1007/b97988},
	Keywords = {workflow},
	Month = {June},
	Pages = {42--49},
	Publisher = {Springer Berlin / Heidelberg},
	Read = {Yes},
	Series = {Lecture Notes in Computer Science},
	Title = {{A-GWL: Abstract Grid Workflow Language}},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNmYWhyaW5nZXIwNGFnd2wucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1enx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmYWhyaW5nZXIwNGFnd2wucGRmAA4AKAATAGYAYQBoAHIAaQBuAGcAZQByADAANABhAGcAdwBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2ZhaHJpbmdlcjA0YWd3bC5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2ZhaHJpbmdlcjA0YWd3bC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://www.springerlink.com/content/3qn3nj3k16bnqpyj}}

@inproceedings{gibson07playground,
	Abstract = {Workflows systems are steadily finding their way into the work practices of scientists. This is particularly true in the in silico science of bioinformatics, where biological data can be processed by Web Services. In this paper we investigate the potential of evolving the users' interaction with workflow environments so that it more closely relates to the mode in which their day to day work is carried out. We present the Data Playground, an environment designed to encourage the uptake of workflow systems in bioinformatics through more intuitive interaction by focusing the user on their data rather than on the processes. We implement a prototype plug-in for the Taverna workflow environment and show how this can promote the creation of workflow fragments by automatically converting the users' interactions with data and Web Services into a more conventional workflow specification.},
	Address = {Los Alamitos, CA, USA},
	Annote = {Usability study for an extended version of Taverna.},
	Author = {Andrew Gibson and Matthew Gamble and Katy Wolstencroft and Tom Oinn and Carole Goble},
	Booktitle = {Third IEEE International Conference on e-Science and Grid Computing (e-Science 2007)},
	Date-Added = {2008-07-08 17:04:28 -0700},
	Date-Modified = {2008-07-15 20:26:16 -0700},
	Doi = {http://doi.ieeecomputersociety.org/10.1109/E-SCIENCE.2007.72},
	Isbn = {0-7695-3064-8},
	Keywords = {workflow},
	Pages = {59-68},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {The Data Playground: An Intuitive Workflow Specification Environment},
	Volume = {0},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZnaWJzb24wN3BsYXlncm91bmQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e4x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpnaWJzb24wN3BsYXlncm91bmQucGRmAAAOAC4AFgBnAGkAYgBzAG8AbgAwADcAcABsAGEAeQBnAHIAbwB1AG4AZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9naWJzb24wN3BsYXlncm91bmQucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L2dpYnNvbjA3cGxheWdyb3VuZC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/E-SCIENCE.2007.72}}

@inproceedings{yang07peer,
	Abstract = {Nowadays, grid and peer-to-peer (p2p) technologies have become popular solutions for largescale resource sharing and system integration. For escience workflow systems, grid is a convenient way of constructing new services by composing existing services, while p2p is an effective approach to eliminate the performance bottlenecks and enhance the scalability of the systems. However, existing workflow systems focus either on p2p or grid environments and therefore cannot take advantage of both technologies. It is desirable to incorporate the two technologies in workflow systems. SwinDeW-G (Swinburne Decentralised Workflow for Grid) is a novel hybrid decentralised workflow management system facilitating both grid and p2p technologies. It is derived from the former p2p based SwinDeW system but redeveloped as grid services with communications between peers conducted in a p2p fashion. This paper describes the system design and functions of the runtime environment of SwinDeW-G.},
	Address = {Los Alamitos, CA, USA},
	Annote = {A workflow execution environment that incorporates both grid and P2P technologies.  Grids have the advantage of utilizing locally grouped resources to increase throughput as well as sophisticated priviledges and administration capabilities.  P2P allows for distributed data and control, and increase scalability.

The system is called SwinDeW-G, and is based on Globus and Java, and is an extension of previous work (SwinDeW) allowing workflows to be executed on a P2P-based runtime.

The merging is achieved by wrapping peers inside grid services and deploying them as grid middleware apps.  Peers are deployed into the grid and search for each other.  Once connected, P2P protocols are used to transfer data and control.},
	Author = {Yun Yang and Ke Liu and Jinjun Chen and Joel Lignier and Hai Jin},
	Booktitle = {Third IEEE International Conference on e-Science and Grid Computing (e-Science 2007)},
	Date-Added = {2008-07-08 17:02:10 -0700},
	Date-Modified = {2008-07-25 13:39:26 -0700},
	Doi = {http://doi.ieeecomputersociety.org/10.1109/E-SCIENCE.2007.56},
	Isbn = {0-7695-3064-8},
	Keywords = {workflow},
	Pages = {51-58},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {Peer-to-Peer Based Grid Workflow Runtime Environment of {SwinDeW-G}},
	Volume = {0},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ55YW5nMDdwZWVyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gmx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp5YW5nMDdwZWVyLnBkZgAADgAeAA4AeQBhAG4AZwAwADcAcABlAGUAcgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS95YW5nMDdwZWVyLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS95YW5nMDdwZWVyLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/E-SCIENCE.2007.56}}

@inproceedings{siddiqui07workflow,
	Abstract = {On-demand synthesis of Grid activities can play a significant role in automatic workflow composition and in improving quality of the Grid resource provisioning. However, in the Grid, synthesis of activities has been largely ignored due to the limited expressiveness of the representation of activity capabilities and the lack of adapted resource management means to take advantage of such activity synthesis. This paper introduces a new mechanism for automatic synthesis of available activities in the Grid by applying ontology rules. Rule-based synthesis combines multiple primitive activities to form new compound activities. The synthesized activities can be provisioned as new or alternative options for negotiation as well as advance reservation. This is a major advantage compared to other approaches that only focus on resource matching and brokerage. Furthermore, the new synthesized activities provide aggregated capabilities that otherwise may not be possible, leading towards an automatic generation of Grid workflows. We developed a prototype to demonstrate advantages of our approach.},
	Address = {Los Alamitos, CA, USA},
	Annote = {Grids provide services that can be composed into workflows.  But, a user might not know about those services, and only be interested in, for example providing an input and getting an output, both of a particular type.  The system described in this paper is able to synthesize primitive activities to automatically generate possible workflows that match given criteria, including input and output types and quality-of-service guarantees.  To accomplish this task, the system uses Askalon/AGWL for the workflow descriptions, and uses Jena ontologies to decide if a workflow fits a description.

How well does this scale?  The given example seems somewhat trivial.  Are there some activities that can have infinitely many synthetic constructions? 
},
	Author = {Mumtaz Siddiqui and Alex Villazon and Thomas Fahringer},
	Booktitle = {Third IEEE International Conference on e-Science and Grid Computing (e-Science 2007)},
	Date-Added = {2008-07-08 16:57:43 -0700},
	Date-Modified = {2009-05-14 12:08:53 -0700},
	Doi = {http://doi.ieeecomputersociety.org/10.1109/E-SCIENCE.2007.68},
	Isbn = {0-7695-3064-8},
	Keywords = {workflow},
	Pages = {43-50},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {Semantic-Based On-demand Synthesis of Grid Activities for Automatic Workflow Generation},
	Volume = {0},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZzaWRkaXF1aTA3d29ya2Zsb3cucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gQx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzaWRkaXF1aTA3d29ya2Zsb3cucGRmAAAOAC4AFgBzAGkAZABkAGkAcQB1AGkAMAA3AHcAbwByAGsAZgBsAG8AdwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9zaWRkaXF1aTA3d29ya2Zsb3cucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L3NpZGRpcXVpMDd3b3JrZmxvdy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/E-SCIENCE.2007.68}}

@inproceedings{rahman07workflow,
	Abstract = {Effective scheduling is a key concern for the execution of performance driven Grid applications. In this paper, we propose a Dynamic Critical Path (DCP) based workflow scheduling algorithm that determines efficient mapping of tasks by calculating the critical path in the workflow task graph at every step. It assigns priority to a task in the critical path which is estimated to complete earlier. Using simulation, we have compared the performance of our proposed approach with other existing heuristic and meta-heuristic based scheduling strategies for different type and size of workflows. Our results demonstrate that DCP based approach can generate better schedule for most of the type of workflows irrespective of their size particularly when resource availability changes frequently.},
	Address = {Los Alamitos, CA, USA},
	Annote = {Adapts the Dynamic Critical Path algorithm for use on a grid, assuming that grids have heterogeneous resources.    In particular, the algorithm is able to match tasks on the critical (most time-consuming) path with the resources that will execute them the fastest, and prior matchings are considered since these may affect execution times downstream.

This paper also has a useful empircal comparison of different scheduling techniques.

In their evaluation they did not use real workflows, but rather three types of "representative" workflows.  Th types were Parallel (fork, many processes in parallel, then a join), Fork-Join (fork, then join, repeat), and random (generate a random DAG).  In each case, the activities have random execution times (that vary by where they are scheduled).  

According to their tests, their algorithm's performance is average compared to traditional algorithms (Myopic (naive), Min/Min, Max/Min, HEFT, Grasp, Genetic) under static scheduling conditions.  Under dynamic conditions, they are among the best, but not a clear winner.  In general, it appears that heuristic approaches (like DCP-G, HEFT and even Myopic) are the best choices in dynamic environments.
},
	Author = {Mustafizur Rahman and Srikumar Venugopal and Rajkumar Buyya},
	Booktitle = {Third IEEE International Conference on e-Science and Grid Computing (e-Science 2007)},
	Date-Added = {2008-07-08 16:54:12 -0700},
	Date-Modified = {2009-05-14 12:08:00 -0700},
	Doi = {10.1109/E-SCIENCE.2007.3},
	Isbn = {0-7695-3064-8},
	Keywords = {workflow},
	Pages = {35-42},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {A Dynamic Critical Path Algorithm for Scheduling Scientific Workflow Applications on Global Grids},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRyYWhtYW4wN3dvcmtmbG93LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gCx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyYWhtYW4wN3dvcmtmbG93LnBkZgAADgAqABQAcgBhAGgAbQBhAG4AMAA3AHcAbwByAGsAZgBsAG8AdwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9yYWhtYW4wN3dvcmtmbG93LnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9yYWhtYW4wN3dvcmtmbG93LnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/E-SCIENCE.2007.3}}

@inproceedings{lee00dataflow,
	Abstract = {Dataflow computation models enable simpler and more efficient management of the memory hierarchy - a key barrier to the performance of many parallel programs. This paper describes a dataflow language based on Java. Use of the dataflow model enables a programmer to generate parallel programs without explicit directions for message passing, work allocation and synchronization. A small handful of additional syntactic constructs are required. A pre-processor is used to convert Dataflow Java programs to standard portable Java.The underlying run-time system was easy to implement using Java's object modeling and communications primitives. Although raw performance lags behind an equivalent C-based system, we were able to demonstrate useful speedups in a heterogeneous environment, thus amply illustrating the potential power of the Dataflow Java approach to use all machines - of whatever type - that might be available on a network .. when Java JIT compiler technology matures.},
	Address = {Washington, DC, USA},
	Author = {Gareth Lee and John Morris},
	Booktitle = {ACAC '00: Proceedings of the 5th Australasian Computer Architecture Conference},
	Date-Added = {2008-07-08 12:05:47 -0700},
	Date-Modified = {2008-07-08 12:07:37 -0700},
	Isbn = {0-7695-0512-0},
	Keywords = {pl,dataflow},
	Pages = {42},
	Publisher = {IEEE Computer Society},
	Title = {Dataflow Java: Implicitly Parallel Java},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFsZWUwMGRhdGFmbG93LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fex1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsZWUwMGRhdGFmbG93LnBkZgAOACQAEQBsAGUAZQAwADAAZABhAHQAYQBmAGwAbwB3AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2xlZTAwZGF0YWZsb3cucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9sZWUwMGRhdGFmbG93LnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/ACAC.2000.824321}}

@inproceedings{snyder07zpl,
	Abstract = {ZPL is an implicitly parallel programming language, which means all instructions to implement and manage the parallelism are inserted by the compiler. It is the first implicitly parallel language to achieve performance portability, that is, consistent high performance across all (MIMD) parallel platforms. ZPL has been designed from first principles, and is founded on the CTA abstract parallel machine. A key enabler of ZPL's performance portability is its What You See Is What You Get (WYSIWYG) performance model. The paper describes the antecedent research on which ZPL was founded, the design principles used to build it incrementally, and the technical basis for its performance portability. Comparisons with other parallel programming approaches are included.},
	Address = {New York, NY, USA},
	Author = {Lawrence Snyder},
	Booktitle = {HOPL III: Proceedings of the third ACM SIGPLAN conference on History of programming languages},
	Date-Added = {2008-06-30 16:32:24 -0700},
	Date-Modified = {2008-07-01 00:31:03 -0700},
	Doi = {10.1145/1238844.1238852},
	Isbn = {978-1-59593-766-X},
	Keywords = {pl,concurrent},
	Location = {San Diego, California},
	Pages = {8-1--8-37},
	Publisher = {ACM},
	Title = {The Design and Development of ZPL},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9zbnlkZXIwN3pwbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gUx1O5JQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmlAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzbnlkZXIwN3pwbC5wZGYADgAgAA8AcwBuAHkAZABlAHIAMAA3AHoAcABsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3NueWRlcjA3enBsLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvc255ZGVyMDd6cGwucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1238844.1238852}}

@unpublished{roy08multi,
	Abstract = {I was recently invited to be on the panel Reinventing Audio and Music Computation for Many-Core Processors at the International Computer Music Conference (ICMC 2008), Belfast, Ireland, Aug. 2008. In my position statement, The Challenges and Opportunities of Multiple Processors: Why Multi-Core Processors are Easy and Internet is Hard, I explain why programming multi-core processors is basically a sociological problem (the technical problems were solved long ago) and why programming loosely coupled systems (like the Internet) still has a lot of technical challenges. I am curious to hear what the LtU community thinks about this.},
	Author = {Peter Van Roy},
	Date-Added = {2008-06-26 14:21:28 -0700},
	Date-Modified = {2008-06-26 14:24:54 -0700},
	Keywords = {concurrent, pl},
	Month = {June},
	Note = {Position paper for panel at the International Computer Music Conference 2008},
	Title = {The Challenges and Opportunities of Multiple Processors: Why Multi-Core Processors are Easy and Internet is Hard},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ5yb3kwOG11bHRpLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gLx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpyb3kwOG11bHRpLnBkZgAADgAeAA4AcgBvAHkAMAA4AG0AdQBsAHQAaQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9yb3kwOG11bHRpLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS9yb3kwOG11bHRpLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==},
	Bdsk-Url-1 = {http://lambda-the-ultimate.org/node/2874}}

@inproceedings{gaudiot97sisal,
	Abstract = {Programming massively-parallel machine is a daunting task for any human programmer and parallelization may even be impossible for any compiler. Instead, the functional programming paradigm may prove to be an ideal solution by providing an implicitly parallel interface to the programmer. We describe here the Sisal project (Stream and Iteration in a Single Assignment Language) and its goal to provide a general-purpose user interface for a wide range of parallel processing platforms.},
	Address = {Los Alamitos, CA, USA},
	Author = {Jean-Luc Gaudiot and Tom DeBoni and John Feo and Wim Bohm and Walid Najjar and Patrick Miller},
	Booktitle = {Proceedings of the Second Aizu International Symposium on Parallel Algorithms/Architecture Synthesis},
	Date-Added = {2008-06-26 14:09:32 -0700},
	Date-Modified = {2009-06-15 15:43:54 -0700},
	Doi = {10.1109/AISPAS.1997.581640},
	Isbn = {0-8186-7870-4},
	Keywords = {dataflow, pl},
	Month = {March},
	Pages = {112--123},
	Publisher = {IEEE Computer Society},
	Title = {The Sisal Model of Functional Programming and its Implementation},
	Year = {1997},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJnYXVkaW90OTdzaXNhbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e3x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpnYXVkaW90OTdzaXNhbC5wZGYAAA4AJgASAGcAYQB1AGQAaQBvAHQAOQA3AHMAaQBzAGEAbAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9nYXVkaW90OTdzaXNhbC5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvZ2F1ZGlvdDk3c2lzYWwucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/AISPAS.1997.581640}}

@inbook{gaudiot01sisal,
	Abstract = {Programming massively-parallel machine is a daunting task for any human programmer and parallelization may even be impossible for any compiler. Instead, the functional programming paradigm may prove to be an ideal solution by providing an implicitly parallel interface to the programmer. We describe here the Sisal project (Stream and Iteration in a Single Assignment Language) and its goal to provide a general-purpose user interface for a wide range of parallel processing platforms.},
	Address = {New York, NY, USA},
	Author = {Jean-Luc Gaudiot and Tom DeBoni and John Feo and Wim Bohm and Walid Najjar and Patrick Miller},
	Chapter = {The Sisal project: real world functional programming},
	Date-Added = {2008-06-26 13:42:36 -0700},
	Date-Modified = {2009-05-14 12:04:01 -0700},
	Doi = {10.1007/3-540-45403-9},
	Isbn = {3-540-41945-4},
	Keywords = {dataflow, pl},
	Pages = {45--72},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {Compiler optimizations for scalable parallel systems: languages, compilation techniques, and run time systems},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJnYXVkaW90MDFzaXNhbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e2x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpnYXVkaW90MDFzaXNhbC5wZGYAAA4AJgASAGcAYQB1AGQAaQBvAHQAMAAxAHMAaQBzAGEAbAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9nYXVkaW90MDFzaXNhbC5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvZ2F1ZGlvdDAxc2lzYWwucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/3-540-45403-9_2}}

@article{mcgraw82val,
	Abstract = {VAL is a high-level, function-based language designed for use on data flow computers. A data flow computer has many small processors organized to cooperate in the execution of a single computation. A computation is represented by its data flow graph; each operator in a graph is scheduled for execution on one of the processors after all of its operands' values are known. VAL promotes the identification of concurrency in algorithms and simplifies the mapping into data flow graphs.

This paper presents a detailed introduction to VAL and analyzes its usefulness for programming in a highly concurrent environment. VAL provides implicit concurrency (operations that can execute simultaneously are evident without the need for any explicit language notation). The language uses function- and expression-based features that prohibit all side effects, which simplifies translation to graphs. The salient language features are described and illustrated through examples taken from a complete VAL program for adaptive quadrature. Analysis of the language shows that VAL meets the critical needs for a data flow environment. The language encourages programmers to think in terms of general concurrency, enhances readability (due to the absence of side effects), and possesses a structure amenable to verification techniques. However, VAL is still evolving. The language definition needs refining, and more support tools for programmer use need to be developed. Also, some new kinds of optimization problems should be addressed.},
	Address = {New York, NY, USA},
	Author = {James R. McGraw},
	Date-Added = {2008-06-17 18:04:10 -0700},
	Date-Modified = {2008-06-17 18:05:56 -0700},
	Doi = {10.1145/357153.357157},
	Issn = {0164-0925},
	Journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	Keywords = {dataflow, pl},
	Number = {1},
	Pages = {44--82},
	Publisher = {ACM},
	Title = {The VAL Language: Description and Analysis},
	Volume = {4},
	Year = {1982},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9tY2dyYXc4MnZhbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fux1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptY2dyYXc4MnZhbC5wZGYADgAgAA8AbQBjAGcAcgBhAHcAOAAyAHYAYQBsAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L21jZ3JhdzgydmFsLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvbWNncmF3ODJ2YWwucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/357153.357157}}

@article{campagna98directed,
	Abstract = {In a broad range of computer graphics applications, the representation of geometric shape is based on triangle meshes. General purpose data structures for polygonal meshes typically provide fast access to geometric objects (e.g., points) and topological entities (e.g., neighborhood relationships) but the memory requirements are rather high due to the many special configurations. In this paper, we present a new data structure which is specifically designed for triangle meshes. The data structure enables the programmer to trade memory for access time by either storing internal references explicitly, or by reconstructing them locally on demand. The trade-off can be hidden from the programmer by an object-oriented API and can automatically adapt to the available hardware resources or the complexity of the mesh (scalability).},
	Address = {Natick, MA, USA},
	Author = {Swen Campagna and Leif Kobbelt and Hans-Peter Seidel},
	Date-Added = {2008-06-05 13:47:10 -0700},
	Date-Modified = {2008-06-05 13:51:49 -0700},
	Issn = {1086-7651},
	Journal = {Journal of Graphics Tools},
	Keywords = {graphics},
	Month = {December},
	Number = {4},
	Pages = {1--12},
	Publisher = {A. K. Peters, Ltd.},
	Title = {Directed edges -- A scalable representation for triangle meshes},
	Volume = {3},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZjYW1wYWduYTk4ZGlyZWN0ZWQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eQx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjYW1wYWduYTk4ZGlyZWN0ZWQucGRmAAAOAC4AFgBjAGEAbQBwAGEAZwBuAGEAOQA4AGQAaQByAGUAYwB0AGUAZAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9jYW1wYWduYTk4ZGlyZWN0ZWQucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L2NhbXBhZ25hOThkaXJlY3RlZC5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?id=335548}}

@webpage{web08mevis,
	Date-Added = {2008-06-02 13:58:12 -0700},
	Date-Modified = {2008-07-25 13:39:55 -0700},
	Keywords = {workflow},
	Title = {{MeVisLab}},
	Url = {http://www.mevis-research.de/~ritter/awakeideas/mevislab-macosx.html},
	Bdsk-Url-1 = {http://www.mevis-research.de/~ritter/awakeideas/mevislab-macosx.html}}

@article{cardelli87polymorphic,
	Abstract = {Polymorphic means to have many forms. As related to programming languages, it refers to data or programs which have many types, or which operate on many types. There are several arbitrary ways in which programs can have many types; we are mostly interested in a particularly orderly form of polymorphism called parametric polymorphism. This is a property of programs which are parametric with respect to the type of some of their identifiers. There are two major ways of achieving parametric polymorphism which are conceptually related but pragmatically very different: explicit and implicit polymorphism. },
	Address = {Amsterdam, The Netherlands},
	Annote = {Assigned reading for 621 PL course in Spring 2008.
},
	Author = {Luca Cardelli},
	Date-Added = {2008-05-26 23:24:58 -0700},
	Date-Modified = {2008-07-15 20:52:12 -0700},
	Doi = {10.1016/0167-6423(87)90019-0},
	Issn = {0167-6423},
	Journal = {Science of Computer Programming},
	Keywords = {pl},
	Number = {2},
	Pages = {147--172},
	Publisher = {Elsevier North-Holland, Inc.},
	Read = {Yes},
	Title = {Basic polymorphic typechecking},
	Volume = {8},
	Year = {1987},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdwAAAAAAdwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRljYXJkZWxsaTg3cG9seW1vcnBoaWMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eRx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBUTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjYXJkZWxsaTg3cG9seW1vcnBoaWMucGRmAA4ANAAZAGMAYQByAGQAZQBsAGwAaQA4ADcAcABvAGwAeQBtAG8AcgBwAGgAaQBjAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBHVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2NhcmRlbGxpODdwb2x5bW9ycGhpYy5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfECFMaWJyYXJ5L2NhcmRlbGxpODdwb2x5bW9ycGhpYy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACgAKCAocCkAKbAp8CrQK0Ar0C4QLmAukC9gL7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAw0=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1016/0167-6423(87)90019-0}}

@webpage{web06wings,
	Abstract = {This will be an interactive tutorial with both presentations and hands-on sessions. The first session is a high-level introduction to workflows and to Wings/Pegasus, and is the only one you need to attend if you just want to learn about workflows. The next two sessions are hands-on and designed for people who want to learn how to create and execute workflows using Wings and Pegasus.},
	Date-Added = {2008-05-16 17:44:15 -0700},
	Date-Modified = {2008-05-16 17:46:00 -0700},
	Keywords = {workflow},
	Title = {Tutorial on computational workflows and the {Wings}/{Pegasus} workflow system},
	Url = {http://seagull.isi.edu/tutorial/},
	Year = {2006},
	Bdsk-Url-1 = {http://seagull.isi.edu/tutorial/}}

@webpage{web05pgrade,
	Date-Added = {2008-05-16 14:30:47 -0700},
	Date-Modified = {2008-07-25 13:39:11 -0700},
	Keywords = {hpc, workflow},
	Title = {{P-GRADE}: Parallel Grid Runtime and Application Development Environment},
	Url = {http://www.lpds.sztaki.hu/pgrade/},
	Bdsk-Url-1 = {http://www.lpds.sztaki.hu/pgrade/}}

@inbook{hansen20origin,
	Abstract = {The author selects classic papers written by the computer scientists who made the major breakthroughs in concurrent programming. These papers cover the pioneering era of the field from the semaphores of the mid 1960s to the remote procedure calls of the late 1970s. The author summarizes the classic papers and puts them in historical perspective. 
},
	Address = {New York, NY, USA},
	Annote = {Covers the authors recollections of being there for the invention of concurrent programming.  Focuses on papers by Hansen himself, along with Hoare and Dijkstra.  In particular, it covers monitors, semaphores, RPC, message passing, fair scheduling, deadlock prevention, hierarchical structure, and extensible kernels.  It also talks about the author's experience building Concurrent Pascal.},
	Author = {Per Brinch Hansen},
	Date-Added = {2008-05-15 16:57:28 -0700},
	Date-Modified = {2008-05-16 16:35:02 -0700},
	Keywords = {concurrent, pl},
	Publisher = {Springer-Verlag New York, Inc.},
	Read = {Yes},
	Title = {The origin of concurrent programming: from semaphores to remote procedure calls},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJoYW5zZW4yMG9yaWdpbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fAx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpoYW5zZW4yMG9yaWdpbi5wZGYAAA4AJgASAGgAYQBuAHMAZQBuADIAMABvAHIAaQBnAGkAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9oYW5zZW4yMG9yaWdpbi5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvaGFuc2VuMjBvcmlnaW4ucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://brinch-hansen.net/papers/}}

@inproceedings{armstrong07history,
	Address = {New York, NY, USA},
	Author = {Joe Armstrong},
	Booktitle = {HOPL III: Proceedings of the third ACM SIGPLAN conference on History of programming languages},
	Date-Added = {2008-05-13 09:23:52 -0700},
	Date-Modified = {2008-07-25 13:41:38 -0700},
	Doi = {10.1145/1238844.1238850},
	Isbn = {978-1-59593-766-X},
	Keywords = {pl, concurrent},
	Location = {San Diego, California},
	Pages = {6-1--6-26},
	Publisher = {ACM},
	Title = {A history of {Erlang}},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZhcm1zdHJvbmcwN2hpc3RvcnkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eCx1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphcm1zdHJvbmcwN2hpc3RvcnkucGRmAAAOAC4AFgBhAHIAbQBzAHQAcgBvAG4AZwAwADcAaABpAHMAdABvAHIAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9hcm1zdHJvbmcwN2hpc3RvcnkucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L2FybXN0cm9uZzA3aGlzdG9yeS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1238844.1238850}}

@article{salimifard01petri,
	Abstract = {Despite their wide range of applications, workflow systems still suffer from lack of an agreed and standard modelling technique. It is a motivating research area and some researchers have proposed different modelling techniques. Petri nets, among the other techniques, are one of the mainly used modelling techniques for both qualitative and quantitative analysis of workflow and workflow systems. We have briefly presented a way of mapping workflow into Petri nets, which can be used as a basis for such systems. A lot of available papers on Petri net-based modelling of workflow have been reviewed and classified.},
	Author = {Khodakaram Salimifard and Mike Wright},
	Date-Added = {2008-05-07 11:08:21 -0700},
	Date-Modified = {2008-05-07 17:44:43 -0700},
	Journal = {European Journal of Operational Research},
	Keywords = {workflow,petrinets},
	Number = {3},
	Pages = {664--676},
	Title = {Petri net-based modelling of workflow systems: An overview},
	Volume = {134},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcwAAAAAAcwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRVzYWxpbWlmYXJkMDFwZXRyaS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gNx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBQTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpzYWxpbWlmYXJkMDFwZXRyaS5wZGYADgAsABUAcwBhAGwAaQBtAGkAZgBhAHIAZAAwADEAcABlAHQAcgBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBDVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3NhbGltaWZhcmQwMXBldHJpLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QHUxpYnJhcnkvc2FsaW1pZmFyZDAxcGV0cmkucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnACcgJ3AoACiwKPAp0CpAKtAs0C0gLVAuIC5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAL5},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/B6VCT-43RTKW4-K/1/9d277dce29cc2d510a922e035fb49b52}}

@inproceedings{ma07automatic,
	Abstract = {Desktop computing remains indispensable in scientific exploration, largely because it provides people with devices for human interaction and environments for interactive job execution. However, with today's rapidly growing data volume and task complexity, it is increasingly hard for individual workstations to meet the demands of interactive scientific data processing. The increasing cost of such interactive processing is hindering the productivity of end-to-end scientific computing workflows. While existing distributed computing systems allow people to aggregate desktop workstation resources for parallel computing, the burden of explicit parallel programming and parallel job execution often prohibits scientists to take advantage of such platforms. In this paper, we discuss the need for transparent desktop parallel computing in scientific data processing. As an initial step toward this goal, we present our on-going work on the automatic parallelization of the scripting language R, a popular tool for statistical computing. Our preliminary results suggest that a reasonable speedup can be achieved on real-world sequential R programs without requiring any code modification.},
	Address = {Los Alamitos, CA, USA},
	Author = {Xiaosong Ma and Jiangtian Li and Nagiza F. Samatova},
	Booktitle = {IEEE International Parallel and Distributed Processing Symposium (IPDPS'07)},
	Date-Added = {2008-05-07 10:46:09 -0700},
	Date-Modified = {2008-05-15 18:00:57 -0700},
	Doi = {10.1109/IPDPS.2007.370488},
	Keywords = {pl,concurrent},
	Month = {March},
	Pages = {1--6},
	Publisher = {IEEE Computer Society},
	Title = {Automatic Parallelization of Scripting Languages: Toward Transparent Desktop Parallel Computing},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFtYTA3YXV0b21hdGljLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fpx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptYTA3YXV0b21hdGljLnBkZgAOACQAEQBtAGEAMAA3AGEAdQB0AG8AbQBhAHQAaQBjAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L21hMDdhdXRvbWF0aWMucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9tYTA3YXV0b21hdGljLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/IPDPS.2007.370488}}

@inproceedings{callahan06vistrails,
	Abstract = {Scientists are now faced with an incredible volume of data to analyze. To successfully analyze and validate various hypotheses, it is necessary to pose several queries, correlate disparate data, and create insightful visualizations of both the simulated processes and observed phenomena. Data exploration through visualization requires scientists to go through several steps. In essence, they need to assemble complex workflows that consist of dataset selection, specification of series of operations that need to be applied to the data, and the creation of appropriate visual representations, before they can finally view and analyze the results. Often, insight comes from comparing the results of multiple visualizations that are created during the data exploration process.},
	Address = {Los Alamitos, CA, USA},
	Annote = {Scientists need tools that allow them to run simulations and visualize the results interactively.  Systems like SCIRun and Paraview allow the creation and manipulation of visualizations, but have limitations.  First, they do not distinguish between a workflow definition and instantiations of that workflow, and parameters must be changed (by hand) in a GUI.  Second, they do not support provenance.

VisTrails is unique in that it supports provenance information on the workflow definitions.  Other systems usually only support provenance of the data generated by a workflow.  This enables scientists to explore a parameter space, go back to old versions of workflows, and compare new workflows with old ones.

VisTrails separates workflow instances from specifications.  An instance is the series of steps used to generate the product, and this can be used as a record for its own sake, and also to regenerate the product.  When used as a template, the parameters can be varied. 

VisTrails stores its workflow specifications and instances as XML, and these can be queried (using XQuery).

VisTrails optimizes the workflows, e.g. factoring out common subexpressions and identifying parallel steps.  It also caches intermediate results that might be used again (memoization).  A related benefit is the ability to restart from a fail point and not have to recalculate everything.  This is possible because VisTrails also keeps detailed logs.

VisTrails uses an interesting graphical "spreadsheet" representation of the parameter space, where different parameterizations are shown in rows and columns, allowing users to compare visualizations.  All the cells share a cache for optimization purposes.

They introduce the concept of a "vistrail", i.e. a series of workflow revisions (similar to a versioning system).  Changes include adding and deleting modules, changing connections between modules, and changing parameter values.  This captures both changes to instances (parameter values) and to specifications (modules and connections).  Important versions of dataflows can be tagged for easy retrieval.},
	Author = {Steven P. Callahan and Juliana Freire and Emanuele Santos and Carlos E. Scheidegger and Claudio T. Silva and Huy T. Vo},
	Booktitle = {22nd International Conference on Data Engineering Workshops (ICDEW'06)},
	Date-Added = {2008-05-06 21:57:12 -0700},
	Date-Modified = {2008-07-25 13:40:04 -0700},
	Doi = {10.1109/ICDEW.2006.75},
	Isbn = {0-7695-2571-7},
	Keywords = {workflow,provenance},
	Pages = {71--75},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {Managing the Evolution of Dataflows with {VisTrails}},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdQAAAAAAdQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRdjYWxsYWhhbjA2dmlzdHJhaWxzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ePx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBSTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjYWxsYWhhbjA2dmlzdHJhaWxzLnBkZgAOADAAFwBjAGEAbABsAGEAaABhAG4AMAA2AHYAaQBzAHQAcgBhAGkAbABzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBFVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2NhbGxhaGFuMDZ2aXN0cmFpbHMucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAfTGlicmFyeS9jYWxsYWhhbjA2dmlzdHJhaWxzLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJ4AnoCfwKIApMClwKlAqwCtQLXAtwC3wLsAvEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADAw==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICDEW.2006.75}}

@article{green96usability,
	Abstract = {The cognitive dimensions framework is a broad-brush evaluation technique for interactive devices and for non-interactive notations. It sets out a small vocabulary of terms designed to capture the cognitively-relevant aspects of structure, and shows how they can be traded off against each other. The purpose of this paper is to propose the framework as an evaluation technique for visual programming environments. We apply it to two commercially-available dataflow languages (with further examples from other systems) and conclude that it is effective and insightful; other HCI-based evaluation techniques focus on different aspects and would make good complements. Insofar as the examples we used are representative, current VPLs are successful in achieving a good `closeness of match', but designers need to consider the `viscosity ' (resistance to local change) and the `secondary notation' (possibility of conveying extra meaning by choice of layout, colour, etc.).},
	Author = {T. R. G. Green and M. Petre},
	Date-Added = {2008-05-06 21:45:01 -0700},
	Date-Modified = {2009-05-14 11:56:55 -0700},
	Journal = {Journal of Visual Languages and Computing},
	Keywords = {pl},
	Month = {June},
	Number = {2},
	Pages = {131--174},
	Title = {Usability Analysis of Visual Programming Environments: A `Cognitive Dimensions' Framework},
	Volume = {7},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRncmVlbjk2dXNhYmlsaXR5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e+x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpncmVlbjk2dXNhYmlsaXR5LnBkZgAADgAqABQAZwByAGUAZQBuADkANgB1AHMAYQBiAGkAbABpAHQAeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9ncmVlbjk2dXNhYmlsaXR5LnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9ncmVlbjk2dXNhYmlsaXR5LnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1006/jvlc.1996.0009}}

@inproceedings{acar08imperative,
	Abstract = {Self-adjusting computation enables writing programs that can automatically and efficiently respond to changes to their data (e.g., inputs). The idea behind the approach is to store all data that can change over time in modifiable references and to let computations construct traces that can drive change propagation. After changes have occurred, change propagation updates the result of the computation by re-evaluating only those expressions that depend on the changed data. Previous approaches to self-adjusting computation require that modifiable references be written at most once during execution---this makes the model applicable only in a purely functional setting.

In this paper, we present techniques for imperative self-adjusting computation where modifiable references can be written multiple times. We define a language SAIL (Self-Adjusting Imperative Language) and prove consistency, i.e., that change propagation and from-scratch execution are observationally equivalent. Since SAIL programs are imperative, they can create cyclic data structures. To prove equivalence in the presence of cycles in the store, we formulate and use an untyped, step-indexed logical relation, where step indices are used to ensure well-foundedness. We show that SAIL accepts an asymptotically efficient implementation by presenting algorithms and data structures for its implementation. When the number of operations (reads and writes) per modifiable is bounded by a constant, we show that change propagation becomes as efficient as in the non-imperative case. The general case incurs a slowdown that is logarithmic in the maximum number of such operations. We describe a prototype implementation of SAIL as a Standard ML library.},
	Address = {New York, NY, USA},
	Author = {Umut A. Acar and Amal Ahmed and Matthias Blume},
	Booktitle = {POPL '08: Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-05-06 21:23:58 -0700},
	Date-Modified = {2008-05-06 21:27:03 -0700},
	Doi = {http://doi.acm.org/10.1145/1328438.1328476},
	Isbn = {978-1-59593-689-9},
	Keywords = {pl},
	Location = {San Francisco, California, USA},
	Pages = {309--322},
	Publisher = {ACM},
	Title = {Imperative self-adjusting computation},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRhY2FyMDhpbXBlcmF0aXZlLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d5x1O5FQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmVAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphY2FyMDhpbXBlcmF0aXZlLnBkZgAADgAqABQAYQBjAGEAcgAwADgAaQBtAHAAZQByAGEAdABpAHYAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9hY2FyMDhpbXBlcmF0aXZlLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9hY2FyMDhpbXBlcmF0aXZlLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1328438.1328476}}

@webpage{web05swfsurvey,
	Date-Added = {2008-05-05 14:06:12 -0700},
	Date-Modified = {2008-05-16 14:37:06 -0700},
	Keywords = {workflow},
	Read = {Yes},
	Title = {Scientific Workflows Survey},
	Url = {http://www.extreme.indiana.edu/swf-survey/},
	Year = {2005},
	Bdsk-Url-1 = {http://www.extreme.indiana.edu/swf-survey/}}

@inproceedings{wolstencroft05panoply,
	Abstract = {The Taverna e-Science Workbench is a central component of myGrid, a loosely coupled suite of middleware services designed to support in silico experiments in biology. Taverna enables the construction and enactment of complex workflows over resources on local and remote machines, allowing the automation of otherwise labour-intensive multi-step bioinformatics tasks. As the Taverna user community has grown, so has the demand for new features and additions. This paper outlines the functional requirements that have become apparent over the last year of working with domain scientists, along with the solutions implemented in both the Taverna workbench and the Freefluo enactment engine to address concerns relating to workflow construction and enactment, respectively.},
	Address = {Los Alamitos, CA, USA},
	Annote = {Reports findings of several case studies that have influenced the recent development of myGrid, Taverna, and Freefluo.

First, they note that workflows can be highly complex.  There are lots of services available, and the number is growing.  Enforcing data standards between these is impossible.  To help with this problem, Taverna integrates with a tool called Feta that enables searching and finding services from a functional specification (e.g. all those seach a particular database, all that perform multiple sequence alignment, etc).  One problem: services must use a particular ontology to describe themselves, and this involves human effort.  A tool called Pedro provides a GUI to help service providers generate descriptions conforming to what Feta expects.

In the future, BioNanny may be able to rank search results from Feta based on service performance (how reliable, how long to execute, etc).

To support iteration, Freefluo was extended to handle sets of data.  A set of data with type T can be passed to a service expecting input of type T, and the default behavior will be invoke that service iteratively (and possibly in parallel) over the set.  Users can also ask for cross products, etc.  The results are collected into an output set.  [Note that this may reduce opportunities for parallelism if the whole output set must be collected before moving on.]

To support fault tolerance, Tavera operations have settings.  A user can specify a timeout, times to retry, and an alternative service.  If these fail, the faulty operation can be configured to abort the entire workflow, or only abort the dependent substream.

Taverna users' data needs do not always fit well within SOAP.  In these cases, specialized wrappers needed to be constructed, and in some cases the execution engine extended.

Taverna supports collaboration and reuse by allowing workflows to be saved, exported, and imported into other workflows as services.  This enables hiearchical composition.},
	Author = {K. Wolstencroft and T. Oinn and C. Goble and J. Ferris and C. Wroe and P. Lord and K. Glover and R. Stevens},
	Booktitle = {Proceedings of the First International Conference on e-Science and Grid Computing},
	Date-Added = {2008-05-05 11:54:53 -0700},
	Date-Modified = {2009-05-14 12:01:37 -0700},
	Doi = {10.1109/E-SCIENCE.2005.65},
	Isbn = {0-7695-2448-6},
	Keywords = {workflow},
	Pages = {156--162},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {Panoply of Utilities in {T}averna},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdwAAAAAAdwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRl3b2xzdGVuY3JvZnQwNXBhbm9wbHkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1glx1O5JgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmmAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBUTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTp3b2xzdGVuY3JvZnQwNXBhbm9wbHkucGRmAA4ANAAZAHcAbwBsAHMAdABlAG4AYwByAG8AZgB0ADAANQBwAGEAbgBvAHAAbAB5AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBHVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L3dvbHN0ZW5jcm9mdDA1cGFub3BseS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfECFMaWJyYXJ5L3dvbHN0ZW5jcm9mdDA1cGFub3BseS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACgAKCAocCkAKbAp8CrQK0Ar0C4QLmAukC9gL7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAw0=},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/E-SCIENCE.2005.65}}

@article{churches06triana,
	Abstract = {In this paper, we discuss a real-world application scenario that uses three distinct types of workflow within the Triana problem-solving environment: serial scientific workflow for the data processing of gravitational wave signals; job submission workflows that execute Triana services on a testbed; and monitoring workflows that examine and modify the behaviour of the executing application. We briefly describe the Triana distribution mechanisms and the underlying architectures that we can support. Our middleware independent abstraction layer, called the Grid Application Prototype (GAP), enables us to advertise, discover and communicate with Web and peer-to-peer (P2P) services. We show how gravitational wave search algorithms have been implemented to distribute both the search computation and data across the European GridLab testbed, using a combination of Web services, Globus interaction and P2P infrastructures. },
	Annote = {The paper starts with an overview of other systems, including SCIRun, ICENI, Taverna, Kepler, BPEL4WS, WSFL, and DAGMan/Condor.

Triana is different from other workflow languages in that there is no explicit support for looping constructs.  These are handled by specific components.  They claim that this makes certain common workflow idioms easier to represent.

Components in Triana are units of execution, represented by Java classes with a name, I/O ports, parameters, and a single process method.  The specification for each component is represented in XML.

Triana uses both data and control flow.  A component can have inputs that are manditory, blocking execution until data is received, or triggering immeadiately.  Execution is decentralized, with no single point of control, and communication can synchronous or asynchronous.  The workflow is a directed cyclic graph, constructed with Java objects.

Triana's execution engine supports other workflow languages, such as BPEL4WS.  [The intent is that when the one, great, perfect SWF language comes along, Triana will support it.  This seems flawed, however, since certain choices about workflows (like allowing cycles or not) are an integral part of both the language and engine].

Triana supports "virtual grid overlays" based on a subsystem called GAP that allows services to advertised, discovered, and communicated with.  In Triana, uses can (graphically) group related sections of a workflow together into compounded units, and then specify how a group is distributed with a policy.  Available policies are parallel (data parallel, no communication between processes in the group) and pipeline (each component is scheduled to a separate resource and data is passed between them).  A policy is essentially a workflow rewriting mechanism, e.g. in parallel groups the nodes are duplicated and reconnected.

Groups are the basis of hierarchical workflow reuse in Triana.

Distributed sections of workflows can be executed statically or dynamically.  The dynamic mode is like RPC, where each sub-workflow is sent to the GAP service and executed independently.  In this mode, each group is deployed with a control component that receives input and aggregates outputs, and may rewire parallel components dynamically depending on load, how many resources/services it has discovered, etc.  Outputs can be ordered by arrival or simply passed through as they are completed.  The static mode is like web-services, where groups can be deployed as a remote service with a fixed interface. [?]

GAP provides a subset of the GridLab GAT, and can take advantage of JXTA (P2P), P2PS (lighter-weight P2P), and web services (based on Apache Axis).

The execution is handled by the grid, using GRMS (a job submission grid service for command line tools).  GRMS can actually handle entire workflows itself, but Triana's system is geared towards letting Triana figure out the order, and letting it submit individual jobs to GRMS.  

In parallel (task farming groups), the number of required resources may be determined in advance (say, as a function of the algorithm) or may need to be determined at runtime.  This is related to quality-of-service issues, for example in real-time algorithms.  },
	Author = {David Churches and Gabor Gombas and Andrew Harrison and Jason Maassen and Craig Robinson and Matthew Shields and Ian Taylor and Ian Wang},
	Date-Added = {2008-05-05 10:55:30 -0700},
	Date-Modified = {2008-07-25 13:38:48 -0700},
	Doi = {10.1002/cpe.992},
	Journal = {Concurrency and Computation: Practice and Experience},
	Keywords = {workflow},
	Number = {10},
	Pages = {1021--1037},
	Read = {Yes},
	Title = {Programming scientific and distributed workflow with {Triana} services},
	Volume = {18},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRjaHVyY2hlczA2dHJpYW5hLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eVx1O5GAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmYAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpjaHVyY2hlczA2dHJpYW5hLnBkZgAADgAqABQAYwBoAHUAcgBjAGgAZQBzADAANgB0AHIAaQBhAG4AYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9jaHVyY2hlczA2dHJpYW5hLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9jaHVyY2hlczA2dHJpYW5hLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/cpe.992}}

@article{lee98framework,
	Abstract = {We give a denotational framework (a ``meta model'') within which certain properties of models of computation can be compared. It describes concurrent processes in general terms as sets of possible behaviors. A process is determinate if, given the constraints imposed by the inputs, there are exactly one or exactly zero behaviors. Compositions of processes are processes with behaviors in the intersection of the behaviors of the component processes. The interaction between processes is through signals, which are collections of events. Each event is a value-tag pair, where the tags can come from a partially ordered or totally ordered set. Timed models are where the set of tags is totally ordered. Synchronous events share the same tag, and synchronous signals contain events with the same set of tags. Synchronous processes have only synchronous signals as behaviors. Strict causality (in timed tag systems) and continuity (in untimed tag systems) ensure determinacy under certain technical conditions. The framework is used to compare certain essential features of various models of computation, including Kahn process networks, dataflow, sequential processes, concurrent sequential processes with rendezvous, Petri nets, and discrete-event systems.},
	Author = {Edward A. Lee and Alberto Sangiovanni-Vincentelli},
	Date-Added = {2008-05-02 14:12:09 -0700},
	Date-Modified = {2009-05-31 15:34:32 -0700},
	Doi = {10.1109/43.736561},
	Issn = {0278-0070},
	Journal = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
	Keywords = {dataflow,concurrent,petrinets},
	Month = {December},
	Number = {12},
	Pages = {1217--1229},
	Title = {A framework for comparing models of computation},
	Volume = {17},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcAAAAAAAcAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRJsZWU5OGZyYW1ld29yay5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fjx1O5IQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmhAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBNTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsZWU5OGZyYW1ld29yay5wZGYAAA4AJgASAGwAZQBlADkAOABmAHIAYQBtAGUAdwBvAHIAawAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9sZWU5OGZyYW1ld29yay5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QGkxpYnJhcnkvbGVlOThmcmFtZXdvcmsucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAmQCZgJrAnQCfwKDApECmAKhAr4CwwLGAtMC2AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALq},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/43.736561}}

@inproceedings{lee87sdf,
	Abstract = {Data flow is a natural paradigm for describing DSP applications for concurrent implementation on parallel hardware. Data flow programs for signal processing are directed graphs where each node represents a function and each arc represents a signal path. Synchronous data flow (SDF) is a special case of data flow (either atomic or large grain) in which the number of data samples produced or consumed by each node on each invocation is specified a priori. Nodes can be scheduled statically (at compile time) onto single or parallel programmable processors so the run-time overhead usually associated with data flow evaporates. Multiple sample rates within the same system are easily and naturally handled. Conditions for correctness of SDF graph are explained and scheduling algorithms are described for homogeneous parallel processors sharing memory. A preliminary SDF software system for automatically generating assembly language code for DSP microcomputers is described. Two new efficiency techniques are introduced, static buffering and an extension to SDF to efficiently implement conditionals.},
	Author = {Edward A. Lee and David G. Messerschmitt},
	Booktitle = {Proceedings of the IEEE},
	Date-Added = {2008-05-02 13:30:35 -0700},
	Date-Modified = {2008-05-15 18:02:01 -0700},
	Keywords = {dataflow,concurrent},
	Month = {September},
	Number = {9},
	Pages = {1235--1245},
	Title = {Synchronous Data Flow},
	Volume = {75},
	Year = {1987},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAagAAAAAAagAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQxsZWU4N3NkZi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fhx1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBHTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsZWU4N3NkZi5wZGYAAA4AGgAMAGwAZQBlADgANwBzAGQAZgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAOlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9sZWU4N3NkZi5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QFExpYnJhcnkvbGVlODdzZGYucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAkwCTgJTAlwCZwJrAnkCgAKJAqACpQKoArUCugAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALM},
	Bdsk-Url-1 = {http://ptolemy.eecs.berkeley.edu/publications/papers/87/synchdataflow/}}

@article{pike95plan,
	Author = {Rob Pike and Dave Presotto and Sean Dorward and Bob Flandrena and Ken Thompson and Howard Trickey and Phil Winterbottom},
	Date-Added = {2008-05-01 14:05:06 -0700},
	Date-Modified = {2008-05-01 14:08:22 -0700},
	Journal = {Computing Systems},
	Keywords = {os},
	Month = {Summer},
	Number = {3},
	Pages = {221--254},
	Title = {{Plan 9} from {Bell Labs}},
	Volume = {8},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ5waWtlOTVwbGFuLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f/x1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpwaWtlOTVwbGFuLnBkZgAADgAeAA4AcABpAGsAZQA5ADUAcABsAGEAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9waWtlOTVwbGFuLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS9waWtlOTVwbGFuLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==},
	Bdsk-Url-1 = {http://citeseer.ist.psu.edu/409838.html}}

@inproceedings{dean04mapreduce,
	Abstract = {MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Many real world tasks are expressible in this model, as shown in the paper.

Programs written in this functional style are automatically parallelized and executed on a large cluster of commodity machines. The run-time system takes care of the details of partitioning the input data, scheduling the program's execution across a set of machines, handling machine failures, and managing the required inter-machine communication. This allows programmers without any experience with parallel and distributed systems to easily utilize the resources of a large distributed system.

Our implementation of MapReduce runs on a large cluster of commodity machines and is highly scalable: a typical MapReduce computation processes many terabytes of data on thousands of machines. Programmers find the system easy to use: hundreds of MapReduce programs have been implemented and upwards of one thousand MapReduce jobs are executed on Google's clusters every day.},
	Address = {Berkeley, CA, USA},
	Author = {Jeffrey Dean and Sanjay Ghemawat},
	Booktitle = {Proceedings of the 6th Symposium on Operating Systems Design and Implementation (OSDI '04)},
	Date-Added = {2008-05-01 13:55:32 -0700},
	Date-Modified = {2008-07-31 15:56:03 -0700},
	Keywords = {hpc},
	Location = {San Francisco, CA},
	Month = {December},
	Pages = {137---150},
	Publisher = {{USENIX} Association},
	Title = {{MapReduce}: simplified data processing on large clusters},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcQAAAAAAcQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRNkZWFuMDRtYXByZWR1Y2UucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1efx1O5GgAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmaAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBOTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpkZWFuMDRtYXByZWR1Y2UucGRmAA4AKAATAGQAZQBhAG4AMAA0AG0AYQBwAHIAZQBkAHUAYwBlAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgBBVXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2RlYW4wNG1hcHJlZHVjZS5wZGYAABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBtMaWJyYXJ5L2RlYW4wNG1hcHJlZHVjZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACaAJqAm8CeAKDAocClQKcAqUCwwLIAssC2ALdAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://www.usenix.net/publications/library/proceedings/osdi04/tech/dean.html}}

@inproceedings{bacon98thin,
	Abstract = {Language-supported synchronization is a source of serious performance problems in many Java programs. Even single-threaded applications may spend up to half their time performing useless synchronization due to the thread-safe nature of the Java libraries. We solve this performance problem with a new algorithm that allows lock and unlock operations to be performed with only a few machine instructions in the most common cases. Our locks only require a partial word per object, and were implemented without increasing object size. We present measurements from our implementation in the JDK 1.1.2 for AIX, demonstrating speedups of up to a factor of 5 in micro-benchmarks and up to a factor of 1.7 in real programs.},
	Address = {New York, NY, USA},
	Author = {David F. Bacon and Ravi Konuru and Chet Murthy and Mauricio Serrano},
	Booktitle = {PLDI '98: Proceedings of the ACM SIGPLAN 1998 conference on Programming language design and implementation},
	Date-Added = {2008-05-01 13:52:14 -0700},
	Date-Modified = {2008-07-15 21:17:02 -0700},
	Doi = {http://doi.acm.org/10.1145/277650.277734},
	Isbn = {0-89791-987-4},
	Keywords = {threads,pl},
	Location = {Montreal, Quebec, Canada},
	Pages = {258--268},
	Publisher = {ACM},
	Read = {Yes},
	Title = {Thin locks: featherweight synchronization for Java},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbQAAAAAAbQAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ9iYWNvbjk4dGhpbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eFx1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBKTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpiYWNvbjk4dGhpbi5wZGYADgAgAA8AYgBhAGMAbwBuADkAOAB0AGgAaQBuAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA9VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L2JhY29uOTh0aGluLnBkZgAAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QF0xpYnJhcnkvYmFjb245OHRoaW4ucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAlgCWgJfAmgCcwJ3AoUCjAKVAq8CtAK3AsQCyQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/277650.277734}}

@article{gil07swf,
	Abstract = {Workflows have emerged as a paradigm for representing and managing complex distributed computations and are used to accelerate the pace of scientific progress. A recent National Science Foundation workshop brought together domain, computer, and social scientists to discuss requirements of future scientific applications and the challenges they present to current workflow technologies.},
	Address = {Los Alamitos, CA, USA},
	Annote = {Survey of current challenges facing SWFs.  Requirements include supporting collaboration across labs, enabling reproduction of results, and flexibility to be simple for common cases but easily modified for specialized workflow needs.  The authors see sharing of workflow representations as crucial, and that depends on coming up with appropriately general representations of workflows and the processes they use.

The authors note differences between scientific and business workflows, noting that in SWFs there is a greater need for rapid reconfiguration to support experimentation.  Also, data is more heterogeneous, and may involve proprietary formats.

There is a discussion of issues in dynamic workflows.  The goal of reproducing results can be hindered by dynamic workflows unless care is taken.  This raises an interesting question of non-determinism, and how much can be tolerated in a running workflow.

The article raises the interesting question of whether machine learning could be applied to workflows execution traces, and thereby help users avoid certain conditions (e.g. incompatible parameters) or optimize for others (e.g. locating opportunities for parallelism).

Reproducibility can take two forms: scientific and engineering.  Scientific reproducibility is weaker, and requires only that equivalent results are obtained.  Engineering reproducibility is stronger, and requires that the results be reconstructed bit by bit.  The latter may be more useful in identifying and correcting problems or outlier results.  

Scaling occurs in four dimensions.  First, the number of tasks in a single workflow.  Users may find it difficult to apprehend and work with workflows consisting of a million separate, interdependent tasks.  This could be addressed with appropriate hiearchical representations.  Second, the number of workflows may scale as more scientists use the system.  This could overwhelm resources.  Third, certain external resources involved in a workflow may need to be managed at scale.  Fourth, the number of users of a workflow.  In complex scenarios, many people may be involved in designing and running a single workflow.  Their roles should be managed in scalable ways.},
	Author = {Yolanda Gil and Ewa Deelman and Mark Ellisman and Thomas Fahringer and Geoffrey Fox and Dennis Gannon and Carole Goble and Miron Livny and Luc Moreau and Jim Myers},
	Date-Added = {2008-05-01 13:14:45 -0700},
	Date-Modified = {2008-05-01 13:44:10 -0700},
	Doi = {http://doi.ieeecomputersociety.org/10.1109/MC.2007.421},
	Issn = {0018-9162},
	Journal = {Computer},
	Keywords = {workflow},
	Month = {December},
	Number = {12},
	Pages = {24-32},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {Examining the Challenges of Scientific Workflows},
	Volume = {40},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAagAAAAAAagAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQxnaWwwN3N3Zi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1e5x1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBHTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpnaWwwN3N3Zi5wZGYAAA4AGgAMAGcAaQBsADAANwBzAHcAZgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAOlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9naWwwN3N3Zi5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QFExpYnJhcnkvZ2lsMDdzd2YucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAkwCTgJTAlwCZwJrAnkCgAKJAqACpQKoArUCugAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALM},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/MC.2007.421}}

@article{oinn04taverna,
	Abstract = {Motivation: In silico experiments in bioinformatics involve the co-ordinated use of computational tools and information repositories. A growing number of these resources are being made available with programmatic access in the form of Web services. Bioinformatics scientists will need to orchestrate these Web services in workflows as part of their analyses.

Results: The Taverna project has developed a tool for the composition and enactment of bioinformatics workflows for the life sciences community. The tool includes a workbench application which provides a graphical user interface for the composition of workflows. These workflows are written in a new language called the Simple conceptual unified flow language (Scufl), where by each step within a workflow represents one atomic task. Two examples are used to illustrate the ease by with which in silico experiments can be represented as Scufl workflows using the workbench application.

Availability: The Taverna workflow system is available as open source and can be downloaded with example Scufl workflows from http://taverna.sourceforge.net.},
	Address = {Oxford, UK},
	Annote = {Bioinformatics tools are available as web services, so bioinfo workflow systems need to talk to them.  At the time Taverna was created, the authors were not aware of any other tools that were open source and had a GUI for composing workflows.  They also aimed to support provenance, and to integrate with existing tools with non-standard interfaces (e.g. Talisman and Soaplab).

Taverna workflow are represented in a XML-based language called Scufl.  A workflow in Scufl has three parts.  First, there are processors.  A processor transforms a set of input data into a set of output data, and is based on a type.  Types include WSDL, Soaplab, Talisman, nested workflow (call into another Scufl workflow hierarchically), string constant (to supply default parameters), and a local type (arbitrary Java code).  Input and outputs are also represented as processors.  Inputs and outputs can have metadata in the form of a MIME type, a semantic type based on myGrid ontology, and arbitrary text.

Second, a Scufl workflows have data links.  These define the flow of data from inputs to outputs.  A single input can be connected to multiple outputs, and each output will get a copy of the value.

Third, there are coordination constraints.  These can be used to impose extra concurrency restraints that go beyond those already imposed by the data flow.  These are rarely needed, but can be used if the processors have dependencies that are not represented in the workflow.

The Scufl workbench allows bioinformaticians (!) to create workflows graphically, without needing to learn Scufl.  It provides a palette of processors, which can be obtained by scavenging services from URLs.  

Workflows are executed using a system called Freefluo.  Freefluo is not tied to Taverna, and supports a general flow-based, message-passing execution model.

The paper details two bioinformatics workflows as case studies.

Provenance is collected during execution.  Recorded information includes the processor type, status, start and end time, and a general description of the service.  Notably, data products are not annotated, although they note that this is a goal.

Taverna can work with any standard web service, even those not developed specifically with Taverna or Scufl in mind.  Non-web service code can be used by creating a plugin for Freefluo, and a corresponding type for Scufl.},
	Author = {Tom Oinn and Matthew Addis and Justin Ferris and Darren Marvin and Martin Senger and Mark Greenwood and Tim Carver and Kevin Glover and Matthew R. Pocock and Anil Wipat and Peter Li},
	Date-Added = {2008-04-30 18:18:29 -0700},
	Date-Modified = {2008-05-05 11:53:21 -0700},
	Doi = {http://dx.doi.org/10.1093/bioinformatics/bth361},
	Issn = {1367-4803},
	Journal = {Bioinformatics},
	Keywords = {workflow},
	Month = {November},
	Number = {17},
	Pages = {3045--3054},
	Publisher = {Oxford University Press},
	Read = {Yes},
	Title = {Taverna: a tool for the composition and enactment of bioinformatics workflows},
	Volume = {20},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFvaW5uMDR0YXZlcm5hLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1f6x1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpvaW5uMDR0YXZlcm5hLnBkZgAOACQAEQBvAGkAbgBuADAANAB0AGEAdgBlAHIAbgBhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L29pbm4wNHRhdmVybmEucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9vaW5uMDR0YXZlcm5hLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1093/bioinformatics/bth361}}

@inproceedings{pugh99java,
	Abstract = {The Java memory model described in Chapter 17 of the Java Language Specification gives constraints on how threads interact through memory.  The Java memory model is hard to interpret and poorly understood; it imposes constraints that prohibit common compiler optimizations and are expensive to implement on existing hardware.  At least one shipping optimizing Java compiler violates the constraints of the existing Java memory model.  These issues are particularly important for high-performance Java applications, since they are more likely to use and need aggressive optimizing compilers and parallel processors.   In addition, programming idioms used by some programmers and used within Sun's Java Development Kit is not guaranteed to be valid according the existing Java memory model.  This paper reviews these issues and suggests replacement memory models for Java.},
	Address = {New York, NY, USA},
	Author = {William Pugh},
	Booktitle = {Proceedings of the ACM 1999 conference on Java Grande},
	Date-Added = {2008-04-30 13:17:01 -0700},
	Date-Modified = {2008-05-15 18:01:12 -0700},
	Doi = {http://doi.acm.org/10.1145/304065.304106},
	Isbn = {1-58113-161-5},
	Keywords = {threads,concurrent,pl},
	Location = {San Francisco, California, United States},
	Pages = {89--98},
	Publisher = {ACM},
	Title = {Fixing the Java memory model},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbAAAAAAAbAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhQ5wdWdoOTlqYXZhLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1gAx1O5JAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmkAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBJTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpwdWdoOTlqYXZhLnBkZgAADgAeAA4AcAB1AGcAaAA5ADkAagBhAHYAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9wdWdoOTlqYXZhLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAWTGlicmFyeS9wdWdoOTlqYXZhLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJUAlYCWwJkAm8CcwKBAogCkQKqAq8CsgK/AsQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/304065.304106}}

@webpage{web02ptolemy,
	Date-Added = {2008-04-30 11:13:01 -0700},
	Date-Modified = {2008-04-30 13:42:07 -0700},
	Keywords = {workflow},
	Read = {Yes},
	Title = {Ptolemy Project Webpage},
	Url = {http://ptolemy.eecs.berkeley.edu/},
	Year = {2002},
	Bdsk-Url-1 = {http://ptolemy.eecs.berkeley.edu/}}

@inproceedings{murata89petri,
	Abstract = {Starts with a brief review of the history and the application areas considered in the literature. The author then proceeds with introductory modeling examples, behavioral and structural properties, three methods of analysis, subclasses of Petri nets and their analysis. In particular, one section is devoted to marked graphs, the concurrent system model most amenable to analysis. Introductory discussions on stochastic nets with their application to performance modeling, and on high-level nets with their application to logic programming, are provided. Also included are recent results on reachability criteria. Suggestions are provided for further reading on many subject areas of Petri nets.},
	Author = {Tadao Murata},
	Booktitle = {Proceedings of the IEEE},
	Date-Added = {2008-04-30 11:03:06 -0700},
	Date-Modified = {2009-05-31 15:32:27 -0700},
	Doi = {10.1109/5.24143},
	Keywords = {petrinets,workflow},
	Month = {April},
	Number = {4},
	Pages = {541--580},
	Title = {Petri nets: Properties, analysis and applications},
	Volume = {77},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbwAAAAAAbwAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRFtdXJhdGE4OXBldHJpLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fzx1O5IwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmjAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBMTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTptdXJhdGE4OXBldHJpLnBkZgAOACQAEQBtAHUAcgBhAHQAYQA4ADkAcABlAHQAcgBpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA/VXNlcnMvZ2h1bGV0dGUvRG9jdW1lbnRzL0JpYmxpb2dyYXBoeS9MaWJyYXJ5L211cmF0YTg5cGV0cmkucGRmAAATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAZTGlicmFyeS9tdXJhdGE4OXBldHJpLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJgAmICZwJwAnsCfwKNApQCnQK5Ar4CwQLOAtMAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC5Q==},
	Bdsk-Url-1 = {http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=24143}}

@webpage{web07vistrails,
	Annote = {An advanced scientific workflow system.},
	Date-Added = {2008-04-29 18:19:51 -0700},
	Date-Modified = {2008-07-25 13:37:19 -0700},
	Keywords = {workflow},
	Read = {Yes},
	Title = {{VisTrails} Project Wiki},
	Url = {http://www.vistrails.org/index.php/Main_Page},
	Year = {2007},
	Bdsk-Url-1 = {http://www.vistrails.org/index.php/Main_Page}}

@article{freire08provenance,
	Abstract = {The problem of systematically capturing and managing provenance for computational tasks has recently received significant attention because of its relevance to a wide range of domains and applications. The authors give an overview of important concepts related to provenance management, so that potential users can make informed decisions when selecting or designing a provenance solution.},
	Annote = {Talks about workflow-based systems as high-level programming model that can capture the computational history automatically.  There are different levels of abstraction: the raw script, a granular workflow, and a workflow where components are collected into modules with abstract meanings (e.g. Read File, Extract Surface, etc).

Interesting quote: "A program (or script) is to a workflow what an unstructured document is to a (structured) database."

There are two kinds of provenance.  Prospective provenance is the recipe used to generate a data product.  Retrospective provenance is a log of the how and under what conditions a particular data product was generated, i.e. a detailed log.

Causality is the process (steps), input, and parameters that led to the output, and can be inferred through either retrospective or prospective provenance.  Users may want to add their own annotations to the provenance data.

Provenance systems have three major components: capture mechanisms, a representation model, and infrastructure for storage, access, and queries.

A provenance capture mechanism records the relevant details of a process.  These may be based on a (particular) workflow system, on processes conforming to some standard, or supported at the OS level.  One advantage of workflow capture mechanisms is that they can capture prospective provenance because they have access to the workflow definition; process and OS mechanisms must infer this information.  OS based tools are able to capture information not available to the other systems (e.g. temporary files used) but may capture too much detail to be useful.

All representations of provenance model process and data dependencies.  Most tend to be focused on a particular domain (e.g. Taverna provides support for bioinformatics ontologies).  It is often helpful to structure the representation into multiple layers ordered by details (e.g. REDUX uses 4 layers: abstract workflow description, specific implementation of that workflow, info about input data and parameters, and finally operational details like start and stop time).  This is helpful because it allows normalization and avoids storing redundant information.  It may also be helpful to record a workflow's evolution over time.

Provenance infrastructure systems should consider the amount of information returned in queries, since it is easy to return too much.  Specifying queries can be complicated for users, and some systems (e.g. VisTrails) use graphical queries.

This article includes a nice overview of some current workflow-based systems that support provenance, including Taverna, Karma, Kepler, Pegasus, REDUX, Swift, and VisTrails.  It also looks at non-workflow systems like PASS, ES3, and PASOA/PreServ.

},
	Author = {Juliana Freire and David Koop and Emanuele Santos and Claudio T. Silva},
	Date-Added = {2008-04-29 17:16:29 -0700},
	Date-Modified = {2009-05-14 12:08:24 -0700},
	Issn = {1521-9615},
	Journal = {Computing in Science and Engineering},
	Keywords = {workflow,provenance},
	Month = {May--June},
	Number = {3},
	Pages = {11--21},
	Read = {Yes},
	Title = {Provenance for Computational Tasks: A Survey},
	Volume = {10},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdAAAAAAAdAAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRZmcmVpcmUwOHByb3ZlbmFuY2UucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1exx1O5HAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmcAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBRTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmcmVpcmUwOHByb3ZlbmFuY2UucGRmAAAOAC4AFgBmAHIAZQBpAHIAZQAwADgAcAByAG8AdgBlAG4AYQBuAGMAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARFVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9mcmVpcmUwOHByb3ZlbmFuY2UucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEB5MaWJyYXJ5L2ZyZWlyZTA4cHJvdmVuYW5jZS5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACdAJ2AnsChAKPApMCoQKoArEC0gLXAtoC5wLsAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/MCSE.2008.79}}

@article{lee06threads,
	Abstract = {For concurrent programming to become mainstream, we must discard threads as a programming model. Nondeterminism should be judiciously and carefully introduced where needed, and it should be explicit in programs.},
	Address = {Los Alamitos, CA, USA},
	Annote = {The author argues against the use of threads, since they introduce rampant non-determinism, which makes it too difficult for programmers to reason about their programs.  Current popular methods for facilitating thread correctness (e.g. design patterns, software engineering practices, correctness checking, higher-level concurrency constructs) only reduce that non-determinism, but don't eliminate it.  Lee proposes the use of well-designed coordination languages (e.g. Ptolemy) instead of threads at high levels.  These introduce non-determinism in controlled ways where needed, and may be accepted into mainstream programming if they complement rather than supplant traditional programming languages.},
	Author = {Edward A. Lee},
	Date-Added = {2008-04-29 16:48:06 -0700},
	Date-Modified = {2008-04-30 18:23:19 -0700},
	Issn = {0018-9162},
	Journal = {Computer},
	Keywords = {threads},
	Number = {5},
	Pages = {33-42},
	Publisher = {IEEE Computer Society},
	Read = {Yes},
	Title = {The Problem with Threads},
	Volume = {39},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAbgAAAAAAbgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRBsZWUwNnRocmVhZHMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1ffx1O5IAAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmgAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBLTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpsZWUwNnRocmVhZHMucGRmAAAOACIAEABsAGUAZQAwADYAdABoAHIAZQBhAGQAcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAPlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9sZWUwNnRocmVhZHMucGRmABMAAS8AABUAAgAP//8AAIAF0hwdHh9YJGNsYXNzZXNaJGNsYXNzbmFtZaMfICFdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3RfEBhMaWJyYXJ5L2xlZTA2dGhyZWFkcy5wZGbSHB0kJaIlIVxOU0RpY3Rpb25hcnkSAAGGoF8QD05TS2V5ZWRBcmNoaXZlcgAIABEAFgAfACgAMgA1ADoAPABFAEsAUgBdAGUAbABvAHEAcwB2AHgAegB8AIYAkwCYAKACXAJeAmMCbAJ3AnsCiQKQApkCtAK5ArwCyQLOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuA=},
	Bdsk-Url-1 = {http://doi.ieeecomputersociety.org/10.1109/MC.2006.180}}

@techreport{hylands03ptolemy,
	Abstract = {The Ptolemy Project is an informal group of researchers that is part of Chess (the center for hybrid and embedded software systems) at U.C. Berkeley; see "Acknowledgements" on page 28 for a list of participants. This project conducts foundational and applied research in software based design techniques for embedded systems. Ptolemy II is the current software infrastructure of the Ptolemy Project. For the participants in the Ptolemy Project, Ptolemy II is first and foremost a laboratory for experimenting with design techniques. It is published freely in open-source form. Distribution of open-source software complements more traditional publication media, and serves as a clear, unambiguous, and complete description of our research results. Also, the open architecture and open source encourages researchers to build their own methods, leveraging and extending the core infrastructure provided by the software. This creates a community where much of the dialog is through the software. In addition, the freely available software encourages designers to try out the new design techniques that are introduced and give feedback to the Ptolemy Project. This helps guide further research. Finally, the open source software encourages commercial providers of software tools to commercialize the research results, which then helps to maximize the impact of the work.

Ptolemy II is the third generation of design software to emerge from this group, with each generation bringing a new set of problems being addressed, new emphasis, and (largely) a new group of contributors.},
	Annote = {Ptolemy II is an "architecture design language" (their words).  It provides a basic syntax of block diagrams (nodes and edges) and allows users to impose different semantics on that model.  For example, you can have a graph with FSM semantics, or one that models a Process Network (like MPI).  Futhermore, you can have models with different semantics interact in well-defined ways.

The idea of the system is that the choice of computation model affects the quality of software, because some paradigms are much more easily/concisely expressed in one model than another.  Therefore choosing the right model is an engineering choice, one not widely acknowledged in traditional software design.  

Ptolemy's nodes are based on Actors (based on, but not identical to, Agha's actors).  The semantics of interactions between actors are the model of computation.  

Concurrent models provided include CSPs, continuous time, a bunch of different real-time models, FSM, Process Networks (Kahn-type, ensures determinism), and synchronous dataflow (SDF).  Ptolemy has its roots in models for embedded computing, hence the large number of real-time models.},
	Author = {Christopher Hylands and Edward Lee and Jie Liu and Xiaojun Liu and Stephen Neuendorffer and Yuhong Xiong and Yang Zhao and Haiyang Zheng},
	Date-Added = {2008-04-29 16:38:08 -0700},
	Date-Modified = {2009-05-14 11:59:33 -0700},
	Institution = {University of California Berkeley},
	Keywords = {workflow},
	Read = {Yes},
	Title = {Overview of the {P}tolemy project},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRoeWxhbmRzMDNwdG9sZW15LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1fNx1O5HQAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmdAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpoeWxhbmRzMDNwdG9sZW15LnBkZgAADgAqABQAaAB5AGwAYQBuAGQAcwAwADMAcAB0AG8AbABlAG0AeQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9oeWxhbmRzMDNwdG9sZW15LnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9oeWxhbmRzMDNwdG9sZW15LnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://ptolemy.eecs.berkeley.edu/publications/papers/03/overview/}}

@webpage{web08hpcsw,
	Annote = {Allen went to this conference.  The web page has links to some interesting presentations on high performance computing.},
	Date-Added = {2008-04-29 16:35:17 -0700},
	Date-Modified = {2008-05-16 14:32:26 -0700},
	Keywords = {hpc},
	Read = {Yes},
	Title = {High Performance Computer Science Week Presentations},
	Url = {http://www.hpcsw.org/presentations/index.shtml},
	Year = {2008},
	Bdsk-Url-1 = {http://www.hpcsw.org/presentations/index.shtml}}

@webpage{web08acsr,
	Annote = {From the HPCSW meeting, Allen wanted me to look at these presentations, focusing on the need for more scalable tools in scientific research.  The gist is that both task- and data-parallelism are underserved by the current generation of MPI-based programming models.

Ian Foster, Argonne National Laboratory
From the Heroic to the Logistical: Programming Model Implications of New Supercomputing Applications

Arie Shoshani, Lawrence Berkeley National Laboratory
Scientific Data Management: Technologies, Applicaitons, and Future Needs

Nathan Barton, Lawrence Livermore National Laboratory
Novel Algorithms in Computational Materials Science: Enabling Adaptive Sampling
},
	Date-Added = {2008-04-29 16:32:34 -0700},
	Date-Modified = {2008-05-16 14:32:54 -0700},
	Keywords = {hpc},
	Read = {Yes},
	Title = {ASCR Computer Science Research PI Presentations},
	Url = {http://www.hpcsw.org/pi_meeting/presentations/},
	Year = {2008},
	Bdsk-Url-1 = {http://www.hpcsw.org/pi_meeting/presentations/}}

@article{fetzer88verification,
	Abstract = {The notion of program verification appears to trade upon an equivocation. Algorithms, as logical structures, are appropriate subjects for deductive verification. Programs, as causal models of those structures, are not. The success of program verification as a generally applicable and completely reliable method for guaranteeing program performance is not even a theoretical possibility.},
	Address = {New York, NY, USA},
	Author = {James H. Fetzer},
	Date-Added = {2008-04-29 16:20:49 -0700},
	Date-Modified = {2009-05-14 11:57:46 -0700},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Keywords = {verification},
	Number = {9},
	Pages = {1048--1063},
	Publisher = {ACM},
	Read = {Yes},
	Title = {Program verification: the very idea},
	Volume = {31},
	Year = {1988},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAdgAAAAAAdgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRhmZXR6ZXI4OHZlcmlmaWNhdGlvbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1epx1O5GwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmbAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBTTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTpmZXR6ZXI4OHZlcmlmaWNhdGlvbi5wZGYAAA4AMgAYAGYAZQB0AHoAZQByADgAOAB2AGUAcgBpAGYAaQBjAGEAdABpAG8AbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIARlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9mZXR6ZXI4OHZlcmlmaWNhdGlvbi5wZGYAEwABLwAAFQACAA///wAAgAXSHB0eH1gkY2xhc3Nlc1okY2xhc3NuYW1lox8gIV1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdF8QIExpYnJhcnkvZmV0emVyODh2ZXJpZmljYXRpb24ucGRm0hwdJCWiJSFcTlNEaWN0aW9uYXJ5EgABhqBfEA9OU0tleWVkQXJjaGl2ZXIACAARABYAHwAoADIANQA6ADwARQBLAFIAXQBlAGwAbwBxAHMAdgB4AHoAfACGAJMAmACgAnwCfgKDAowClwKbAqkCsAK5AtwC4QLkAvEC9gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMI},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/48529.48530}}

@inproceedings{altintas04kepler,
	Abstract = {Most scientists conduct analyses and run models in several different software and hardware environments, mentally coordinating the export and import of data from one environment to another. The Kepler scientific workflow system provides domain scientists with an easy-to-use yet powerful system for capturing scientific workflows (SWFs). SWFs are a formalization of the ad-hoc process that a scientist may go through to get from raw data to publishable results. Kepler attempts to streamline the workflow creation and execution process so that scientists can design, execute, monitor, re-run, and communicate analytical procedures repeatedly with minimal effort. Kepler is unique in that it seamlessly combines high-level workflow design with execution and runtime interaction, access to local and remote data, and local and remote service invocation. SWFs are superficially similar to business process workflows but have several challenges not present in the business workflow scenario. For example, they often operate on large, complex and heterogeneous data, can be computationally intensive and produce complex derived data products that may be archived for use in reparameterized runs or other workflows. Moreover, unlike business workflows, SWFs are often dataflow-oriented as witnessed by a number of recent academic systems (e.g., DiscoveryNet, Taverna and Triana) and commercial systems (Scitegic/Pipeline-Pilot, Inforsense). In a sense, SWFs are often closer to signal-processing and data streaming applications than they are to control-oriented business workflow applications.},
	Annote = {Kepler is a scientific workflow system based on Ptolemy II.  The authors note that SWFs have special requirements beyond typical business workflows: they can use and produce large, hetergeneous datasets and can be computationally complex.  They also note that SWFs are dataflow-based.  Components in Kepler are actors, just like in Ptolemy.  It extends Ptolomy in ways that, in their view, facilitates creation of scientific workflows.  It adds prototyping of workflows, where a scientist can lay out the actor's name and ports, and the system will generate a stub to be filled in with code (presumably Java code).  Distributed execution is enabled using web and grid services.  These are realized as a special local actor that can be configured to access any WSDL-based web service.  They also define special grid-based actors like "GlobusJob" and "GridFTP".  There are special actors for accessing databases.  Kepler supports execution in languages other than Java through JNI, including Matlab and Python.  Kepler/Ptolomy supports a multi-dataflow execution model, and they contend that competitors (Taverna, Triana, SCIRun) are limited to one.

Mentions some other SWF systems.  Academic examples: Taverna, Triana, and DiscoveryNet.  Commercial examples: Scitegic/Pipeline-Pilot, and Inforsense.

Questions:  What is multi-dataflow execution and why is that helpful?  Is Kepler "just" a set of actors for Ptolomy?
},
	Author = {Ilkay Altintas and Chad Berkley and Efrat Jaeger and Matthew Jones and Bertram Lud{\"a}scher and Steve Mock},
	Booktitle = {Proceedings of the 16th International Conference on Scientific and Statistical Database Management 2004},
	Date-Added = {2008-04-29 15:41:03 -0700},
	Date-Modified = {2008-07-25 13:40:37 -0700},
	Keywords = {workflow},
	Pages = {423--424},
	Read = {Yes},
	Title = {{Kepler}: an extensible system for design and execution of scientific workflows},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUIJidUJHRvcFgkb2JqZWN0c1gkdmVyc2lvblkkYXJjaGl2ZXLRBgdUcm9vdIABqAkKFRYXGyIjVSRudWxs0wsMDQ4RFFpOUy5vYmplY3RzV05TLmtleXNWJGNsYXNzog8QgASABqISE4ACgAOAB1lhbGlhc0RhdGFccmVsYXRpdmVQYXRo0hgNGRpXTlMuZGF0YU8RAcgAAAAAAcgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMZqmo5IKwAAAEdZhRRhbHRpbnRhczA0a2VwbGVyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1d+x1O5FwAAAAAAAAAAAAEAAwAACSAAAAAAAAAAAAAAAAAAAAAHTGlicmFyeQAAEAAIAADGavz+AAAAEQAIAADHVCmXAAAAAQAUAEdZhQBHVtwACMDMAAjAtQAAeYkAAgBPTWFjaW50b3NoIEhEOlVzZXJzOmdodWxldHRlOkRvY3VtZW50czpCaWJsaW9ncmFwaHk6TGlicmFyeTphbHRpbnRhczA0a2VwbGVyLnBkZgAADgAqABQAYQBsAHQAaQBuAHQAYQBzADAANABrAGUAcABsAGUAcgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQlVzZXJzL2dodWxldHRlL0RvY3VtZW50cy9CaWJsaW9ncmFwaHkvTGlicmFyeS9hbHRpbnRhczA0a2VwbGVyLnBkZgATAAEvAAAVAAIAD///AACABdIcHR4fWCRjbGFzc2VzWiRjbGFzc25hbWWjHyAhXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN0XxAcTGlicmFyeS9hbHRpbnRhczA0a2VwbGVyLnBkZtIcHSQloiUhXE5TRGljdGlvbmFyeRIAAYagXxAPTlNLZXllZEFyY2hpdmVyAAgAEQAWAB8AKAAyADUAOgA8AEUASwBSAF0AZQBsAG8AcQBzAHYAeAB6AHwAhgCTAJgAoAJsAm4CcwJ8AocCiwKZAqACqQLIAs0C0ALdAuIAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC9A==},
	Bdsk-Url-1 = {http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1311241}}

@comment{BibDesk Static Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>group name</key>
		<string>Area Exam</string>
		<key>keys</key>
		<string>chakravarty03haskellffi,pierce02reconstruct,coulouris94sunrpc,smolinski99interop,hopkins00component,slee07thrift,wilson94suif,abadi89dynamic,kaplan01exu,rossberg06dynamic,tay90rpc,reid00fortran,milner78atheory,spec03xmlrpc,barrett96polyspin,birrell84rpc,folk2003attributes,furr06jni,lattner04llvm,swamy09coercions,reppy06ffi,goodale03cactus,liao06openuh,reid08fortran,panda07ejb,folk2000introduction,bracha92jigsaw,murphy08open64,ravitch09bindings,macqueen84modules,furr08check,hamilton03clr,fisher01interop,jones97greencard,ms06cli,demichiel06ejb,trifonov99safe,batory97genvoca,pierce02subtyping,curbera02soap,nierstrasz95composition,beazley96swig,visser01survey,blume01nlffi,matthews09semantics,schordan03rose,kohn01babel,visser98core,janssen94ilu,mathworksmexfiles,waldo98jrmi,grechanik04polylingual,armstrong99common,pierce02rectypes,sousa99formal,rfc1832,liang99jni,breazu91coercion,kaplan98idl,quinlan99rose,reid07fortran,benton99interlang,baader98term,lindlan98pdt,vinoski97corba,flanagan06hybrid,goodale07expressing,gosling00java,hirzel07jeannie,cardelli88asemantics,rasmussen01chasm,pierce02subtypingtheory,spec00soap11,huelsbergen96mlffi</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>Not printed</string>
		<key>keys</key>
		<string>gosling00java,pierce02subtyping,pierce02rectypes,demichiel06ejb,pierce02reconstruct,pierce02subtypingtheory,spec00soap11,baader98term,liang99jni,ms06cli</string>
	</dict>
</array>
</plist>
}}
